
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/svm/plot_linearsvc_support_vectors.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_svm_plot_linearsvc_support_vectors.py>`
        to download the full example code or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_svm_plot_linearsvc_support_vectors.py:


=====================================
Plot the support vectors in LinearSVC
=====================================

Unlike SVC (based on LIBSVM), LinearSVC (based on LIBLINEAR) does not provide
the support vectors. This example demonstrates how to obtain the support
vectors in LinearSVC.

.. GENERATED FROM PYTHON SOURCE LINES 11-59



.. image-sg:: /auto_examples/svm/images/sphx_glr_plot_linearsvc_support_vectors_001.png
   :alt: C=1, C=100
   :srcset: /auto_examples/svm/images/sphx_glr_plot_linearsvc_support_vectors_001.png
   :class: sphx-glr-single-img





.. code-block:: default


    import matplotlib.pyplot as plt
    import numpy as np

    from sklearn.datasets import make_blobs
    from sklearn.inspection import DecisionBoundaryDisplay
    from sklearn.svm import LinearSVC

    X, y = make_blobs(n_samples=40, centers=2, random_state=0)

    plt.figure(figsize=(10, 5))
    for i, C in enumerate([1, 100]):
        # "hinge" is the standard SVM loss
        clf = LinearSVC(C=C, loss="hinge", random_state=42, dual="auto").fit(X, y)
        # obtain the support vectors through the decision function
        decision_function = clf.decision_function(X)
        # we can also calculate the decision function manually
        # decision_function = np.dot(X, clf.coef_[0]) + clf.intercept_[0]
        # The support vectors are the samples that lie within the margin
        # boundaries, whose size is conventionally constrained to 1
        support_vector_indices = np.where(np.abs(decision_function) <= 1 + 1e-15)[0]
        support_vectors = X[support_vector_indices]

        plt.subplot(1, 2, i + 1)
        plt.scatter(X[:, 0], X[:, 1], c=y, s=30, cmap=plt.cm.Paired)
        ax = plt.gca()
        DecisionBoundaryDisplay.from_estimator(
            clf,
            X,
            ax=ax,
            grid_resolution=50,
            plot_method="contour",
            colors="k",
            levels=[-1, 0, 1],
            alpha=0.5,
            linestyles=["--", "-", "--"],
        )
        plt.scatter(
            support_vectors[:, 0],
            support_vectors[:, 1],
            s=100,
            linewidth=1,
            facecolors="none",
            edgecolors="k",
        )
        plt.title("C=" + str(C))
    plt.tight_layout()
    plt.show()


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.123 seconds)


.. _sphx_glr_download_auto_examples_svm_plot_linearsvc_support_vectors.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: binder-badge

      .. image:: images/binder_badge_logo.svg
        :target: https://mybinder.org/v2/gh/scikit-learn/scikit-learn/1.3.X?urlpath=lab/tree/notebooks/auto_examples/svm/plot_linearsvc_support_vectors.ipynb
        :alt: Launch binder
        :width: 150 px



    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_linearsvc_support_vectors.py <plot_linearsvc_support_vectors.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_linearsvc_support_vectors.ipynb <plot_linearsvc_support_vectors.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
