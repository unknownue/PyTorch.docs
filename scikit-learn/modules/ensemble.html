

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="1.11. Ensembles: Gradient boosting, random forests, bagging, voting, stacking" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://scikit-learn/stable/modules/ensemble.html" />
<meta property="og:site_name" content="scikit-learn" />
<meta property="og:description" content="Ensemble methods combine the predictions of several base estimators built with a given learning algorithm in order to improve generalizability / robustness over a single estimator. Two very famous ..." />
<meta property="og:image" content="https://scikit-learn/stable/_images/sphx_glr_plot_gradient_boosting_regression_001.png" />
<meta property="og:image:alt" content="scikit-learn" />
<meta name="description" content="Ensemble methods combine the predictions of several base estimators built with a given learning algorithm in order to improve generalizability / robustness over a single estimator. Two very famous ..." />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
  <title>1.11. Ensembles: Gradient boosting, random forests, bagging, voting, stacking &mdash; scikit-learn 1.3.2 documentation</title>
  
  <link rel="canonical" href="http://scikit-learn.org/stable/modules/ensemble.html" />

  
  <link rel="shortcut icon" href="../_static/favicon.ico"/>
  

  <link rel="stylesheet" href="../_static/css/vendor/bootstrap.min.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../_static/plot_directive.css" type="text/css" />
  <link rel="stylesheet" href="../_static/sg_gallery.css" type="text/css" />
  <link rel="stylesheet" href="../_static/sg_gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../_static/sg_gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../_static/sg_gallery-rendered-html.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
<script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
<script src="../_static/js/vendor/jquery-3.6.3.slim.min.js"></script> 
</head>
<body>






<nav id="navbar" class="sk-docs-navbar navbar navbar-expand-md navbar-light bg-light py-0">
  <div class="container-fluid sk-docs-container px-0">
      <a class="navbar-brand py-0" href="../index.html">
        <img
          class="sk-brand-img"
          src="../_static/scikit-learn-logo-small.png"
          alt="logo"/>
      </a>
    <button
      id="sk-navbar-toggler"
      class="navbar-toggler"
      type="button"
      data-toggle="collapse"
      data-target="#navbarSupportedContent"
      aria-controls="navbarSupportedContent"
      aria-expanded="false"
      aria-label="Toggle navigation"
    >
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="sk-navbar-collapse collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav mr-auto">
        <li class="nav-item">
          <a class="sk-nav-link nav-link" href="../install.html">Install</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link" href="../user_guide.html">User Guide</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link" href="classes.html">API</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link" href="../auto_examples/index.html">Examples</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link" target="_blank" rel="noopener noreferrer" href="https://blog.scikit-learn.org/">Community</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../getting_started.html" >Getting Started</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../tutorial/index.html" >Tutorial</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../whats_new/v1.3.html" >What's new</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../glossary.html" >Glossary</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="https://scikit-learn.org/dev/developers/index.html" target="_blank" rel="noopener noreferrer">Development</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../faq.html" >FAQ</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../support.html" >Support</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../related_projects.html" >Related packages</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../roadmap.html" >Roadmap</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../governance.html" >Governance</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../about.html" >About us</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="https://github.com/scikit-learn/scikit-learn" >GitHub</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="https://scikit-learn.org/dev/versions.html" >Other Versions and Download</a>
        </li>
        <li class="nav-item dropdown nav-more-item-dropdown">
          <a class="sk-nav-link nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">More</a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
              <a class="sk-nav-dropdown-item dropdown-item" href="../getting_started.html" >Getting Started</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../tutorial/index.html" >Tutorial</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../whats_new/v1.3.html" >What's new</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../glossary.html" >Glossary</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="https://scikit-learn.org/dev/developers/index.html" target="_blank" rel="noopener noreferrer">Development</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../faq.html" >FAQ</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../support.html" >Support</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../related_projects.html" >Related packages</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../roadmap.html" >Roadmap</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../governance.html" >Governance</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../about.html" >About us</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="https://github.com/scikit-learn/scikit-learn" >GitHub</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="https://scikit-learn.org/dev/versions.html" >Other Versions and Download</a>
          </div>
        </li>
      </ul>
      <div id="searchbox" role="search">
          <div class="searchformwrapper">
          <form class="search" action="../search.html" method="get">
            <input class="sk-search-text-input" type="text" name="q" aria-labelledby="searchlabel" />
            <input class="sk-search-text-btn" type="submit" value="Go" />
          </form>
          </div>
      </div>
    </div>
  </div>
</nav>
<div class="d-flex" id="sk-doc-wrapper">
    <input type="checkbox" name="sk-toggle-checkbox" id="sk-toggle-checkbox">
    <label id="sk-sidemenu-toggle" class="sk-btn-toggle-toc btn sk-btn-primary" for="sk-toggle-checkbox">Toggle Menu</label>
    <div id="sk-sidebar-wrapper" class="border-right">
      <div class="sk-sidebar-toc-wrapper">
        <div class="btn-group w-100 mb-2" role="group" aria-label="rellinks">
            <a href="tree.html" role="button" class="btn sk-btn-rellink py-1" sk-rellink-tooltip="1.10. Decision Trees">Prev</a><a href="../supervised_learning.html" role="button" class="btn sk-btn-rellink py-1" sk-rellink-tooltip="1. Supervised learning">Up</a>
            <a href="multiclass.html" role="button" class="btn sk-btn-rellink py-1" sk-rellink-tooltip="1.12. Multiclass and multioutput algorithms">Next</a>
        </div>
        <div class="alert alert-danger p-1 mb-2" role="alert">
          <p class="text-center mb-0">
          <strong>scikit-learn 1.3.2</strong><br/>
          <a href="http://scikit-learn.org/dev/versions.html">Other versions</a>
          </p>
        </div>
        <div class="alert alert-warning p-1 mb-2" role="alert">
          <p class="text-center mb-0">
            Please <a class="font-weight-bold" href="../about.html#citing-scikit-learn"><string>cite us</string></a> if you use the software.
          </p>
        </div>
            <div class="sk-sidebar-toc">
              <ul>
<li><a class="reference internal" href="#">1.11. Ensembles: Gradient boosting, random forests, bagging, voting, stacking</a><ul>
<li><a class="reference internal" href="#gradient-boosted-trees">1.11.1. Gradient-boosted trees</a><ul>
<li><a class="reference internal" href="#histogram-based-gradient-boosting">1.11.1.1. Histogram-Based Gradient Boosting</a><ul>
<li><a class="reference internal" href="#usage">1.11.1.1.1. Usage</a></li>
<li><a class="reference internal" href="#missing-values-support">1.11.1.1.2. Missing values support</a></li>
<li><a class="reference internal" href="#sample-weight-support">1.11.1.1.3. Sample weight support</a></li>
<li><a class="reference internal" href="#categorical-features-support">1.11.1.1.4. Categorical Features Support</a></li>
<li><a class="reference internal" href="#monotonic-constraints">1.11.1.1.5. Monotonic Constraints</a></li>
<li><a class="reference internal" href="#interaction-constraints">1.11.1.1.6. Interaction constraints</a></li>
<li><a class="reference internal" href="#low-level-parallelism">1.11.1.1.7. Low-level parallelism</a></li>
<li><a class="reference internal" href="#why-it-s-faster">1.11.1.1.8. Why it’s faster</a></li>
</ul>
</li>
<li><a class="reference internal" href="#gradientboostingclassifier-and-gradientboostingregressor">1.11.1.2. <code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingClassifier</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingRegressor</span></code></a><ul>
<li><a class="reference internal" href="#classification">1.11.1.2.1. Classification</a></li>
<li><a class="reference internal" href="#regression">1.11.1.2.2. Regression</a></li>
<li><a class="reference internal" href="#fitting-additional-weak-learners">1.11.1.2.3. Fitting additional weak-learners</a></li>
<li><a class="reference internal" href="#controlling-the-tree-size">1.11.1.2.4. Controlling the tree size</a></li>
<li><a class="reference internal" href="#mathematical-formulation">1.11.1.2.5. Mathematical formulation</a><ul>
<li><a class="reference internal" href="#id9">1.11.1.2.5.1. Regression</a></li>
<li><a class="reference internal" href="#id10">1.11.1.2.5.2. Classification</a></li>
</ul>
</li>
<li><a class="reference internal" href="#loss-functions">1.11.1.2.6. Loss Functions</a></li>
<li><a class="reference internal" href="#shrinkage-via-learning-rate">1.11.1.2.7. Shrinkage via learning rate</a></li>
<li><a class="reference internal" href="#subsampling">1.11.1.2.8. Subsampling</a></li>
<li><a class="reference internal" href="#interpretation-with-feature-importance">1.11.1.2.9. Interpretation with feature importance</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#random-forests-and-other-randomized-tree-ensembles">1.11.2. Random forests and other randomized tree ensembles</a><ul>
<li><a class="reference internal" href="#random-forests">1.11.2.1. Random Forests</a></li>
<li><a class="reference internal" href="#extremely-randomized-trees">1.11.2.2. Extremely Randomized Trees</a></li>
<li><a class="reference internal" href="#parameters">1.11.2.3. Parameters</a></li>
<li><a class="reference internal" href="#parallelization">1.11.2.4. Parallelization</a></li>
<li><a class="reference internal" href="#feature-importance-evaluation">1.11.2.5. Feature importance evaluation</a></li>
<li><a class="reference internal" href="#totally-random-trees-embedding">1.11.2.6. Totally Random Trees Embedding</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bagging-meta-estimator">1.11.3. Bagging meta-estimator</a></li>
<li><a class="reference internal" href="#voting-classifier">1.11.4. Voting Classifier</a><ul>
<li><a class="reference internal" href="#majority-class-labels-majority-hard-voting">1.11.4.1. Majority Class Labels (Majority/Hard Voting)</a></li>
<li><a class="reference internal" href="#id24">1.11.4.2. Usage</a></li>
<li><a class="reference internal" href="#weighted-average-probabilities-soft-voting">1.11.4.3. Weighted Average Probabilities (Soft Voting)</a></li>
<li><a class="reference internal" href="#using-the-votingclassifier-with-gridsearchcv">1.11.4.4. Using the <code class="docutils literal notranslate"><span class="pre">VotingClassifier</span></code> with <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code></a></li>
<li><a class="reference internal" href="#id25">1.11.4.5. Usage</a></li>
</ul>
</li>
<li><a class="reference internal" href="#voting-regressor">1.11.5. Voting Regressor</a><ul>
<li><a class="reference internal" href="#id27">1.11.5.1. Usage</a></li>
</ul>
</li>
<li><a class="reference internal" href="#stacked-generalization">1.11.6. Stacked generalization</a></li>
<li><a class="reference internal" href="#adaboost">1.11.7. AdaBoost</a><ul>
<li><a class="reference internal" href="#id35">1.11.7.1. Usage</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            </div>
      </div>
    </div>
    <div id="sk-page-content-wrapper">
      <div class="sk-page-content container-fluid body px-md-3" role="main">
        
  <section id="ensembles-gradient-boosting-random-forests-bagging-voting-stacking">
<span id="ensemble"></span><h1><span class="section-number">1.11. </span>Ensembles: Gradient boosting, random forests, bagging, voting, stacking<a class="headerlink" href="#ensembles-gradient-boosting-random-forests-bagging-voting-stacking" title="Link to this heading">¶</a></h1>
<p><strong>Ensemble methods</strong> combine the predictions of several
base estimators built with a given learning algorithm in order to improve
generalizability / robustness over a single estimator.</p>
<p>Two very famous examples of ensemble methods are <a class="reference internal" href="#gradient-boosting"><span class="std std-ref">gradient-boosted trees</span></a> and <a class="reference internal" href="#forest"><span class="std std-ref">random forests</span></a>.</p>
<p>More generally, ensemble models can be applied to any base learner beyond
trees, in averaging methods such as <a class="reference internal" href="#bagging"><span class="std std-ref">Bagging methods</span></a>,
<a class="reference internal" href="#stacking"><span class="std std-ref">model stacking</span></a>, or <a class="reference internal" href="#voting-classifier"><span class="std std-ref">Voting</span></a>, or in
boosting, as <a class="reference internal" href="#adaboost"><span class="std std-ref">AdaBoost</span></a>.</p>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#gradient-boosted-trees" id="id36">Gradient-boosted trees</a></p></li>
<li><p><a class="reference internal" href="#random-forests-and-other-randomized-tree-ensembles" id="id37">Random forests and other randomized tree ensembles</a></p></li>
<li><p><a class="reference internal" href="#bagging-meta-estimator" id="id38">Bagging meta-estimator</a></p></li>
<li><p><a class="reference internal" href="#voting-classifier" id="id39">Voting Classifier</a></p></li>
<li><p><a class="reference internal" href="#voting-regressor" id="id40">Voting Regressor</a></p></li>
<li><p><a class="reference internal" href="#stacked-generalization" id="id41">Stacked generalization</a></p></li>
<li><p><a class="reference internal" href="#adaboost" id="id42">AdaBoost</a></p></li>
</ul>
</nav>
<section id="gradient-boosted-trees">
<span id="gradient-boosting"></span><h2><a class="toc-backref" href="#id36" role="doc-backlink"><span class="section-number">1.11.1. </span>Gradient-boosted trees</a><a class="headerlink" href="#gradient-boosted-trees" title="Link to this heading">¶</a></h2>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Gradient_boosting">Gradient Tree Boosting</a>
or Gradient Boosted Decision Trees (GBDT) is a generalization
of boosting to arbitrary differentiable loss functions, see the seminal work of
<a class="reference internal" href="#friedman2001" id="id1"><span>[Friedman2001]</span></a>. GBDT is an excellent model for both regression and
classification, in particular for tabular data.</p>
<aside class="topic">
<p class="topic-title"><a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingClassifier.html#sklearn.ensemble.GradientBoostingClassifier" title="sklearn.ensemble.GradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingClassifier</span></code></a> vs <a class="reference internal" href="generated/sklearn.ensemble.HistGradientBoostingClassifier.html#sklearn.ensemble.HistGradientBoostingClassifier" title="sklearn.ensemble.HistGradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">HistGradientBoostingClassifier</span></code></a></p>
<p>Scikit-learn provides two implementations of gradient-boosted trees:
<a class="reference internal" href="generated/sklearn.ensemble.HistGradientBoostingClassifier.html#sklearn.ensemble.HistGradientBoostingClassifier" title="sklearn.ensemble.HistGradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">HistGradientBoostingClassifier</span></code></a> vs
<a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingClassifier.html#sklearn.ensemble.GradientBoostingClassifier" title="sklearn.ensemble.GradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingClassifier</span></code></a> for classification, and the
corresponding classes for regression. The former can be <strong>orders of
magnitude faster</strong> than the latter when the number of samples is
larger than tens of thousands of samples.</p>
<p>Missing values and categorical data are natively supported by the
Hist… version, removing the need for additional preprocessing such as
imputation.</p>
<p><a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingClassifier.html#sklearn.ensemble.GradientBoostingClassifier" title="sklearn.ensemble.GradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingClassifier</span></code></a> and
<a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingRegressor.html#sklearn.ensemble.GradientBoostingRegressor" title="sklearn.ensemble.GradientBoostingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingRegressor</span></code></a>, might be preferred for small sample
sizes since binning may lead to split points that are too approximate
in this setting.</p>
</aside>
<section id="histogram-based-gradient-boosting">
<span id="id2"></span><h3><span class="section-number">1.11.1.1. </span>Histogram-Based Gradient Boosting<a class="headerlink" href="#histogram-based-gradient-boosting" title="Link to this heading">¶</a></h3>
<p>Scikit-learn 0.21 introduced two new implementations of
gradient boosted trees, namely <a class="reference internal" href="generated/sklearn.ensemble.HistGradientBoostingClassifier.html#sklearn.ensemble.HistGradientBoostingClassifier" title="sklearn.ensemble.HistGradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">HistGradientBoostingClassifier</span></code></a>
and <a class="reference internal" href="generated/sklearn.ensemble.HistGradientBoostingRegressor.html#sklearn.ensemble.HistGradientBoostingRegressor" title="sklearn.ensemble.HistGradientBoostingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">HistGradientBoostingRegressor</span></code></a>, inspired by
<a class="reference external" href="https://github.com/Microsoft/LightGBM">LightGBM</a> (See <a class="reference internal" href="#lightgbm" id="id3"><span>[LightGBM]</span></a>).</p>
<p>These histogram-based estimators can be <strong>orders of magnitude faster</strong>
than <a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingClassifier.html#sklearn.ensemble.GradientBoostingClassifier" title="sklearn.ensemble.GradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingClassifier</span></code></a> and
<a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingRegressor.html#sklearn.ensemble.GradientBoostingRegressor" title="sklearn.ensemble.GradientBoostingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingRegressor</span></code></a> when the number of samples is larger
than tens of thousands of samples.</p>
<p>They also have built-in support for missing values, which avoids the need
for an imputer.</p>
<p>These fast estimators first bin the input samples <code class="docutils literal notranslate"><span class="pre">X</span></code> into
integer-valued bins (typically 256 bins) which tremendously reduces the
number of splitting points to consider, and allows the algorithm to
leverage integer-based data structures (histograms) instead of relying on
sorted continuous values when building the trees. The API of these
estimators is slightly different, and some of the features from
<a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingClassifier.html#sklearn.ensemble.GradientBoostingClassifier" title="sklearn.ensemble.GradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingClassifier</span></code></a> and <a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingRegressor.html#sklearn.ensemble.GradientBoostingRegressor" title="sklearn.ensemble.GradientBoostingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingRegressor</span></code></a>
are not yet supported, for instance some loss functions.</p>
<aside class="topic">
<p class="topic-title">Examples:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../auto_examples/inspection/plot_partial_dependence.html#sphx-glr-auto-examples-inspection-plot-partial-dependence-py"><span class="std std-ref">Partial Dependence and Individual Conditional Expectation Plots</span></a></p></li>
</ul>
</aside>
<section id="usage">
<h4><span class="section-number">1.11.1.1.1. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">¶</a></h4>
<p>Most of the parameters are unchanged from
<a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingClassifier.html#sklearn.ensemble.GradientBoostingClassifier" title="sklearn.ensemble.GradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingClassifier</span></code></a> and <a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingRegressor.html#sklearn.ensemble.GradientBoostingRegressor" title="sklearn.ensemble.GradientBoostingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingRegressor</span></code></a>.
One exception is the <code class="docutils literal notranslate"><span class="pre">max_iter</span></code> parameter that replaces <code class="docutils literal notranslate"><span class="pre">n_estimators</span></code>, and
controls the number of iterations of the boosting process:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">HistGradientBoostingClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_hastie_10_2</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_hastie_10_2</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:</span><span class="mi">2000</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="mi">2000</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="mi">2000</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">2000</span><span class="p">:]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">HistGradientBoostingClassifier</span><span class="p">(</span><span class="n">max_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
<span class="go">0.8965</span>
</pre></div>
</div>
<p>Available losses for regression are ‘squared_error’,
‘absolute_error’, which is less sensitive to outliers, and
‘poisson’, which is well suited to model counts and frequencies. For
classification, ‘log_loss’ is the only option. For binary classification it uses the
binary log loss, also known as binomial deviance or binary cross-entropy. For
<code class="docutils literal notranslate"><span class="pre">n_classes</span> <span class="pre">&gt;=</span> <span class="pre">3</span></code>, it uses the multi-class log loss function, with multinomial deviance
and categorical cross-entropy as alternative names. The appropriate loss version is
selected based on <a class="reference internal" href="../glossary.html#term-y"><span class="xref std std-term">y</span></a> passed to <a class="reference internal" href="../glossary.html#term-fit"><span class="xref std std-term">fit</span></a>.</p>
<p>The size of the trees can be controlled through the <code class="docutils literal notranslate"><span class="pre">max_leaf_nodes</span></code>,
<code class="docutils literal notranslate"><span class="pre">max_depth</span></code>, and <code class="docutils literal notranslate"><span class="pre">min_samples_leaf</span></code> parameters.</p>
<p>The number of bins used to bin the data is controlled with the <code class="docutils literal notranslate"><span class="pre">max_bins</span></code>
parameter. Using less bins acts as a form of regularization. It is
generally recommended to use as many bins as possible (256), which is the default.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">l2_regularization</span></code> parameter is a regularizer on the loss function and
corresponds to <span class="math notranslate nohighlight">\(\lambda\)</span> in equation (2) of <a class="reference internal" href="#xgboost" id="id4"><span>[XGBoost]</span></a>.</p>
<p>Note that <strong>early-stopping is enabled by default if the number of samples is
larger than 10,000</strong>. The early-stopping behaviour is controlled via the
<code class="docutils literal notranslate"><span class="pre">early_stopping</span></code>, <code class="docutils literal notranslate"><span class="pre">scoring</span></code>, <code class="docutils literal notranslate"><span class="pre">validation_fraction</span></code>,
<code class="docutils literal notranslate"><span class="pre">n_iter_no_change</span></code>, and <code class="docutils literal notranslate"><span class="pre">tol</span></code> parameters. It is possible to early-stop
using an arbitrary <a class="reference internal" href="../glossary.html#term-scorer"><span class="xref std std-term">scorer</span></a>, or just the training or validation loss.
Note that for technical reasons, using a scorer is significantly slower than
using the loss. By default, early-stopping is performed if there are at least
10,000 samples in the training set, and uses the validation loss.</p>
</section>
<section id="missing-values-support">
<h4><span class="section-number">1.11.1.1.2. </span>Missing values support<a class="headerlink" href="#missing-values-support" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="generated/sklearn.ensemble.HistGradientBoostingClassifier.html#sklearn.ensemble.HistGradientBoostingClassifier" title="sklearn.ensemble.HistGradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">HistGradientBoostingClassifier</span></code></a> and
<a class="reference internal" href="generated/sklearn.ensemble.HistGradientBoostingRegressor.html#sklearn.ensemble.HistGradientBoostingRegressor" title="sklearn.ensemble.HistGradientBoostingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">HistGradientBoostingRegressor</span></code></a> have built-in support for missing
values (NaNs).</p>
<p>During training, the tree grower learns at each split point whether samples
with missing values should go to the left or right child, based on the
potential gain. When predicting, samples with missing values are assigned to
the left or right child consequently:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">HistGradientBoostingClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">gbdt</span> <span class="o">=</span> <span class="n">HistGradientBoostingClassifier</span><span class="p">(</span><span class="n">min_samples_leaf</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gbdt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([0, 0, 1, 1])</span>
</pre></div>
</div>
<p>When the missingness pattern is predictive, the splits can be performed on
whether the feature value is missing or not:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gbdt</span> <span class="o">=</span> <span class="n">HistGradientBoostingClassifier</span><span class="p">(</span><span class="n">min_samples_leaf</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>                                      <span class="n">max_depth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                                      <span class="n">learning_rate</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>                                      <span class="n">max_iter</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gbdt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([0, 1, 0, 0, 1])</span>
</pre></div>
</div>
<p>If no missing values were encountered for a given feature during training,
then samples with missing values are mapped to whichever child has the most
samples.</p>
</section>
<section id="sample-weight-support">
<span id="sw-hgbdt"></span><h4><span class="section-number">1.11.1.1.3. </span>Sample weight support<a class="headerlink" href="#sample-weight-support" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="generated/sklearn.ensemble.HistGradientBoostingClassifier.html#sklearn.ensemble.HistGradientBoostingClassifier" title="sklearn.ensemble.HistGradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">HistGradientBoostingClassifier</span></code></a> and
<a class="reference internal" href="generated/sklearn.ensemble.HistGradientBoostingRegressor.html#sklearn.ensemble.HistGradientBoostingRegressor" title="sklearn.ensemble.HistGradientBoostingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">HistGradientBoostingRegressor</span></code></a> support sample weights during
<a class="reference internal" href="../glossary.html#term-fit"><span class="xref std std-term">fit</span></a>.</p>
<p>The following toy example demonstrates that samples with a sample weight of zero are ignored:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>     <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># ignore the first 2 training samples by setting their weight to 0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample_weight</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gb</span> <span class="o">=</span> <span class="n">HistGradientBoostingClassifier</span><span class="p">(</span><span class="n">min_samples_leaf</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gb</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_weight</span><span class="o">=</span><span class="n">sample_weight</span><span class="p">)</span>
<span class="go">HistGradientBoostingClassifier(...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gb</span><span class="o">.</span><span class="n">predict</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="go">array([1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gb</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">0.99...</span>
</pre></div>
</div>
<p>As you can see, the <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">0]</span></code> is comfortably classified as <code class="docutils literal notranslate"><span class="pre">1</span></code> since the first
two samples are ignored due to their sample weights.</p>
<p>Implementation detail: taking sample weights into account amounts to
multiplying the gradients (and the hessians) by the sample weights. Note that
the binning stage (specifically the quantiles computation) does not take the
weights into account.</p>
</section>
<section id="categorical-features-support">
<span id="categorical-support-gbdt"></span><h4><span class="section-number">1.11.1.1.4. </span>Categorical Features Support<a class="headerlink" href="#categorical-features-support" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="generated/sklearn.ensemble.HistGradientBoostingClassifier.html#sklearn.ensemble.HistGradientBoostingClassifier" title="sklearn.ensemble.HistGradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">HistGradientBoostingClassifier</span></code></a> and
<a class="reference internal" href="generated/sklearn.ensemble.HistGradientBoostingRegressor.html#sklearn.ensemble.HistGradientBoostingRegressor" title="sklearn.ensemble.HistGradientBoostingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">HistGradientBoostingRegressor</span></code></a> have native support for categorical
features: they can consider splits on non-ordered, categorical data.</p>
<p>For datasets with categorical features, using the native categorical support
is often better than relying on one-hot encoding
(<a class="reference internal" href="generated/sklearn.preprocessing.OneHotEncoder.html#sklearn.preprocessing.OneHotEncoder" title="sklearn.preprocessing.OneHotEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">OneHotEncoder</span></code></a>), because one-hot encoding
requires more tree depth to achieve equivalent splits. It is also usually
better to rely on the native categorical support rather than to treat
categorical features as continuous (ordinal), which happens for ordinal-encoded
categorical data, since categories are nominal quantities where order does not
matter.</p>
<p>To enable categorical support, a boolean mask can be passed to the
<code class="docutils literal notranslate"><span class="pre">categorical_features</span></code> parameter, indicating which feature is categorical. In
the following, the first feature will be treated as categorical and the
second feature as numerical:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gbdt</span> <span class="o">=</span> <span class="n">HistGradientBoostingClassifier</span><span class="p">(</span><span class="n">categorical_features</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
</pre></div>
</div>
<p>Equivalently, one can pass a list of integers indicating the indices of the
categorical features:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gbdt</span> <span class="o">=</span> <span class="n">HistGradientBoostingClassifier</span><span class="p">(</span><span class="n">categorical_features</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>The cardinality of each categorical feature must be less than the <code class="docutils literal notranslate"><span class="pre">max_bins</span></code>
parameter, and each categorical feature is expected to be encoded in
<code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">max_bins</span> <span class="pre">-</span> <span class="pre">1]</span></code>. To that end, it might be useful to pre-process the data
with an <a class="reference internal" href="generated/sklearn.preprocessing.OrdinalEncoder.html#sklearn.preprocessing.OrdinalEncoder" title="sklearn.preprocessing.OrdinalEncoder"><code class="xref py py-class docutils literal notranslate"><span class="pre">OrdinalEncoder</span></code></a> as done in
<a class="reference internal" href="../auto_examples/ensemble/plot_gradient_boosting_categorical.html#sphx-glr-auto-examples-ensemble-plot-gradient-boosting-categorical-py"><span class="std std-ref">Categorical Feature Support in Gradient Boosting</span></a>.</p>
<p>If there are missing values during training, the missing values will be
treated as a proper category. If there are no missing values during training,
then at prediction time, missing values are mapped to the child node that has
the most samples (just like for continuous features). When predicting,
categories that were not seen during fit time will be treated as missing
values.</p>
<p><strong>Split finding with categorical features</strong>: The canonical way of considering
categorical splits in a tree is to consider
all of the <span class="math notranslate nohighlight">\(2^{K - 1} - 1\)</span> partitions, where <span class="math notranslate nohighlight">\(K\)</span> is the number of
categories. This can quickly become prohibitive when <span class="math notranslate nohighlight">\(K\)</span> is large.
Fortunately, since gradient boosting trees are always regression trees (even
for classification problems), there exist a faster strategy that can yield
equivalent splits. First, the categories of a feature are sorted according to
the variance of the target, for each category <code class="docutils literal notranslate"><span class="pre">k</span></code>. Once the categories are
sorted, one can consider <em>continuous partitions</em>, i.e. treat the categories
as if they were ordered continuous values (see Fisher <a class="reference internal" href="#fisher1958" id="id5"><span>[Fisher1958]</span></a> for a
formal proof). As a result, only <span class="math notranslate nohighlight">\(K - 1\)</span> splits need to be considered
instead of <span class="math notranslate nohighlight">\(2^{K - 1} - 1\)</span>. The initial sorting is a
<span class="math notranslate nohighlight">\(\mathcal{O}(K \log(K))\)</span> operation, leading to a total complexity of
<span class="math notranslate nohighlight">\(\mathcal{O}(K \log(K) + K)\)</span>, instead of <span class="math notranslate nohighlight">\(\mathcal{O}(2^K)\)</span>.</p>
<aside class="topic">
<p class="topic-title">Examples:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../auto_examples/ensemble/plot_gradient_boosting_categorical.html#sphx-glr-auto-examples-ensemble-plot-gradient-boosting-categorical-py"><span class="std std-ref">Categorical Feature Support in Gradient Boosting</span></a></p></li>
</ul>
</aside>
</section>
<section id="monotonic-constraints">
<span id="monotonic-cst-gbdt"></span><h4><span class="section-number">1.11.1.1.5. </span>Monotonic Constraints<a class="headerlink" href="#monotonic-constraints" title="Link to this heading">¶</a></h4>
<p>Depending on the problem at hand, you may have prior knowledge indicating
that a given feature should in general have a positive (or negative) effect
on the target value. For example, all else being equal, a higher credit
score should increase the probability of getting approved for a loan.
Monotonic constraints allow you to incorporate such prior knowledge into the
model.</p>
<p>For a predictor <span class="math notranslate nohighlight">\(F\)</span> with two features:</p>
<blockquote>
<div><ul>
<li><dl>
<dt>a <strong>monotonic increase constraint</strong> is a constraint of the form:</dt><dd><div class="math notranslate nohighlight">
\[x_1 \leq x_1' \implies F(x_1, x_2) \leq F(x_1', x_2)\]</div>
</dd>
</dl>
</li>
<li><dl>
<dt>a <strong>monotonic decrease constraint</strong> is a constraint of the form:</dt><dd><div class="math notranslate nohighlight">
\[x_1 \leq x_1' \implies F(x_1, x_2) \geq F(x_1', x_2)\]</div>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>You can specify a monotonic constraint on each feature using the
<code class="docutils literal notranslate"><span class="pre">monotonic_cst</span></code> parameter. For each feature, a value of 0 indicates no
constraint, while 1 and -1 indicate a monotonic increase and
monotonic decrease constraint, respectively:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">HistGradientBoostingRegressor</span>

<span class="go">... # monotonic increase, monotonic decrease, and no constraint on the 3 features</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gbdt</span> <span class="o">=</span> <span class="n">HistGradientBoostingRegressor</span><span class="p">(</span><span class="n">monotonic_cst</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p>In a binary classification context, imposing a monotonic increase (decrease) constraint means that higher values of the feature are supposed
to have a positive (negative) effect on the probability of samples
to belong to the positive class.</p>
<p>Nevertheless, monotonic constraints only marginally constrain feature effects on the output.
For instance, monotonic increase and decrease constraints cannot be used to enforce the
following modelling constraint:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[x_1 \leq x_1' \implies F(x_1, x_2) \leq F(x_1', x_2')\]</div>
</div></blockquote>
<p>Also, monotonic constraints are not supported for multiclass classification.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since categories are unordered quantities, it is not possible to enforce
monotonic constraints on categorical features.</p>
</div>
<aside class="topic">
<p class="topic-title">Examples:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../auto_examples/ensemble/plot_monotonic_constraints.html#sphx-glr-auto-examples-ensemble-plot-monotonic-constraints-py"><span class="std std-ref">Monotonic Constraints</span></a></p></li>
</ul>
</aside>
</section>
<section id="interaction-constraints">
<span id="interaction-cst-hgbt"></span><h4><span class="section-number">1.11.1.1.6. </span>Interaction constraints<a class="headerlink" href="#interaction-constraints" title="Link to this heading">¶</a></h4>
<p>A priori, the histogram gradient boosted trees are allowed to use any feature
to split a node into child nodes. This creates so called interactions between
features, i.e. usage of different features as split along a branch. Sometimes,
one wants to restrict the possible interactions, see <a class="reference internal" href="#mayer2022" id="id6"><span>[Mayer2022]</span></a>. This can be
done by the parameter <code class="docutils literal notranslate"><span class="pre">interaction_cst</span></code>, where one can specify the indices
of features that are allowed to interact.
For instance, with 3 features in total, <code class="docutils literal notranslate"><span class="pre">interaction_cst=[{0},</span> <span class="pre">{1},</span> <span class="pre">{2}]</span></code>
forbids all interactions.
The constraints <code class="docutils literal notranslate"><span class="pre">[{0,</span> <span class="pre">1},</span> <span class="pre">{1,</span> <span class="pre">2}]</span></code> specifies two groups of possibly
interacting features. Features 0 and 1 may interact with each other, as well
as features 1 and 2. But note that features 0 and 2 are forbidden to interact.
The following depicts a tree and the possible splits of the tree:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>   1      &lt;- Both constraint groups could be applied from now on
  / \
 1   2    &lt;- Left split still fulfills both constraint groups.
/ \ / \      Right split at feature 2 has only group {1, 2} from now on.
</pre></div>
</div>
<p>LightGBM uses the same logic for overlapping groups.</p>
<p>Note that features not listed in <code class="docutils literal notranslate"><span class="pre">interaction_cst</span></code> are automatically
assigned an interaction group for themselves. With again 3 features, this
means that <code class="docutils literal notranslate"><span class="pre">[{0}]</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">[{0},</span> <span class="pre">{1,</span> <span class="pre">2}]</span></code>.</p>
<aside class="topic">
<p class="topic-title">Examples:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../auto_examples/inspection/plot_partial_dependence.html#sphx-glr-auto-examples-inspection-plot-partial-dependence-py"><span class="std std-ref">Partial Dependence and Individual Conditional Expectation Plots</span></a></p></li>
</ul>
</aside>
<aside class="topic">
<p class="topic-title">References</p>
<div role="list" class="citation-list">
<div class="citation" id="mayer2022" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">Mayer2022</a><span class="fn-bracket">]</span></span>
<p>M. Mayer, S.C. Bourassa, M. Hoesli, and D.F. Scognamiglio.
2022. <a class="reference external" href="https://doi.org/10.3390/jrfm15050193">Machine Learning Applications to Land and Structure Valuation</a>.
Journal of Risk and Financial Management 15, no. 5: 193</p>
</div>
</div>
</aside>
</section>
<section id="low-level-parallelism">
<h4><span class="section-number">1.11.1.1.7. </span>Low-level parallelism<a class="headerlink" href="#low-level-parallelism" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="generated/sklearn.ensemble.HistGradientBoostingClassifier.html#sklearn.ensemble.HistGradientBoostingClassifier" title="sklearn.ensemble.HistGradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">HistGradientBoostingClassifier</span></code></a> and
<a class="reference internal" href="generated/sklearn.ensemble.HistGradientBoostingRegressor.html#sklearn.ensemble.HistGradientBoostingRegressor" title="sklearn.ensemble.HistGradientBoostingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">HistGradientBoostingRegressor</span></code></a> use OpenMP
for parallelization through Cython. For more details on how to control the
number of threads, please refer to our <a class="reference internal" href="../computing/parallelism.html#parallelism"><span class="std std-ref">Parallelism</span></a> notes.</p>
<p>The following parts are parallelized:</p>
<ul class="simple">
<li><p>mapping samples from real values to integer-valued bins (finding the bin
thresholds is however sequential)</p></li>
<li><p>building histograms is parallelized over features</p></li>
<li><p>finding the best split point at a node is parallelized over features</p></li>
<li><p>during fit, mapping samples into the left and right children is
parallelized over samples</p></li>
<li><p>gradient and hessians computations are parallelized over samples</p></li>
<li><p>predicting is parallelized over samples</p></li>
</ul>
</section>
<section id="why-it-s-faster">
<span id="id7"></span><h4><span class="section-number">1.11.1.1.8. </span>Why it’s faster<a class="headerlink" href="#why-it-s-faster" title="Link to this heading">¶</a></h4>
<p>The bottleneck of a gradient boosting procedure is building the decision
trees. Building a traditional decision tree (as in the other GBDTs
<a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingClassifier.html#sklearn.ensemble.GradientBoostingClassifier" title="sklearn.ensemble.GradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingClassifier</span></code></a> and <a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingRegressor.html#sklearn.ensemble.GradientBoostingRegressor" title="sklearn.ensemble.GradientBoostingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingRegressor</span></code></a>)
requires sorting the samples at each node (for
each feature). Sorting is needed so that the potential gain of a split point
can be computed efficiently. Splitting a single node has thus a complexity
of <span class="math notranslate nohighlight">\(\mathcal{O}(n_\text{features} \times n \log(n))\)</span> where <span class="math notranslate nohighlight">\(n\)</span>
is the number of samples at the node.</p>
<p><a class="reference internal" href="generated/sklearn.ensemble.HistGradientBoostingClassifier.html#sklearn.ensemble.HistGradientBoostingClassifier" title="sklearn.ensemble.HistGradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">HistGradientBoostingClassifier</span></code></a> and
<a class="reference internal" href="generated/sklearn.ensemble.HistGradientBoostingRegressor.html#sklearn.ensemble.HistGradientBoostingRegressor" title="sklearn.ensemble.HistGradientBoostingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">HistGradientBoostingRegressor</span></code></a>, in contrast, do not require sorting the
feature values and instead use a data-structure called a histogram, where the
samples are implicitly ordered. Building a histogram has a
<span class="math notranslate nohighlight">\(\mathcal{O}(n)\)</span> complexity, so the node splitting procedure has a
<span class="math notranslate nohighlight">\(\mathcal{O}(n_\text{features} \times n)\)</span> complexity, much smaller
than the previous one. In addition, instead of considering <span class="math notranslate nohighlight">\(n\)</span> split
points, we consider only <code class="docutils literal notranslate"><span class="pre">max_bins</span></code> split points, which might be much
smaller.</p>
<p>In order to build histograms, the input data <code class="docutils literal notranslate"><span class="pre">X</span></code> needs to be binned into
integer-valued bins. This binning procedure does require sorting the feature
values, but it only happens once at the very beginning of the boosting process
(not at each node, like in <a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingClassifier.html#sklearn.ensemble.GradientBoostingClassifier" title="sklearn.ensemble.GradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingClassifier</span></code></a> and
<a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingRegressor.html#sklearn.ensemble.GradientBoostingRegressor" title="sklearn.ensemble.GradientBoostingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingRegressor</span></code></a>).</p>
<p>Finally, many parts of the implementation of
<a class="reference internal" href="generated/sklearn.ensemble.HistGradientBoostingClassifier.html#sklearn.ensemble.HistGradientBoostingClassifier" title="sklearn.ensemble.HistGradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">HistGradientBoostingClassifier</span></code></a> and
<a class="reference internal" href="generated/sklearn.ensemble.HistGradientBoostingRegressor.html#sklearn.ensemble.HistGradientBoostingRegressor" title="sklearn.ensemble.HistGradientBoostingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">HistGradientBoostingRegressor</span></code></a> are parallelized.</p>
<aside class="topic">
<p class="topic-title">References</p>
<div role="list" class="citation-list">
<div class="citation" id="xgboost" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">XGBoost</a><span class="fn-bracket">]</span></span>
<p>Tianqi Chen, Carlos Guestrin, <a class="reference external" href="https://arxiv.org/abs/1603.02754">“XGBoost: A Scalable Tree
Boosting System”</a></p>
</div>
<div class="citation" id="lightgbm" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">LightGBM</a><span class="fn-bracket">]</span></span>
<p>Ke et. al. <a class="reference external" href="https://papers.nips.cc/paper/6907-lightgbm-a-highly-efficient-gradient-boosting-decision-tree">“LightGBM: A Highly Efficient Gradient
BoostingDecision Tree”</a></p>
</div>
<div class="citation" id="fisher1958" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">Fisher1958</a><span class="fn-bracket">]</span></span>
<p>Fisher, W.D. (1958). <a class="reference external" href="http://csiss.ncgia.ucsb.edu/SPACE/workshops/2004/SAC/files/fisher.pdf">“On Grouping for Maximum Homogeneity”</a>
Journal of the American Statistical Association, 53, 789-798.</p>
</div>
</div>
</aside>
</section>
</section>
<section id="gradientboostingclassifier-and-gradientboostingregressor">
<h3><span class="section-number">1.11.1.2. </span><a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingClassifier.html#sklearn.ensemble.GradientBoostingClassifier" title="sklearn.ensemble.GradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingClassifier</span></code></a> and <a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingRegressor.html#sklearn.ensemble.GradientBoostingRegressor" title="sklearn.ensemble.GradientBoostingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingRegressor</span></code></a><a class="headerlink" href="#gradientboostingclassifier-and-gradientboostingregressor" title="Link to this heading">¶</a></h3>
<p>The usage and the parameters of <a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingClassifier.html#sklearn.ensemble.GradientBoostingClassifier" title="sklearn.ensemble.GradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingClassifier</span></code></a> and
<a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingRegressor.html#sklearn.ensemble.GradientBoostingRegressor" title="sklearn.ensemble.GradientBoostingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingRegressor</span></code></a> are described below. The 2 most important
parameters of these estimators are <code class="docutils literal notranslate"><span class="pre">n_estimators</span></code> and <code class="docutils literal notranslate"><span class="pre">learning_rate</span></code>.</p>
<section id="classification">
<h4><span class="section-number">1.11.1.2.1. </span>Classification<a class="headerlink" href="#classification" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingClassifier.html#sklearn.ensemble.GradientBoostingClassifier" title="sklearn.ensemble.GradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingClassifier</span></code></a> supports both binary and multi-class
classification.
The following example shows how to fit a gradient boosting classifier
with 100 decision stumps as weak learners:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_hastie_10_2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">GradientBoostingClassifier</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_hastie_10_2</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:</span><span class="mi">2000</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="mi">2000</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="mi">2000</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">2000</span><span class="p">:]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">GradientBoostingClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">max_depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
<span class="go">0.913...</span>
</pre></div>
</div>
<p>The number of weak learners (i.e. regression trees) is controlled by the
parameter <code class="docutils literal notranslate"><span class="pre">n_estimators</span></code>; <a class="reference internal" href="#gradient-boosting-tree-size"><span class="std std-ref">The size of each tree</span></a> can be controlled either by setting the tree
depth via <code class="docutils literal notranslate"><span class="pre">max_depth</span></code> or by setting the number of leaf nodes via
<code class="docutils literal notranslate"><span class="pre">max_leaf_nodes</span></code>. The <code class="docutils literal notranslate"><span class="pre">learning_rate</span></code> is a hyper-parameter in the range
(0.0, 1.0] that controls overfitting via <a class="reference internal" href="#gradient-boosting-shrinkage"><span class="std std-ref">shrinkage</span></a> .</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Classification with more than 2 classes requires the induction
of <code class="docutils literal notranslate"><span class="pre">n_classes</span></code> regression trees at each iteration,
thus, the total number of induced trees equals
<code class="docutils literal notranslate"><span class="pre">n_classes</span> <span class="pre">*</span> <span class="pre">n_estimators</span></code>. For datasets with a large number
of classes we strongly recommend to use
<a class="reference internal" href="generated/sklearn.ensemble.HistGradientBoostingClassifier.html#sklearn.ensemble.HistGradientBoostingClassifier" title="sklearn.ensemble.HistGradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">HistGradientBoostingClassifier</span></code></a> as an alternative to
<a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingClassifier.html#sklearn.ensemble.GradientBoostingClassifier" title="sklearn.ensemble.GradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingClassifier</span></code></a> .</p>
</div>
</section>
<section id="regression">
<h4><span class="section-number">1.11.1.2.2. </span>Regression<a class="headerlink" href="#regression" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingRegressor.html#sklearn.ensemble.GradientBoostingRegressor" title="sklearn.ensemble.GradientBoostingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingRegressor</span></code></a> supports a number of
<a class="reference internal" href="#gradient-boosting-loss"><span class="std std-ref">different loss functions</span></a>
for regression which can be specified via the argument
<code class="docutils literal notranslate"><span class="pre">loss</span></code>; the default loss function for regression is squared error
(<code class="docutils literal notranslate"><span class="pre">'squared_error'</span></code>).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_squared_error</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_friedman1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">GradientBoostingRegressor</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_friedman1</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">1200</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:</span><span class="mi">200</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="mi">200</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="mi">200</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">200</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">est</span> <span class="o">=</span> <span class="n">GradientBoostingRegressor</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;squared_error&#39;</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">est</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">))</span>
<span class="go">5.00...</span>
</pre></div>
</div>
<p>The figure below shows the results of applying <a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingRegressor.html#sklearn.ensemble.GradientBoostingRegressor" title="sklearn.ensemble.GradientBoostingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingRegressor</span></code></a>
with least squares loss and 500 base learners to the diabetes dataset
(<a class="reference internal" href="generated/sklearn.datasets.load_diabetes.html#sklearn.datasets.load_diabetes" title="sklearn.datasets.load_diabetes"><code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.datasets.load_diabetes</span></code></a>).
The plot shows the train and test error at each iteration.
The train error at each iteration is stored in the
<code class="docutils literal notranslate"><span class="pre">train_score_</span></code> attribute of the gradient boosting model.
The test error at each iterations can be obtained
via the <a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingRegressor.html#sklearn.ensemble.GradientBoostingRegressor.staged_predict" title="sklearn.ensemble.GradientBoostingRegressor.staged_predict"><code class="xref py py-meth docutils literal notranslate"><span class="pre">staged_predict</span></code></a> method which returns a
generator that yields the predictions at each stage. Plots like these can be used
to determine the optimal number of trees (i.e. <code class="docutils literal notranslate"><span class="pre">n_estimators</span></code>) by early stopping.</p>
<figure class="align-center">
<a class="reference external image-reference" href="../auto_examples/ensemble/plot_gradient_boosting_regression.html"><img alt="../_images/sphx_glr_plot_gradient_boosting_regression_001.png" src="../_images/sphx_glr_plot_gradient_boosting_regression_001.png" style="width: 450.0px; height: 450.0px;" /></a>
</figure>
<aside class="topic">
<p class="topic-title">Examples:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../auto_examples/ensemble/plot_gradient_boosting_regression.html#sphx-glr-auto-examples-ensemble-plot-gradient-boosting-regression-py"><span class="std std-ref">Gradient Boosting regression</span></a></p></li>
<li><p><a class="reference internal" href="../auto_examples/ensemble/plot_gradient_boosting_oob.html#sphx-glr-auto-examples-ensemble-plot-gradient-boosting-oob-py"><span class="std std-ref">Gradient Boosting Out-of-Bag estimates</span></a></p></li>
</ul>
</aside>
</section>
<section id="fitting-additional-weak-learners">
<span id="gradient-boosting-warm-start"></span><h4><span class="section-number">1.11.1.2.3. </span>Fitting additional weak-learners<a class="headerlink" href="#fitting-additional-weak-learners" title="Link to this heading">¶</a></h4>
<p>Both <a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingRegressor.html#sklearn.ensemble.GradientBoostingRegressor" title="sklearn.ensemble.GradientBoostingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingRegressor</span></code></a> and <a class="reference internal" href="generated/sklearn.ensemble.GradientBoostingClassifier.html#sklearn.ensemble.GradientBoostingClassifier" title="sklearn.ensemble.GradientBoostingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GradientBoostingClassifier</span></code></a>
support <code class="docutils literal notranslate"><span class="pre">warm_start=True</span></code> which allows you to add more estimators to an already
fitted model.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">est</span><span class="o">.</span><span class="n">set_params</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">warm_start</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># set warm_start and new nr of trees</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">est</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span> <span class="c1"># fit additional 100 trees to est</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">est</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">))</span>
<span class="go">3.84...</span>
</pre></div>
</div>
</section>
<section id="controlling-the-tree-size">
<span id="gradient-boosting-tree-size"></span><h4><span class="section-number">1.11.1.2.4. </span>Controlling the tree size<a class="headerlink" href="#controlling-the-tree-size" title="Link to this heading">¶</a></h4>
<p>The size of the regression tree base learners defines the level of variable
interactions that can be captured by the gradient boosting model. In general,
a tree of depth <code class="docutils literal notranslate"><span class="pre">h</span></code> can capture interactions of order <code class="docutils literal notranslate"><span class="pre">h</span></code> .
There are two ways in which the size of the individual regression trees can
be controlled.</p>
<p>If you specify <code class="docutils literal notranslate"><span class="pre">max_depth=h</span></code> then complete binary trees
of depth <code class="docutils literal notranslate"><span class="pre">h</span></code> will be grown. Such trees will have (at most) <code class="docutils literal notranslate"><span class="pre">2**h</span></code> leaf nodes
and <code class="docutils literal notranslate"><span class="pre">2**h</span> <span class="pre">-</span> <span class="pre">1</span></code> split nodes.</p>
<p>Alternatively, you can control the tree size by specifying the number of
leaf nodes via the parameter <code class="docutils literal notranslate"><span class="pre">max_leaf_nodes</span></code>. In this case,
trees will be grown using best-first search where nodes with the highest improvement
in impurity will be expanded first.
A tree with <code class="docutils literal notranslate"><span class="pre">max_leaf_nodes=k</span></code> has <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">-</span> <span class="pre">1</span></code> split nodes and thus can
model interactions of up to order <code class="docutils literal notranslate"><span class="pre">max_leaf_nodes</span> <span class="pre">-</span> <span class="pre">1</span></code> .</p>
<p>We found that <code class="docutils literal notranslate"><span class="pre">max_leaf_nodes=k</span></code> gives comparable results to <code class="docutils literal notranslate"><span class="pre">max_depth=k-1</span></code>
but is significantly faster to train at the expense of a slightly higher
training error.
The parameter <code class="docutils literal notranslate"><span class="pre">max_leaf_nodes</span></code> corresponds to the variable <code class="docutils literal notranslate"><span class="pre">J</span></code> in the
chapter on gradient boosting in <a class="reference internal" href="#friedman2001" id="id8"><span>[Friedman2001]</span></a> and is related to the parameter
<code class="docutils literal notranslate"><span class="pre">interaction.depth</span></code> in R’s gbm package where <code class="docutils literal notranslate"><span class="pre">max_leaf_nodes</span> <span class="pre">==</span> <span class="pre">interaction.depth</span> <span class="pre">+</span> <span class="pre">1</span></code> .</p>
</section>
<section id="mathematical-formulation">
<h4><span class="section-number">1.11.1.2.5. </span>Mathematical formulation<a class="headerlink" href="#mathematical-formulation" title="Link to this heading">¶</a></h4>
<p>We first present GBRT for regression, and then detail the classification
case.</p>
<section id="id9">
<h5><span class="section-number">1.11.1.2.5.1. </span>Regression<a class="headerlink" href="#id9" title="Link to this heading">¶</a></h5>
<p>GBRT regressors are additive models whose prediction <span class="math notranslate nohighlight">\(\hat{y}_i\)</span> for a
given input <span class="math notranslate nohighlight">\(x_i\)</span> is of the following form:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\hat{y}_i = F_M(x_i) = \sum_{m=1}^{M} h_m(x_i)\]</div>
</div></blockquote>
<p>where the <span class="math notranslate nohighlight">\(h_m\)</span> are estimators called <em>weak learners</em> in the context
of boosting. Gradient Tree Boosting uses <a class="reference internal" href="tree.html#tree"><span class="std std-ref">decision tree regressors</span></a> of fixed size as weak learners. The constant M corresponds to the
<code class="docutils literal notranslate"><span class="pre">n_estimators</span></code> parameter.</p>
<p>Similar to other boosting algorithms, a GBRT is built in a greedy fashion:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[F_m(x) = F_{m-1}(x) + h_m(x),\]</div>
</div></blockquote>
<p>where the newly added tree <span class="math notranslate nohighlight">\(h_m\)</span> is fitted in order to minimize a sum
of losses <span class="math notranslate nohighlight">\(L_m\)</span>, given the previous ensemble <span class="math notranslate nohighlight">\(F_{m-1}\)</span>:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[h_m =  \arg\min_{h} L_m = \arg\min_{h} \sum_{i=1}^{n}
l(y_i, F_{m-1}(x_i) + h(x_i)),\]</div>
</div></blockquote>
<p>where <span class="math notranslate nohighlight">\(l(y_i, F(x_i))\)</span> is defined by the <code class="docutils literal notranslate"><span class="pre">loss</span></code> parameter, detailed
in the next section.</p>
<p>By default, the initial model <span class="math notranslate nohighlight">\(F_{0}\)</span> is chosen as the constant that
minimizes the loss: for a least-squares loss, this is the empirical mean of
the target values. The initial model can also be specified via the <code class="docutils literal notranslate"><span class="pre">init</span></code>
argument.</p>
<p>Using a first-order Taylor approximation, the value of <span class="math notranslate nohighlight">\(l\)</span> can be
approximated as follows:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[l(y_i, F_{m-1}(x_i) + h_m(x_i)) \approx
l(y_i, F_{m-1}(x_i))
+ h_m(x_i)
\left[ \frac{\partial l(y_i, F(x_i))}{\partial F(x_i)} \right]_{F=F_{m - 1}}.\]</div>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Briefly, a first-order Taylor approximation says that
<span class="math notranslate nohighlight">\(l(z) \approx l(a) + (z - a) \frac{\partial l}{\partial z}(a)\)</span>.
Here, <span class="math notranslate nohighlight">\(z\)</span> corresponds to <span class="math notranslate nohighlight">\(F_{m - 1}(x_i) + h_m(x_i)\)</span>, and
<span class="math notranslate nohighlight">\(a\)</span> corresponds to <span class="math notranslate nohighlight">\(F_{m-1}(x_i)\)</span></p>
</div>
<p>The quantity <span class="math notranslate nohighlight">\(\left[ \frac{\partial l(y_i, F(x_i))}{\partial F(x_i)}
\right]_{F=F_{m - 1}}\)</span> is the derivative of the loss with respect to its
second parameter, evaluated at <span class="math notranslate nohighlight">\(F_{m-1}(x)\)</span>. It is easy to compute for
any given <span class="math notranslate nohighlight">\(F_{m - 1}(x_i)\)</span> in a closed form since the loss is
differentiable. We will denote it by <span class="math notranslate nohighlight">\(g_i\)</span>.</p>
<p>Removing the constant terms, we have:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[h_m \approx \arg\min_{h} \sum_{i=1}^{n} h(x_i) g_i\]</div>
</div></blockquote>
<p>This is minimized if <span class="math notranslate nohighlight">\(h(x_i)\)</span> is fitted to predict a value that is
proportional to the negative gradient <span class="math notranslate nohighlight">\(-g_i\)</span>. Therefore, at each
iteration, <strong>the estimator</strong> <span class="math notranslate nohighlight">\(h_m\)</span> <strong>is fitted to predict the negative
gradients of the samples</strong>. The gradients are updated at each iteration.
This can be considered as some kind of gradient descent in a functional
space.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For some losses, e.g. <code class="docutils literal notranslate"><span class="pre">'absolute_error'</span></code> where the gradients
are <span class="math notranslate nohighlight">\(\pm 1\)</span>, the values predicted by a fitted <span class="math notranslate nohighlight">\(h_m\)</span> are not
accurate enough: the tree can only output integer values. As a result, the
leaves values of the tree <span class="math notranslate nohighlight">\(h_m\)</span> are modified once the tree is
fitted, such that the leaves values minimize the loss <span class="math notranslate nohighlight">\(L_m\)</span>. The
update is loss-dependent: for the absolute error loss, the value of
a leaf is updated to the median of the samples in that leaf.</p>
</div>
</section>
<section id="id10">
<h5><span class="section-number">1.11.1.2.5.2. </span>Classification<a class="headerlink" href="#id10" title="Link to this heading">¶</a></h5>
<p>Gradient boosting for classification is very similar to the regression case.
However, the sum of the trees <span class="math notranslate nohighlight">\(F_M(x_i) = \sum_m h_m(x_i)\)</span> is not
homogeneous to a prediction: it cannot be a class, since the trees predict
continuous values.</p>
<p>The mapping from the value <span class="math notranslate nohighlight">\(F_M(x_i)\)</span> to a class or a probability is
loss-dependent. For the log-loss, the probability that
<span class="math notranslate nohighlight">\(x_i\)</span> belongs to the positive class is modeled as <span class="math notranslate nohighlight">\(p(y_i = 1 |
x_i) = \sigma(F_M(x_i))\)</span> where <span class="math notranslate nohighlight">\(\sigma\)</span> is the sigmoid or expit function.</p>
<p>For multiclass classification, K trees (for K classes) are built at each of
the <span class="math notranslate nohighlight">\(M\)</span> iterations. The probability that <span class="math notranslate nohighlight">\(x_i\)</span> belongs to class
k is modeled as a softmax of the <span class="math notranslate nohighlight">\(F_{M,k}(x_i)\)</span> values.</p>
<p>Note that even for a classification task, the <span class="math notranslate nohighlight">\(h_m\)</span> sub-estimator is
still a regressor, not a classifier. This is because the sub-estimators are
trained to predict (negative) <em>gradients</em>, which are always continuous
quantities.</p>
</section>
</section>
<section id="loss-functions">
<span id="gradient-boosting-loss"></span><h4><span class="section-number">1.11.1.2.6. </span>Loss Functions<a class="headerlink" href="#loss-functions" title="Link to this heading">¶</a></h4>
<p>The following loss functions are supported and can be specified using
the parameter <code class="docutils literal notranslate"><span class="pre">loss</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><p>Regression</p>
<ul>
<li><p>Squared error (<code class="docutils literal notranslate"><span class="pre">'squared_error'</span></code>): The natural choice for regression
due to its superior computational properties. The initial model is
given by the mean of the target values.</p></li>
<li><p>Absolute error (<code class="docutils literal notranslate"><span class="pre">'absolute_error'</span></code>): A robust loss function for
regression. The initial model is given by the median of the
target values.</p></li>
<li><p>Huber (<code class="docutils literal notranslate"><span class="pre">'huber'</span></code>): Another robust loss function that combines
least squares and least absolute deviation; use <code class="docutils literal notranslate"><span class="pre">alpha</span></code> to
control the sensitivity with regards to outliers (see <a class="reference internal" href="#friedman2001" id="id11"><span>[Friedman2001]</span></a> for
more details).</p></li>
<li><p>Quantile (<code class="docutils literal notranslate"><span class="pre">'quantile'</span></code>): A loss function for quantile regression.
Use <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">alpha</span> <span class="pre">&lt;</span> <span class="pre">1</span></code> to specify the quantile. This loss function
can be used to create prediction intervals
(see <a class="reference internal" href="../auto_examples/ensemble/plot_gradient_boosting_quantile.html#sphx-glr-auto-examples-ensemble-plot-gradient-boosting-quantile-py"><span class="std std-ref">Prediction Intervals for Gradient Boosting Regression</span></a>).</p></li>
</ul>
</li>
<li><p>Classification</p>
<ul>
<li><p>Binary log-loss (<code class="docutils literal notranslate"><span class="pre">'log-loss'</span></code>): The binomial
negative log-likelihood loss function for binary classification. It provides
probability estimates.  The initial model is given by the
log odds-ratio.</p></li>
<li><p>Multi-class log-loss (<code class="docutils literal notranslate"><span class="pre">'log-loss'</span></code>): The multinomial
negative log-likelihood loss function for multi-class classification with
<code class="docutils literal notranslate"><span class="pre">n_classes</span></code> mutually exclusive classes. It provides
probability estimates.  The initial model is given by the
prior probability of each class. At each iteration <code class="docutils literal notranslate"><span class="pre">n_classes</span></code>
regression trees have to be constructed which makes GBRT rather
inefficient for data sets with a large number of classes.</p></li>
<li><p>Exponential loss (<code class="docutils literal notranslate"><span class="pre">'exponential'</span></code>): The same loss function
as <a class="reference internal" href="generated/sklearn.ensemble.AdaBoostClassifier.html#sklearn.ensemble.AdaBoostClassifier" title="sklearn.ensemble.AdaBoostClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">AdaBoostClassifier</span></code></a>. Less robust to mislabeled
examples than <code class="docutils literal notranslate"><span class="pre">'log-loss'</span></code>; can only be used for binary
classification.</p></li>
</ul>
</li>
</ul>
</div></blockquote>
</section>
<section id="shrinkage-via-learning-rate">
<span id="gradient-boosting-shrinkage"></span><h4><span class="section-number">1.11.1.2.7. </span>Shrinkage via learning rate<a class="headerlink" href="#shrinkage-via-learning-rate" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="#friedman2001" id="id12"><span>[Friedman2001]</span></a> proposed a simple regularization strategy that scales
the contribution of each weak learner by a constant factor <span class="math notranslate nohighlight">\(\nu\)</span>:</p>
<div class="math notranslate nohighlight">
\[F_m(x) = F_{m-1}(x) + \nu h_m(x)\]</div>
<p>The parameter <span class="math notranslate nohighlight">\(\nu\)</span> is also called the <strong>learning rate</strong> because
it scales the step length the gradient descent procedure; it can
be set via the <code class="docutils literal notranslate"><span class="pre">learning_rate</span></code> parameter.</p>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">learning_rate</span></code> strongly interacts with the parameter
<code class="docutils literal notranslate"><span class="pre">n_estimators</span></code>, the number of weak learners to fit. Smaller values
of <code class="docutils literal notranslate"><span class="pre">learning_rate</span></code> require larger numbers of weak learners to maintain
a constant training error. Empirical evidence suggests that small
values of <code class="docutils literal notranslate"><span class="pre">learning_rate</span></code> favor better test error. <a class="reference internal" href="#htf" id="id13"><span>[HTF]</span></a>
recommend to set the learning rate to a small constant
(e.g. <code class="docutils literal notranslate"><span class="pre">learning_rate</span> <span class="pre">&lt;=</span> <span class="pre">0.1</span></code>) and choose <code class="docutils literal notranslate"><span class="pre">n_estimators</span></code> by early
stopping. For a more detailed discussion of the interaction between
<code class="docutils literal notranslate"><span class="pre">learning_rate</span></code> and <code class="docutils literal notranslate"><span class="pre">n_estimators</span></code> see <a class="reference internal" href="#r2007" id="id14"><span>[R2007]</span></a>.</p>
</section>
<section id="subsampling">
<h4><span class="section-number">1.11.1.2.8. </span>Subsampling<a class="headerlink" href="#subsampling" title="Link to this heading">¶</a></h4>
<p><a class="reference internal" href="#friedman2002" id="id15"><span>[Friedman2002]</span></a> proposed stochastic gradient boosting, which combines gradient
boosting with bootstrap averaging (bagging). At each iteration
the base classifier is trained on a fraction <code class="docutils literal notranslate"><span class="pre">subsample</span></code> of
the available training data. The subsample is drawn without replacement.
A typical value of <code class="docutils literal notranslate"><span class="pre">subsample</span></code> is 0.5.</p>
<p>The figure below illustrates the effect of shrinkage and subsampling
on the goodness-of-fit of the model. We can clearly see that shrinkage
outperforms no-shrinkage. Subsampling with shrinkage can further increase
the accuracy of the model. Subsampling without shrinkage, on the other hand,
does poorly.</p>
<figure class="align-center">
<a class="reference external image-reference" href="../auto_examples/ensemble/plot_gradient_boosting_regularization.html"><img alt="../_images/sphx_glr_plot_gradient_boosting_regularization_001.png" src="../_images/sphx_glr_plot_gradient_boosting_regularization_001.png" style="width: 480.0px; height: 360.0px;" /></a>
</figure>
<p>Another strategy to reduce the variance is by subsampling the features
analogous to the random splits in <a class="reference internal" href="generated/sklearn.ensemble.RandomForestClassifier.html#sklearn.ensemble.RandomForestClassifier" title="sklearn.ensemble.RandomForestClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">RandomForestClassifier</span></code></a>.
The number of subsampled features can be controlled via the <code class="docutils literal notranslate"><span class="pre">max_features</span></code>
parameter.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Using a small <code class="docutils literal notranslate"><span class="pre">max_features</span></code> value can significantly decrease the runtime.</p>
</div>
<p>Stochastic gradient boosting allows to compute out-of-bag estimates of the
test deviance by computing the improvement in deviance on the examples that are
not included in the bootstrap sample (i.e. the out-of-bag examples).
The improvements are stored in the attribute <code class="docutils literal notranslate"><span class="pre">oob_improvement_</span></code>.
<code class="docutils literal notranslate"><span class="pre">oob_improvement_[i]</span></code> holds the improvement in terms of the loss on the OOB samples
if you add the i-th stage to the current predictions.
Out-of-bag estimates can be used for model selection, for example to determine
the optimal number of iterations. OOB estimates are usually very pessimistic thus
we recommend to use cross-validation instead and only use OOB if cross-validation
is too time consuming.</p>
<aside class="topic">
<p class="topic-title">Examples:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../auto_examples/ensemble/plot_gradient_boosting_regularization.html#sphx-glr-auto-examples-ensemble-plot-gradient-boosting-regularization-py"><span class="std std-ref">Gradient Boosting regularization</span></a></p></li>
<li><p><a class="reference internal" href="../auto_examples/ensemble/plot_gradient_boosting_oob.html#sphx-glr-auto-examples-ensemble-plot-gradient-boosting-oob-py"><span class="std std-ref">Gradient Boosting Out-of-Bag estimates</span></a></p></li>
<li><p><a class="reference internal" href="../auto_examples/ensemble/plot_ensemble_oob.html#sphx-glr-auto-examples-ensemble-plot-ensemble-oob-py"><span class="std std-ref">OOB Errors for Random Forests</span></a></p></li>
</ul>
</aside>
</section>
<section id="interpretation-with-feature-importance">
<h4><span class="section-number">1.11.1.2.9. </span>Interpretation with feature importance<a class="headerlink" href="#interpretation-with-feature-importance" title="Link to this heading">¶</a></h4>
<p>Individual decision trees can be interpreted easily by simply
visualizing the tree structure. Gradient boosting models, however,
comprise hundreds of regression trees thus they cannot be easily
interpreted by visual inspection of the individual trees. Fortunately,
a number of techniques have been proposed to summarize and interpret
gradient boosting models.</p>
<p>Often features do not contribute equally to predict the target
response; in many situations the majority of the features are in fact
irrelevant.
When interpreting a model, the first question usually is: what are
those important features and how do they contributing in predicting
the target response?</p>
<p>Individual decision trees intrinsically perform feature selection by selecting
appropriate split points. This information can be used to measure the
importance of each feature; the basic idea is: the more often a
feature is used in the split points of a tree the more important that
feature is. This notion of importance can be extended to decision tree
ensembles by simply averaging the impurity-based feature importance of each tree (see
<a class="reference internal" href="#random-forest-feature-importance"><span class="std std-ref">Feature importance evaluation</span></a> for more details).</p>
<p>The feature importance scores of a fit gradient boosting model can be
accessed via the <code class="docutils literal notranslate"><span class="pre">feature_importances_</span></code> property:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_hastie_10_2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">GradientBoostingClassifier</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_hastie_10_2</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">GradientBoostingClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">max_depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">feature_importances_</span>
<span class="go">array([0.10..., 0.10..., 0.11..., ...</span>
</pre></div>
</div>
<p>Note that this computation of feature importance is based on entropy, and it
is distinct from <a class="reference internal" href="generated/sklearn.inspection.permutation_importance.html#sklearn.inspection.permutation_importance" title="sklearn.inspection.permutation_importance"><code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.inspection.permutation_importance</span></code></a> which is
based on permutation of the features.</p>
<aside class="topic">
<p class="topic-title">Examples:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../auto_examples/ensemble/plot_gradient_boosting_regression.html#sphx-glr-auto-examples-ensemble-plot-gradient-boosting-regression-py"><span class="std std-ref">Gradient Boosting regression</span></a></p></li>
</ul>
</aside>
<aside class="topic">
<p class="topic-title">References</p>
<div role="list" class="citation-list">
<div class="citation" id="friedman2001" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Friedman2001<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id1">1</a>,<a role="doc-backlink" href="#id8">2</a>,<a role="doc-backlink" href="#id11">3</a>,<a role="doc-backlink" href="#id12">4</a>)</span>
<p>Friedman, J.H. (2001). <a class="reference external" href="https://doi.org/10.1214/aos/1013203451">Greedy function approximation: A gradient
boosting machine</a>.
Annals of Statistics, 29, 1189-1232.</p>
</div>
<div class="citation" id="friedman2002" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id15">Friedman2002</a><span class="fn-bracket">]</span></span>
<p>Friedman, J.H. (2002). <a class="reference external" href="https://statweb.stanford.edu/~jhf/ftp/stobst.pdf">Stochastic gradient boosting.</a>.
Computational Statistics &amp; Data Analysis, 38, 367-378.</p>
</div>
<div class="citation" id="r2007" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id14">R2007</a><span class="fn-bracket">]</span></span>
<p>G. Ridgeway (2006). <a class="reference external" href="https://cran.r-project.org/web/packages/gbm/vignettes/gbm.pdf">Generalized Boosted Models: A guide to the gbm
package</a></p>
</div>
</div>
</aside>
</section>
</section>
</section>
<section id="random-forests-and-other-randomized-tree-ensembles">
<span id="forest"></span><h2><a class="toc-backref" href="#id37" role="doc-backlink"><span class="section-number">1.11.2. </span>Random forests and other randomized tree ensembles</a><a class="headerlink" href="#random-forests-and-other-randomized-tree-ensembles" title="Link to this heading">¶</a></h2>
<p>The <a class="reference internal" href="classes.html#module-sklearn.ensemble" title="sklearn.ensemble"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.ensemble</span></code></a> module includes two averaging algorithms based
on randomized <a class="reference internal" href="tree.html#tree"><span class="std std-ref">decision trees</span></a>: the RandomForest algorithm
and the Extra-Trees method. Both algorithms are perturb-and-combine
techniques <a class="reference internal" href="#b1998" id="id16"><span>[B1998]</span></a> specifically designed for trees. This means a diverse
set of classifiers is created by introducing randomness in the classifier
construction.  The prediction of the ensemble is given as the averaged
prediction of the individual classifiers.</p>
<p>As other classifiers, forest classifiers have to be fitted with two
arrays: a sparse or dense array X of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_features)</span></code>
holding the training samples, and an array Y of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,)</span></code>
holding the target values (class labels) for the training samples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
</pre></div>
</div>
<p>Like <a class="reference internal" href="tree.html#tree"><span class="std std-ref">decision trees</span></a>, forests of trees also extend to
<a class="reference internal" href="tree.html#tree-multioutput"><span class="std std-ref">multi-output problems</span></a>  (if Y is an array
of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_outputs)</span></code>).</p>
<section id="random-forests">
<h3><span class="section-number">1.11.2.1. </span>Random Forests<a class="headerlink" href="#random-forests" title="Link to this heading">¶</a></h3>
<p>In random forests (see <a class="reference internal" href="generated/sklearn.ensemble.RandomForestClassifier.html#sklearn.ensemble.RandomForestClassifier" title="sklearn.ensemble.RandomForestClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">RandomForestClassifier</span></code></a> and
<a class="reference internal" href="generated/sklearn.ensemble.RandomForestRegressor.html#sklearn.ensemble.RandomForestRegressor" title="sklearn.ensemble.RandomForestRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">RandomForestRegressor</span></code></a> classes), each tree in the ensemble is built
from a sample drawn with replacement (i.e., a bootstrap sample) from the
training set.</p>
<p>Furthermore, when splitting each node during the construction of a tree, the
best split is found either from all input features or a random subset of size
<code class="docutils literal notranslate"><span class="pre">max_features</span></code>. (See the <a class="reference internal" href="#random-forest-parameters"><span class="std std-ref">parameter tuning guidelines</span></a> for more details).</p>
<p>The purpose of these two sources of randomness is to decrease the variance of
the forest estimator. Indeed, individual decision trees typically exhibit high
variance and tend to overfit. The injected randomness in forests yield decision
trees with somewhat decoupled prediction errors. By taking an average of those
predictions, some errors can cancel out. Random forests achieve a reduced
variance by combining diverse trees, sometimes at the cost of a slight increase
in bias. In practice the variance reduction is often significant hence yielding
an overall better model.</p>
<p>In contrast to the original publication <a class="reference internal" href="#b2001" id="id17"><span>[B2001]</span></a>, the scikit-learn
implementation combines classifiers by averaging their probabilistic
prediction, instead of letting each classifier vote for a single class.</p>
<p>A competitive alternative to random forests are
<a class="reference internal" href="#histogram-based-gradient-boosting"><span class="std std-ref">Histogram-Based Gradient Boosting</span></a> (HGBT) models:</p>
<ul class="simple">
<li><p>Building trees: Random forests typically rely on deep trees (that overfit
individually) which uses much computational resources, as they require
several splittings and evaluations of candidate splits. Boosting models
build shallow trees (that underfit individually) which are faster to fit
and predict.</p></li>
<li><p>Sequential boosting: In HGBT, the decision trees are built sequentially,
where each tree is trained to correct the errors made by the previous ones.
This allows them to iteratively improve the model’s performance using
relatively few trees. In contrast, random forests use a majority vote to
predict the outcome, which can require a larger number of trees to achieve
the same level of accuracy.</p></li>
<li><p>Efficient binning: HGBT uses an efficient binning algorithm that can handle
large datasets with a high number of features. The binning algorithm can
pre-process the data to speed up the subsequent tree construction (see
<a class="reference internal" href="#why-it-s-faster"><span class="std std-ref">Why it’s faster</span></a>). In contrast, the scikit-learn
implementation of random forests does not use binning and relies on exact
splitting, which can be computationally expensive.</p></li>
</ul>
<p>Overall, the computational cost of HGBT versus RF depends on the specific
characteristics of the dataset and the modeling task. It’s a good idea
to try both models and compare their performance and computational efficiency
on your specific problem to determine which model is the best fit.</p>
<aside class="topic">
<p class="topic-title">Examples:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../auto_examples/ensemble/plot_forest_hist_grad_boosting_comparison.html#sphx-glr-auto-examples-ensemble-plot-forest-hist-grad-boosting-comparison-py"><span class="std std-ref">Comparing Random Forests and Histogram Gradient Boosting models</span></a></p></li>
</ul>
</aside>
</section>
<section id="extremely-randomized-trees">
<h3><span class="section-number">1.11.2.2. </span>Extremely Randomized Trees<a class="headerlink" href="#extremely-randomized-trees" title="Link to this heading">¶</a></h3>
<p>In extremely randomized trees (see <a class="reference internal" href="generated/sklearn.ensemble.ExtraTreesClassifier.html#sklearn.ensemble.ExtraTreesClassifier" title="sklearn.ensemble.ExtraTreesClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExtraTreesClassifier</span></code></a>
and <a class="reference internal" href="generated/sklearn.ensemble.ExtraTreesRegressor.html#sklearn.ensemble.ExtraTreesRegressor" title="sklearn.ensemble.ExtraTreesRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExtraTreesRegressor</span></code></a> classes), randomness goes one step
further in the way splits are computed. As in random forests, a random
subset of candidate features is used, but instead of looking for the
most discriminative thresholds, thresholds are drawn at random for each
candidate feature and the best of these randomly-generated thresholds is
picked as the splitting rule. This usually allows to reduce the variance
of the model a bit more, at the expense of a slightly greater increase
in bias:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_blobs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">ExtraTreesClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="kn">import</span> <span class="n">DecisionTreeClassifier</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">n_features</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_samples_split</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="go">0.98...</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">min_samples_split</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="go">0.999...</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">ExtraTreesClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">min_samples_split</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.999</span>
<span class="go">True</span>
</pre></div>
</div>
<figure class="align-center">
<a class="reference external image-reference" href="../auto_examples/ensemble/plot_forest_iris.html"><img alt="../_images/sphx_glr_plot_forest_iris_001.png" src="../_images/sphx_glr_plot_forest_iris_001.png" style="width: 480.0px; height: 360.0px;" /></a>
</figure>
</section>
<section id="parameters">
<span id="random-forest-parameters"></span><h3><span class="section-number">1.11.2.3. </span>Parameters<a class="headerlink" href="#parameters" title="Link to this heading">¶</a></h3>
<p>The main parameters to adjust when using these methods is <code class="docutils literal notranslate"><span class="pre">n_estimators</span></code> and
<code class="docutils literal notranslate"><span class="pre">max_features</span></code>. The former is the number of trees in the forest. The larger
the better, but also the longer it will take to compute. In addition, note that
results will stop getting significantly better beyond a critical number of
trees. The latter is the size of the random subsets of features to consider
when splitting a node. The lower the greater the reduction of variance, but
also the greater the increase in bias. Empirical good default values are
<code class="docutils literal notranslate"><span class="pre">max_features=1.0</span></code> or equivalently <code class="docutils literal notranslate"><span class="pre">max_features=None</span></code> (always considering
all features instead of a random subset) for regression problems, and
<code class="docutils literal notranslate"><span class="pre">max_features=&quot;sqrt&quot;</span></code> (using a random subset of size <code class="docutils literal notranslate"><span class="pre">sqrt(n_features)</span></code>)
for classification tasks (where <code class="docutils literal notranslate"><span class="pre">n_features</span></code> is the number of features in
the data). The default value of <code class="docutils literal notranslate"><span class="pre">max_features=1.0</span></code> is equivalent to bagged
trees and more randomness can be achieved by setting smaller values (e.g. 0.3
is a typical default in the literature). Good results are often achieved when
setting <code class="docutils literal notranslate"><span class="pre">max_depth=None</span></code> in combination with <code class="docutils literal notranslate"><span class="pre">min_samples_split=2</span></code> (i.e.,
when fully developing the trees). Bear in mind though that these values are
usually not optimal, and might result in models that consume a lot of RAM.
The best parameter values should always be cross-validated. In addition, note
that in random forests, bootstrap samples are used by default
(<code class="docutils literal notranslate"><span class="pre">bootstrap=True</span></code>) while the default strategy for extra-trees is to use the
whole dataset (<code class="docutils literal notranslate"><span class="pre">bootstrap=False</span></code>). When using bootstrap sampling the
generalization error can be estimated on the left out or out-of-bag samples.
This can be enabled by setting <code class="docutils literal notranslate"><span class="pre">oob_score=True</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The size of the model with the default parameters is <span class="math notranslate nohighlight">\(O( M * N * log (N) )\)</span>,
where <span class="math notranslate nohighlight">\(M\)</span> is the number of trees and <span class="math notranslate nohighlight">\(N\)</span> is the number of samples.
In order to reduce the size of the model, you can change these parameters:
<code class="docutils literal notranslate"><span class="pre">min_samples_split</span></code>, <code class="docutils literal notranslate"><span class="pre">max_leaf_nodes</span></code>, <code class="docutils literal notranslate"><span class="pre">max_depth</span></code> and <code class="docutils literal notranslate"><span class="pre">min_samples_leaf</span></code>.</p>
</div>
</section>
<section id="parallelization">
<h3><span class="section-number">1.11.2.4. </span>Parallelization<a class="headerlink" href="#parallelization" title="Link to this heading">¶</a></h3>
<p>Finally, this module also features the parallel construction of the trees
and the parallel computation of the predictions through the <code class="docutils literal notranslate"><span class="pre">n_jobs</span></code>
parameter. If <code class="docutils literal notranslate"><span class="pre">n_jobs=k</span></code> then computations are partitioned into
<code class="docutils literal notranslate"><span class="pre">k</span></code> jobs, and run on <code class="docutils literal notranslate"><span class="pre">k</span></code> cores of the machine. If <code class="docutils literal notranslate"><span class="pre">n_jobs=-1</span></code>
then all cores available on the machine are used. Note that because of
inter-process communication overhead, the speedup might not be linear
(i.e., using <code class="docutils literal notranslate"><span class="pre">k</span></code> jobs will unfortunately not be <code class="docutils literal notranslate"><span class="pre">k</span></code> times as
fast). Significant speedup can still be achieved though when building
a large number of trees, or when building a single tree requires a fair
amount of time (e.g., on large datasets).</p>
<aside class="topic">
<p class="topic-title">Examples:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../auto_examples/ensemble/plot_forest_iris.html#sphx-glr-auto-examples-ensemble-plot-forest-iris-py"><span class="std std-ref">Plot the decision surfaces of ensembles of trees on the iris dataset</span></a></p></li>
<li><p><a class="reference internal" href="../auto_examples/ensemble/plot_forest_importances_faces.html#sphx-glr-auto-examples-ensemble-plot-forest-importances-faces-py"><span class="std std-ref">Pixel importances with a parallel forest of trees</span></a></p></li>
<li><p><a class="reference internal" href="../auto_examples/miscellaneous/plot_multioutput_face_completion.html#sphx-glr-auto-examples-miscellaneous-plot-multioutput-face-completion-py"><span class="std std-ref">Face completion with a multi-output estimators</span></a></p></li>
</ul>
</aside>
<aside class="topic">
<p class="topic-title">References</p>
<div role="list" class="citation-list">
<div class="citation" id="b2001" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id17">B2001</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="12">
<li><p>Breiman, “Random Forests”, Machine Learning, 45(1), 5-32, 2001.</p></li>
</ol>
</div>
<div class="citation" id="b1998" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id16">B1998</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="12">
<li><p>Breiman, “Arcing Classifiers”, Annals of Statistics 1998.</p></li>
</ol>
</div>
</div>
<ul class="simple">
<li><p>P. Geurts, D. Ernst., and L. Wehenkel, “Extremely randomized
trees”, Machine Learning, 63(1), 3-42, 2006.</p></li>
</ul>
</aside>
</section>
<section id="feature-importance-evaluation">
<span id="random-forest-feature-importance"></span><h3><span class="section-number">1.11.2.5. </span>Feature importance evaluation<a class="headerlink" href="#feature-importance-evaluation" title="Link to this heading">¶</a></h3>
<p>The relative rank (i.e. depth) of a feature used as a decision node in a
tree can be used to assess the relative importance of that feature with
respect to the predictability of the target variable. Features used at
the top of the tree contribute to the final prediction decision of a
larger fraction of the input samples. The <strong>expected fraction of the
samples</strong> they contribute to can thus be used as an estimate of the
<strong>relative importance of the features</strong>. In scikit-learn, the fraction of
samples a feature contributes to is combined with the decrease in impurity
from splitting them to create a normalized estimate of the predictive power
of that feature.</p>
<p>By <strong>averaging</strong> the estimates of predictive ability over several randomized
trees one can <strong>reduce the variance</strong> of such an estimate and use it
for feature selection. This is known as the mean decrease in impurity, or MDI.
Refer to <a class="reference internal" href="#l2014" id="id18"><span>[L2014]</span></a> for more information on MDI and feature importance
evaluation with Random Forests.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The impurity-based feature importances computed on tree-based models suffer
from two flaws that can lead to misleading conclusions. First they are
computed on statistics derived from the training dataset and therefore <strong>do
not necessarily inform us on which features are most important to make good
predictions on held-out dataset</strong>. Secondly, <strong>they favor high cardinality
features</strong>, that is features with many unique values.
<a class="reference internal" href="permutation_importance.html#permutation-importance"><span class="std std-ref">Permutation feature importance</span></a> is an alternative to impurity-based feature
importance that does not suffer from these flaws. These two methods of
obtaining feature importance are explored in:
<a class="reference internal" href="../auto_examples/inspection/plot_permutation_importance.html#sphx-glr-auto-examples-inspection-plot-permutation-importance-py"><span class="std std-ref">Permutation Importance vs Random Forest Feature Importance (MDI)</span></a>.</p>
</div>
<p>The following example shows a color-coded representation of the relative
importances of each individual pixel for a face recognition task using
a <a class="reference internal" href="generated/sklearn.ensemble.ExtraTreesClassifier.html#sklearn.ensemble.ExtraTreesClassifier" title="sklearn.ensemble.ExtraTreesClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExtraTreesClassifier</span></code></a> model.</p>
<figure class="align-center">
<a class="reference external image-reference" href="../auto_examples/ensemble/plot_forest_importances_faces.html"><img alt="../_images/sphx_glr_plot_forest_importances_faces_001.png" src="../_images/sphx_glr_plot_forest_importances_faces_001.png" style="width: 360.0px; height: 360.0px;" /></a>
</figure>
<p>In practice those estimates are stored as an attribute named
<code class="docutils literal notranslate"><span class="pre">feature_importances_</span></code> on the fitted model. This is an array with shape
<code class="docutils literal notranslate"><span class="pre">(n_features,)</span></code> whose values are positive and sum to 1.0. The higher
the value, the more important is the contribution of the matching feature
to the prediction function.</p>
<aside class="topic">
<p class="topic-title">Examples:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../auto_examples/ensemble/plot_forest_importances_faces.html#sphx-glr-auto-examples-ensemble-plot-forest-importances-faces-py"><span class="std std-ref">Pixel importances with a parallel forest of trees</span></a></p></li>
<li><p><a class="reference internal" href="../auto_examples/ensemble/plot_forest_importances.html#sphx-glr-auto-examples-ensemble-plot-forest-importances-py"><span class="std std-ref">Feature importances with a forest of trees</span></a></p></li>
</ul>
</aside>
<aside class="topic">
<p class="topic-title">References</p>
<div role="list" class="citation-list">
<div class="citation" id="l2014" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id18">L2014</a><span class="fn-bracket">]</span></span>
<p>G. Louppe, <a class="reference external" href="https://arxiv.org/abs/1407.7502">“Understanding Random Forests: From Theory to
Practice”</a>,
PhD Thesis, U. of Liege, 2014.</p>
</div>
</div>
</aside>
</section>
<section id="totally-random-trees-embedding">
<span id="random-trees-embedding"></span><h3><span class="section-number">1.11.2.6. </span>Totally Random Trees Embedding<a class="headerlink" href="#totally-random-trees-embedding" title="Link to this heading">¶</a></h3>
<p><a class="reference internal" href="generated/sklearn.ensemble.RandomTreesEmbedding.html#sklearn.ensemble.RandomTreesEmbedding" title="sklearn.ensemble.RandomTreesEmbedding"><code class="xref py py-class docutils literal notranslate"><span class="pre">RandomTreesEmbedding</span></code></a> implements an unsupervised transformation of the
data.  Using a forest of completely random trees, <a class="reference internal" href="generated/sklearn.ensemble.RandomTreesEmbedding.html#sklearn.ensemble.RandomTreesEmbedding" title="sklearn.ensemble.RandomTreesEmbedding"><code class="xref py py-class docutils literal notranslate"><span class="pre">RandomTreesEmbedding</span></code></a>
encodes the data by the indices of the leaves a data point ends up in.  This
index is then encoded in a one-of-K manner, leading to a high dimensional,
sparse binary coding.
This coding can be computed very efficiently and can then be used as a basis
for other learning tasks.
The size and sparsity of the code can be influenced by choosing the number of
trees and the maximum depth per tree. For each tree in the ensemble, the coding
contains one entry of one. The size of the coding is at most <code class="docutils literal notranslate"><span class="pre">n_estimators</span> <span class="pre">*</span> <span class="pre">2</span>
<span class="pre">**</span> <span class="pre">max_depth</span></code>, the maximum number of leaves in the forest.</p>
<p>As neighboring data points are more likely to lie within the same leaf of a
tree, the transformation performs an implicit, non-parametric density
estimation.</p>
<aside class="topic">
<p class="topic-title">Examples:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../auto_examples/ensemble/plot_random_forest_embedding.html#sphx-glr-auto-examples-ensemble-plot-random-forest-embedding-py"><span class="std std-ref">Hashing feature transformation using Totally Random Trees</span></a></p></li>
<li><p><a class="reference internal" href="../auto_examples/manifold/plot_lle_digits.html#sphx-glr-auto-examples-manifold-plot-lle-digits-py"><span class="std std-ref">Manifold learning on handwritten digits: Locally Linear Embedding, Isomap…</span></a> compares non-linear
dimensionality reduction techniques on handwritten digits.</p></li>
<li><p><a class="reference internal" href="../auto_examples/ensemble/plot_feature_transformation.html#sphx-glr-auto-examples-ensemble-plot-feature-transformation-py"><span class="std std-ref">Feature transformations with ensembles of trees</span></a> compares
supervised and unsupervised tree based feature transformations.</p></li>
</ul>
</aside>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="manifold.html#manifold"><span class="std std-ref">Manifold learning</span></a> techniques can also be useful to derive non-linear
representations of feature space, also these approaches focus also on
dimensionality reduction.</p>
</div>
</section>
</section>
<section id="bagging-meta-estimator">
<span id="bagging"></span><h2><a class="toc-backref" href="#id38" role="doc-backlink"><span class="section-number">1.11.3. </span>Bagging meta-estimator</a><a class="headerlink" href="#bagging-meta-estimator" title="Link to this heading">¶</a></h2>
<p>In ensemble algorithms, bagging methods form a class of algorithms which build
several instances of a black-box estimator on random subsets of the original
training set and then aggregate their individual predictions to form a final
prediction. These methods are used as a way to reduce the variance of a base
estimator (e.g., a decision tree), by introducing randomization into its
construction procedure and then making an ensemble out of it. In many cases,
bagging methods constitute a very simple way to improve with respect to a
single model, without making it necessary to adapt the underlying base
algorithm. As they provide a way to reduce overfitting, bagging methods work
best with strong and complex models (e.g., fully developed decision trees), in
contrast with boosting methods which usually work best with weak models (e.g.,
shallow decision trees).</p>
<p>Bagging methods come in many flavours but mostly differ from each other by the
way they draw random subsets of the training set:</p>
<blockquote>
<div><ul class="simple">
<li><p>When random subsets of the dataset are drawn as random subsets of the
samples, then this algorithm is known as Pasting <a class="reference internal" href="#b1999" id="id19"><span>[B1999]</span></a>.</p></li>
<li><p>When samples are drawn with replacement, then the method is known as
Bagging <a class="reference internal" href="#b1996" id="id20"><span>[B1996]</span></a>.</p></li>
<li><p>When random subsets of the dataset are drawn as random subsets of
the features, then the method is known as Random Subspaces <a class="reference internal" href="#h1998" id="id21"><span>[H1998]</span></a>.</p></li>
<li><p>Finally, when base estimators are built on subsets of both samples and
features, then the method is known as Random Patches <a class="reference internal" href="#lg2012" id="id22"><span>[LG2012]</span></a>.</p></li>
</ul>
</div></blockquote>
<p>In scikit-learn, bagging methods are offered as a unified
<a class="reference internal" href="generated/sklearn.ensemble.BaggingClassifier.html#sklearn.ensemble.BaggingClassifier" title="sklearn.ensemble.BaggingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaggingClassifier</span></code></a> meta-estimator  (resp. <a class="reference internal" href="generated/sklearn.ensemble.BaggingRegressor.html#sklearn.ensemble.BaggingRegressor" title="sklearn.ensemble.BaggingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">BaggingRegressor</span></code></a>),
taking as input a user-specified estimator along with parameters
specifying the strategy to draw random subsets. In particular, <code class="docutils literal notranslate"><span class="pre">max_samples</span></code>
and <code class="docutils literal notranslate"><span class="pre">max_features</span></code> control the size of the subsets (in terms of samples and
features), while <code class="docutils literal notranslate"><span class="pre">bootstrap</span></code> and <code class="docutils literal notranslate"><span class="pre">bootstrap_features</span></code> control whether
samples and features are drawn with or without replacement. When using a subset
of the available samples the generalization accuracy can be estimated with the
out-of-bag samples by setting <code class="docutils literal notranslate"><span class="pre">oob_score=True</span></code>. As an example, the
snippet below illustrates how to instantiate a bagging ensemble of
<a class="reference internal" href="generated/sklearn.neighbors.KNeighborsClassifier.html#sklearn.neighbors.KNeighborsClassifier" title="sklearn.neighbors.KNeighborsClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">KNeighborsClassifier</span></code></a> estimators, each built on random
subsets of 50% of the samples and 50% of the features.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">BaggingClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bagging</span> <span class="o">=</span> <span class="n">BaggingClassifier</span><span class="p">(</span><span class="n">KNeighborsClassifier</span><span class="p">(),</span>
<span class="gp">... </span>                            <span class="n">max_samples</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">max_features</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<aside class="topic">
<p class="topic-title">Examples:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../auto_examples/ensemble/plot_bias_variance.html#sphx-glr-auto-examples-ensemble-plot-bias-variance-py"><span class="std std-ref">Single estimator versus bagging: bias-variance decomposition</span></a></p></li>
</ul>
</aside>
<aside class="topic">
<p class="topic-title">References</p>
<div role="list" class="citation-list">
<div class="citation" id="b1999" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id19">B1999</a><span class="fn-bracket">]</span></span>
<p>L. Breiman, “Pasting small votes for classification in large
databases and on-line”, Machine Learning, 36(1), 85-103, 1999.</p>
</div>
<div class="citation" id="b1996" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id20">B1996</a><span class="fn-bracket">]</span></span>
<p>L. Breiman, “Bagging predictors”, Machine Learning, 24(2),
123-140, 1996.</p>
</div>
<div class="citation" id="h1998" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id21">H1998</a><span class="fn-bracket">]</span></span>
<p>T. Ho, “The random subspace method for constructing decision
forests”, Pattern Analysis and Machine Intelligence, 20(8), 832-844,
1998.</p>
</div>
<div class="citation" id="lg2012" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id22">LG2012</a><span class="fn-bracket">]</span></span>
<p>G. Louppe and P. Geurts, “Ensembles on Random Patches”,
Machine Learning and Knowledge Discovery in Databases, 346-361, 2012.</p>
</div>
</div>
</aside>
</section>
<section id="voting-classifier">
<span id="id23"></span><h2><a class="toc-backref" href="#id39" role="doc-backlink"><span class="section-number">1.11.4. </span>Voting Classifier</a><a class="headerlink" href="#voting-classifier" title="Link to this heading">¶</a></h2>
<p>The idea behind the <a class="reference internal" href="generated/sklearn.ensemble.VotingClassifier.html#sklearn.ensemble.VotingClassifier" title="sklearn.ensemble.VotingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">VotingClassifier</span></code></a> is to combine
conceptually different machine learning classifiers and use a majority vote
or the average predicted probabilities (soft vote) to predict the class labels.
Such a classifier can be useful for a set of equally well performing models
in order to balance out their individual weaknesses.</p>
<section id="majority-class-labels-majority-hard-voting">
<h3><span class="section-number">1.11.4.1. </span>Majority Class Labels (Majority/Hard Voting)<a class="headerlink" href="#majority-class-labels-majority-hard-voting" title="Link to this heading">¶</a></h3>
<p>In majority voting, the predicted class label for a particular sample is
the class label that represents the majority (mode) of the class labels
predicted by each individual classifier.</p>
<p>E.g., if the prediction for a given sample is</p>
<ul class="simple">
<li><p>classifier 1 -&gt; class 1</p></li>
<li><p>classifier 2 -&gt; class 1</p></li>
<li><p>classifier 3 -&gt; class 2</p></li>
</ul>
<p>the VotingClassifier (with <code class="docutils literal notranslate"><span class="pre">voting='hard'</span></code>) would classify the sample
as “class 1” based on the majority class label.</p>
<p>In the cases of a tie, the <a class="reference internal" href="generated/sklearn.ensemble.VotingClassifier.html#sklearn.ensemble.VotingClassifier" title="sklearn.ensemble.VotingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">VotingClassifier</span></code></a> will select the class
based on the ascending sort order. E.g., in the following scenario</p>
<ul class="simple">
<li><p>classifier 1 -&gt; class 2</p></li>
<li><p>classifier 2 -&gt; class 1</p></li>
</ul>
<p>the class label 1 will be assigned to the sample.</p>
</section>
<section id="id24">
<h3><span class="section-number">1.11.4.2. </span>Usage<a class="headerlink" href="#id24" title="Link to this heading">¶</a></h3>
<p>The following example shows how to fit the majority rule classifier:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">datasets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.naive_bayes</span> <span class="kn">import</span> <span class="n">GaussianNB</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">VotingClassifier</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">iris</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">load_iris</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">clf1</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf2</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf3</span> <span class="o">=</span> <span class="n">GaussianNB</span><span class="p">()</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">eclf</span> <span class="o">=</span> <span class="n">VotingClassifier</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">estimators</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;lr&#39;</span><span class="p">,</span> <span class="n">clf1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;rf&#39;</span><span class="p">,</span> <span class="n">clf2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;gnb&#39;</span><span class="p">,</span> <span class="n">clf3</span><span class="p">)],</span>
<span class="gp">... </span>    <span class="n">voting</span><span class="o">=</span><span class="s1">&#39;hard&#39;</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">clf</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">clf1</span><span class="p">,</span> <span class="n">clf2</span><span class="p">,</span> <span class="n">clf3</span><span class="p">,</span> <span class="n">eclf</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;Logistic Regression&#39;</span><span class="p">,</span> <span class="s1">&#39;Random Forest&#39;</span><span class="p">,</span> <span class="s1">&#39;naive Bayes&#39;</span><span class="p">,</span> <span class="s1">&#39;Ensemble&#39;</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;accuracy&#39;</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Accuracy: </span><span class="si">%0.2f</span><span class="s2"> (+/- </span><span class="si">%0.2f</span><span class="s2">) [</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">scores</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">scores</span><span class="o">.</span><span class="n">std</span><span class="p">(),</span> <span class="n">label</span><span class="p">))</span>
<span class="go">Accuracy: 0.95 (+/- 0.04) [Logistic Regression]</span>
<span class="go">Accuracy: 0.94 (+/- 0.04) [Random Forest]</span>
<span class="go">Accuracy: 0.91 (+/- 0.04) [naive Bayes]</span>
<span class="go">Accuracy: 0.95 (+/- 0.04) [Ensemble]</span>
</pre></div>
</div>
</section>
<section id="weighted-average-probabilities-soft-voting">
<h3><span class="section-number">1.11.4.3. </span>Weighted Average Probabilities (Soft Voting)<a class="headerlink" href="#weighted-average-probabilities-soft-voting" title="Link to this heading">¶</a></h3>
<p>In contrast to majority voting (hard voting), soft voting
returns the class label as argmax of the sum of predicted probabilities.</p>
<p>Specific weights can be assigned to each classifier via the <code class="docutils literal notranslate"><span class="pre">weights</span></code>
parameter. When weights are provided, the predicted class probabilities
for each classifier are collected, multiplied by the classifier weight,
and averaged. The final class label is then derived from the class label
with the highest average probability.</p>
<p>To illustrate this with a simple example, let’s assume we have 3
classifiers and a 3-class classification problems where we assign
equal weights to all classifiers: w1=1, w2=1, w3=1.</p>
<p>The weighted average probabilities for a sample would then be
calculated as follows:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>classifier</p></th>
<th class="head"><p>class 1</p></th>
<th class="head"><p>class 2</p></th>
<th class="head"><p>class 3</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>classifier 1</p></td>
<td><p>w1 * 0.2</p></td>
<td><p>w1 * 0.5</p></td>
<td><p>w1 * 0.3</p></td>
</tr>
<tr class="row-odd"><td><p>classifier 2</p></td>
<td><p>w2 * 0.6</p></td>
<td><p>w2 * 0.3</p></td>
<td><p>w2 * 0.1</p></td>
</tr>
<tr class="row-even"><td><p>classifier 3</p></td>
<td><p>w3 * 0.3</p></td>
<td><p>w3 * 0.4</p></td>
<td><p>w3 * 0.3</p></td>
</tr>
<tr class="row-odd"><td><p>weighted average</p></td>
<td><p>0.37</p></td>
<td><p>0.4</p></td>
<td><p>0.23</p></td>
</tr>
</tbody>
</table>
<p>Here, the predicted class label is 2, since it has the
highest average probability.</p>
<p>The following example illustrates how the decision regions may change
when a soft <a class="reference internal" href="generated/sklearn.ensemble.VotingClassifier.html#sklearn.ensemble.VotingClassifier" title="sklearn.ensemble.VotingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">VotingClassifier</span></code></a> is used based on a linear Support
Vector Machine, a Decision Tree, and a K-nearest neighbor classifier:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">datasets</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="kn">import</span> <span class="n">DecisionTreeClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">VotingClassifier</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Loading some example data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iris</span> <span class="o">=</span> <span class="n">datasets</span><span class="o">.</span><span class="n">load_iris</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Training classifiers</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf1</span> <span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf2</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf3</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;rbf&#39;</span><span class="p">,</span> <span class="n">probability</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eclf</span> <span class="o">=</span> <span class="n">VotingClassifier</span><span class="p">(</span><span class="n">estimators</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;dt&#39;</span><span class="p">,</span> <span class="n">clf1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;knn&#39;</span><span class="p">,</span> <span class="n">clf2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;svc&#39;</span><span class="p">,</span> <span class="n">clf3</span><span class="p">)],</span>
<span class="gp">... </span>                        <span class="n">voting</span><span class="o">=</span><span class="s1">&#39;soft&#39;</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">clf1</span> <span class="o">=</span> <span class="n">clf1</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf2</span> <span class="o">=</span> <span class="n">clf2</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf3</span> <span class="o">=</span> <span class="n">clf3</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eclf</span> <span class="o">=</span> <span class="n">eclf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center">
<a class="reference external image-reference" href="../auto_examples/ensemble/plot_voting_decision_regions.html"><img alt="../_images/sphx_glr_plot_voting_decision_regions_001.png" src="../_images/sphx_glr_plot_voting_decision_regions_001.png" style="width: 750.0px; height: 600.0px;" /></a>
</figure>
</section>
<section id="using-the-votingclassifier-with-gridsearchcv">
<h3><span class="section-number">1.11.4.4. </span>Using the <code class="docutils literal notranslate"><span class="pre">VotingClassifier</span></code> with <code class="docutils literal notranslate"><span class="pre">GridSearchCV</span></code><a class="headerlink" href="#using-the-votingclassifier-with-gridsearchcv" title="Link to this heading">¶</a></h3>
<p>The <a class="reference internal" href="generated/sklearn.ensemble.VotingClassifier.html#sklearn.ensemble.VotingClassifier" title="sklearn.ensemble.VotingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">VotingClassifier</span></code></a> can also be used together with
<a class="reference internal" href="generated/sklearn.model_selection.GridSearchCV.html#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code class="xref py py-class docutils literal notranslate"><span class="pre">GridSearchCV</span></code></a> in order to tune the
hyperparameters of the individual estimators:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf1</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf2</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf3</span> <span class="o">=</span> <span class="n">GaussianNB</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eclf</span> <span class="o">=</span> <span class="n">VotingClassifier</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">estimators</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;lr&#39;</span><span class="p">,</span> <span class="n">clf1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;rf&#39;</span><span class="p">,</span> <span class="n">clf2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;gnb&#39;</span><span class="p">,</span> <span class="n">clf3</span><span class="p">)],</span>
<span class="gp">... </span>    <span class="n">voting</span><span class="o">=</span><span class="s1">&#39;soft&#39;</span>
<span class="gp">... </span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;lr__C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">],</span> <span class="s1">&#39;rf__n_estimators&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">200</span><span class="p">]}</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">estimator</span><span class="o">=</span><span class="n">eclf</span><span class="p">,</span> <span class="n">param_grid</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">iris</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">iris</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id25">
<h3><span class="section-number">1.11.4.5. </span>Usage<a class="headerlink" href="#id25" title="Link to this heading">¶</a></h3>
<p>In order to predict the class labels based on the predicted
class-probabilities (scikit-learn estimators in the VotingClassifier
must support <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code> method):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eclf</span> <span class="o">=</span> <span class="n">VotingClassifier</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">estimators</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;lr&#39;</span><span class="p">,</span> <span class="n">clf1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;rf&#39;</span><span class="p">,</span> <span class="n">clf2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;gnb&#39;</span><span class="p">,</span> <span class="n">clf3</span><span class="p">)],</span>
<span class="gp">... </span>    <span class="n">voting</span><span class="o">=</span><span class="s1">&#39;soft&#39;</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p>Optionally, weights can be provided for the individual classifiers:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eclf</span> <span class="o">=</span> <span class="n">VotingClassifier</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">estimators</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;lr&#39;</span><span class="p">,</span> <span class="n">clf1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;rf&#39;</span><span class="p">,</span> <span class="n">clf2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;gnb&#39;</span><span class="p">,</span> <span class="n">clf3</span><span class="p">)],</span>
<span class="gp">... </span>    <span class="n">voting</span><span class="o">=</span><span class="s1">&#39;soft&#39;</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="voting-regressor">
<span id="id26"></span><h2><a class="toc-backref" href="#id40" role="doc-backlink"><span class="section-number">1.11.5. </span>Voting Regressor</a><a class="headerlink" href="#voting-regressor" title="Link to this heading">¶</a></h2>
<p>The idea behind the <a class="reference internal" href="generated/sklearn.ensemble.VotingRegressor.html#sklearn.ensemble.VotingRegressor" title="sklearn.ensemble.VotingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">VotingRegressor</span></code></a> is to combine conceptually
different machine learning regressors and return the average predicted values.
Such a regressor can be useful for a set of equally well performing models
in order to balance out their individual weaknesses.</p>
<section id="id27">
<h3><span class="section-number">1.11.5.1. </span>Usage<a class="headerlink" href="#id27" title="Link to this heading">¶</a></h3>
<p>The following example shows how to fit the VotingRegressor:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_diabetes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">GradientBoostingRegressor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestRegressor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">VotingRegressor</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Loading some example data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">load_diabetes</span><span class="p">(</span><span class="n">return_X_y</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Training classifiers</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg1</span> <span class="o">=</span> <span class="n">GradientBoostingRegressor</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg2</span> <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg3</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ereg</span> <span class="o">=</span> <span class="n">VotingRegressor</span><span class="p">(</span><span class="n">estimators</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;gb&#39;</span><span class="p">,</span> <span class="n">reg1</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;rf&#39;</span><span class="p">,</span> <span class="n">reg2</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;lr&#39;</span><span class="p">,</span> <span class="n">reg3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ereg</span> <span class="o">=</span> <span class="n">ereg</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center">
<a class="reference external image-reference" href="../auto_examples/ensemble/plot_voting_regressor.html"><img alt="../_images/sphx_glr_plot_voting_regressor_001.png" src="../_images/sphx_glr_plot_voting_regressor_001.png" style="width: 480.0px; height: 360.0px;" /></a>
</figure>
<aside class="topic">
<p class="topic-title">Examples:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../auto_examples/ensemble/plot_voting_regressor.html#sphx-glr-auto-examples-ensemble-plot-voting-regressor-py"><span class="std std-ref">Plot individual and voting regression predictions</span></a></p></li>
</ul>
</aside>
</section>
</section>
<section id="stacked-generalization">
<span id="stacking"></span><h2><a class="toc-backref" href="#id41" role="doc-backlink"><span class="section-number">1.11.6. </span>Stacked generalization</a><a class="headerlink" href="#stacked-generalization" title="Link to this heading">¶</a></h2>
<p>Stacked generalization is a method for combining estimators to reduce their
biases <a class="reference internal" href="#w1992" id="id28"><span>[W1992]</span></a> <a class="reference internal" href="#htf" id="id29"><span>[HTF]</span></a>. More precisely, the predictions of each individual
estimator are stacked together and used as input to a final estimator to
compute the prediction. This final estimator is trained through
cross-validation.</p>
<p>The <a class="reference internal" href="generated/sklearn.ensemble.StackingClassifier.html#sklearn.ensemble.StackingClassifier" title="sklearn.ensemble.StackingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">StackingClassifier</span></code></a> and <a class="reference internal" href="generated/sklearn.ensemble.StackingRegressor.html#sklearn.ensemble.StackingRegressor" title="sklearn.ensemble.StackingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">StackingRegressor</span></code></a> provide such
strategies which can be applied to classification and regression problems.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">estimators</span></code> parameter corresponds to the list of the estimators which
are stacked together in parallel on the input data. It should be given as a
list of names and estimators:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">RidgeCV</span><span class="p">,</span> <span class="n">LassoCV</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsRegressor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimators</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;ridge&#39;</span><span class="p">,</span> <span class="n">RidgeCV</span><span class="p">()),</span>
<span class="gp">... </span>              <span class="p">(</span><span class="s1">&#39;lasso&#39;</span><span class="p">,</span> <span class="n">LassoCV</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)),</span>
<span class="gp">... </span>              <span class="p">(</span><span class="s1">&#39;knr&#39;</span><span class="p">,</span> <span class="n">KNeighborsRegressor</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
<span class="gp">... </span>                                          <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">))]</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">final_estimator</span></code> will use the predictions of the <code class="docutils literal notranslate"><span class="pre">estimators</span></code> as input. It
needs to be a classifier or a regressor when using <a class="reference internal" href="generated/sklearn.ensemble.StackingClassifier.html#sklearn.ensemble.StackingClassifier" title="sklearn.ensemble.StackingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">StackingClassifier</span></code></a>
or <a class="reference internal" href="generated/sklearn.ensemble.StackingRegressor.html#sklearn.ensemble.StackingRegressor" title="sklearn.ensemble.StackingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">StackingRegressor</span></code></a>, respectively:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">GradientBoostingRegressor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">StackingRegressor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">final_estimator</span> <span class="o">=</span> <span class="n">GradientBoostingRegressor</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">n_estimators</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">subsample</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">min_samples_leaf</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">max_features</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span> <span class="o">=</span> <span class="n">StackingRegressor</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">estimators</span><span class="o">=</span><span class="n">estimators</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">final_estimator</span><span class="o">=</span><span class="n">final_estimator</span><span class="p">)</span>
</pre></div>
</div>
<p>To train the <code class="docutils literal notranslate"><span class="pre">estimators</span></code> and <code class="docutils literal notranslate"><span class="pre">final_estimator</span></code>, the <code class="docutils literal notranslate"><span class="pre">fit</span></code> method needs
to be called on the training data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_diabetes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">load_diabetes</span><span class="p">(</span><span class="n">return_X_y</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
<span class="gp">... </span>                                                    <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="go">StackingRegressor(...)</span>
</pre></div>
</div>
<p>During training, the <code class="docutils literal notranslate"><span class="pre">estimators</span></code> are fitted on the whole training data
<code class="docutils literal notranslate"><span class="pre">X_train</span></code>. They will be used when calling <code class="docutils literal notranslate"><span class="pre">predict</span></code> or <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code>. To
generalize and avoid over-fitting, the <code class="docutils literal notranslate"><span class="pre">final_estimator</span></code> is trained on
out-samples using <a class="reference internal" href="generated/sklearn.model_selection.cross_val_predict.html#sklearn.model_selection.cross_val_predict" title="sklearn.model_selection.cross_val_predict"><code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.model_selection.cross_val_predict</span></code></a> internally.</p>
<p>For <a class="reference internal" href="generated/sklearn.ensemble.StackingClassifier.html#sklearn.ensemble.StackingClassifier" title="sklearn.ensemble.StackingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">StackingClassifier</span></code></a>, note that the output of the <code class="docutils literal notranslate"><span class="pre">estimators</span></code> is
controlled by the parameter <code class="docutils literal notranslate"><span class="pre">stack_method</span></code> and it is called by each estimator.
This parameter is either a string, being estimator method names, or <code class="docutils literal notranslate"><span class="pre">'auto'</span></code>
which will automatically identify an available method depending on the
availability, tested in the order of preference: <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code>,
<code class="docutils literal notranslate"><span class="pre">decision_function</span></code> and <code class="docutils literal notranslate"><span class="pre">predict</span></code>.</p>
<p>A <a class="reference internal" href="generated/sklearn.ensemble.StackingRegressor.html#sklearn.ensemble.StackingRegressor" title="sklearn.ensemble.StackingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">StackingRegressor</span></code></a> and <a class="reference internal" href="generated/sklearn.ensemble.StackingClassifier.html#sklearn.ensemble.StackingClassifier" title="sklearn.ensemble.StackingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">StackingClassifier</span></code></a> can be used as
any other regressor or classifier, exposing a <code class="docutils literal notranslate"><span class="pre">predict</span></code>, <code class="docutils literal notranslate"><span class="pre">predict_proba</span></code>, and
<code class="docutils literal notranslate"><span class="pre">decision_function</span></code> methods, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">reg</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">r2_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;R2 score: </span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">r2_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)))</span>
<span class="go">R2 score: 0.53</span>
</pre></div>
</div>
<p>Note that it is also possible to get the output of the stacked
<code class="docutils literal notranslate"><span class="pre">estimators</span></code> using the <code class="docutils literal notranslate"><span class="pre">transform</span></code> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">[:</span><span class="mi">5</span><span class="p">])</span>
<span class="go">array([[142..., 138..., 146...],</span>
<span class="go">       [179..., 182..., 151...],</span>
<span class="go">       [139..., 132..., 158...],</span>
<span class="go">       [286..., 292..., 225...],</span>
<span class="go">       [126..., 124..., 164...]])</span>
</pre></div>
</div>
<p>In practice, a stacking predictor predicts as good as the best predictor of the
base layer and even sometimes outperforms it by combining the different
strengths of the these predictors. However, training a stacking predictor is
computationally expensive.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For <a class="reference internal" href="generated/sklearn.ensemble.StackingClassifier.html#sklearn.ensemble.StackingClassifier" title="sklearn.ensemble.StackingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">StackingClassifier</span></code></a>, when using <code class="docutils literal notranslate"><span class="pre">stack_method_='predict_proba'</span></code>,
the first column is dropped when the problem is a binary classification
problem. Indeed, both probability columns predicted by each estimator are
perfectly collinear.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Multiple stacking layers can be achieved by assigning <code class="docutils literal notranslate"><span class="pre">final_estimator</span></code> to
a <a class="reference internal" href="generated/sklearn.ensemble.StackingClassifier.html#sklearn.ensemble.StackingClassifier" title="sklearn.ensemble.StackingClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">StackingClassifier</span></code></a> or <a class="reference internal" href="generated/sklearn.ensemble.StackingRegressor.html#sklearn.ensemble.StackingRegressor" title="sklearn.ensemble.StackingRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">StackingRegressor</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">final_layer_rfr</span> <span class="o">=</span> <span class="n">RandomForestRegressor</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">n_estimators</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_features</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_leaf_nodes</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">final_layer_gbr</span> <span class="o">=</span> <span class="n">GradientBoostingRegressor</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">n_estimators</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_features</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_leaf_nodes</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">final_layer</span> <span class="o">=</span> <span class="n">StackingRegressor</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">estimators</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;rf&#39;</span><span class="p">,</span> <span class="n">final_layer_rfr</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s1">&#39;gbrt&#39;</span><span class="p">,</span> <span class="n">final_layer_gbr</span><span class="p">)],</span>
<span class="gp">... </span>    <span class="n">final_estimator</span><span class="o">=</span><span class="n">RidgeCV</span><span class="p">()</span>
<span class="gp">... </span>    <span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">multi_layer_regressor</span> <span class="o">=</span> <span class="n">StackingRegressor</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">estimators</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;ridge&#39;</span><span class="p">,</span> <span class="n">RidgeCV</span><span class="p">()),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s1">&#39;lasso&#39;</span><span class="p">,</span> <span class="n">LassoCV</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="s1">&#39;knr&#39;</span><span class="p">,</span> <span class="n">KNeighborsRegressor</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
<span class="gp">... </span>                                            <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">))],</span>
<span class="gp">... </span>    <span class="n">final_estimator</span><span class="o">=</span><span class="n">final_layer</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">multi_layer_regressor</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="go">StackingRegressor(...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;R2 score: </span><span class="si">{:.2f}</span><span class="s1">&#39;</span>
<span class="gp">... </span>      <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">multi_layer_regressor</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
<span class="go">R2 score: 0.53</span>
</pre></div>
</div>
</div>
<aside class="topic">
<p class="topic-title">References</p>
<div role="list" class="citation-list">
<div class="citation" id="w1992" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id28">W1992</a><span class="fn-bracket">]</span></span>
<p>Wolpert, David H. “Stacked generalization.” Neural networks 5.2
(1992): 241-259.</p>
</div>
</div>
</aside>
</section>
<section id="adaboost">
<span id="id30"></span><h2><a class="toc-backref" href="#id42" role="doc-backlink"><span class="section-number">1.11.7. </span>AdaBoost</a><a class="headerlink" href="#adaboost" title="Link to this heading">¶</a></h2>
<p>The module <a class="reference internal" href="classes.html#module-sklearn.ensemble" title="sklearn.ensemble"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.ensemble</span></code></a> includes the popular boosting algorithm
AdaBoost, introduced in 1995 by Freund and Schapire <a class="reference internal" href="#fs1995" id="id31"><span>[FS1995]</span></a>.</p>
<p>The core principle of AdaBoost is to fit a sequence of weak learners (i.e.,
models that are only slightly better than random guessing, such as small
decision trees) on repeatedly modified versions of the data. The predictions
from all of them are then combined through a weighted majority vote (or sum) to
produce the final prediction. The data modifications at each so-called boosting
iteration consists of applying weights <span class="math notranslate nohighlight">\(w_1\)</span>, <span class="math notranslate nohighlight">\(w_2\)</span>, …, <span class="math notranslate nohighlight">\(w_N\)</span>
to each of the training samples. Initially, those weights are all set to
<span class="math notranslate nohighlight">\(w_i = 1/N\)</span>, so that the first step simply trains a weak learner on the
original data. For each successive iteration, the sample weights are
individually modified and the learning algorithm is reapplied to the reweighted
data. At a given step, those training examples that were incorrectly predicted
by the boosted model induced at the previous step have their weights increased,
whereas the weights are decreased for those that were predicted correctly. As
iterations proceed, examples that are difficult to predict receive
ever-increasing influence. Each subsequent weak learner is thereby forced to
concentrate on the examples that are missed by the previous ones in the sequence
<a class="reference internal" href="#htf" id="id32"><span>[HTF]</span></a>.</p>
<figure class="align-center">
<a class="reference external image-reference" href="../auto_examples/ensemble/plot_adaboost_hastie_10_2.html"><img alt="../_images/sphx_glr_plot_adaboost_hastie_10_2_001.png" src="../_images/sphx_glr_plot_adaboost_hastie_10_2_001.png" style="width: 480.0px; height: 360.0px;" /></a>
</figure>
<p>AdaBoost can be used both for classification and regression problems:</p>
<blockquote>
<div><ul class="simple">
<li><p>For multi-class classification, <a class="reference internal" href="generated/sklearn.ensemble.AdaBoostClassifier.html#sklearn.ensemble.AdaBoostClassifier" title="sklearn.ensemble.AdaBoostClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">AdaBoostClassifier</span></code></a> implements
AdaBoost-SAMME and AdaBoost-SAMME.R <a class="reference internal" href="#zzrh2009" id="id33"><span>[ZZRH2009]</span></a>.</p></li>
<li><p>For regression, <a class="reference internal" href="generated/sklearn.ensemble.AdaBoostRegressor.html#sklearn.ensemble.AdaBoostRegressor" title="sklearn.ensemble.AdaBoostRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">AdaBoostRegressor</span></code></a> implements AdaBoost.R2 <a class="reference internal" href="#d1997" id="id34"><span>[D1997]</span></a>.</p></li>
</ul>
</div></blockquote>
<section id="id35">
<h3><span class="section-number">1.11.7.1. </span>Usage<a class="headerlink" href="#id35" title="Link to this heading">¶</a></h3>
<p>The following example shows how to fit an AdaBoost classifier with 100 weak
learners:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_iris</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">AdaBoostClassifier</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">load_iris</span><span class="p">(</span><span class="n">return_X_y</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">AdaBoostClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scores</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="go">0.9...</span>
</pre></div>
</div>
<p>The number of weak learners is controlled by the parameter <code class="docutils literal notranslate"><span class="pre">n_estimators</span></code>. The
<code class="docutils literal notranslate"><span class="pre">learning_rate</span></code> parameter controls the contribution of the weak learners in
the final combination. By default, weak learners are decision stumps. Different
weak learners can be specified through the <code class="docutils literal notranslate"><span class="pre">estimator</span></code> parameter.
The main parameters to tune to obtain good results are <code class="docutils literal notranslate"><span class="pre">n_estimators</span></code> and
the complexity of the base estimators (e.g., its depth <code class="docutils literal notranslate"><span class="pre">max_depth</span></code> or
minimum required number of samples to consider a split <code class="docutils literal notranslate"><span class="pre">min_samples_split</span></code>).</p>
<aside class="topic">
<p class="topic-title">Examples:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../auto_examples/ensemble/plot_adaboost_hastie_10_2.html#sphx-glr-auto-examples-ensemble-plot-adaboost-hastie-10-2-py"><span class="std std-ref">Discrete versus Real AdaBoost</span></a> compares the
classification error of a decision stump, decision tree, and a boosted
decision stump using AdaBoost-SAMME and AdaBoost-SAMME.R.</p></li>
<li><p><a class="reference internal" href="../auto_examples/ensemble/plot_adaboost_multiclass.html#sphx-glr-auto-examples-ensemble-plot-adaboost-multiclass-py"><span class="std std-ref">Multi-class AdaBoosted Decision Trees</span></a> shows the performance
of AdaBoost-SAMME and AdaBoost-SAMME.R on a multi-class problem.</p></li>
<li><p><a class="reference internal" href="../auto_examples/ensemble/plot_adaboost_twoclass.html#sphx-glr-auto-examples-ensemble-plot-adaboost-twoclass-py"><span class="std std-ref">Two-class AdaBoost</span></a> shows the decision boundary
and decision function values for a non-linearly separable two-class problem
using AdaBoost-SAMME.</p></li>
<li><p><a class="reference internal" href="../auto_examples/ensemble/plot_adaboost_regression.html#sphx-glr-auto-examples-ensemble-plot-adaboost-regression-py"><span class="std std-ref">Decision Tree Regression with AdaBoost</span></a> demonstrates regression
with the AdaBoost.R2 algorithm.</p></li>
</ul>
</aside>
<aside class="topic">
<p class="topic-title">References</p>
<div role="list" class="citation-list">
<div class="citation" id="fs1995" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id31">FS1995</a><span class="fn-bracket">]</span></span>
<p>Y. Freund, and R. Schapire, “A Decision-Theoretic Generalization of
On-Line Learning and an Application to Boosting”, 1997.</p>
</div>
<div class="citation" id="zzrh2009" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id33">ZZRH2009</a><span class="fn-bracket">]</span></span>
<p>J. Zhu, H. Zou, S. Rosset, T. Hastie. “Multi-class AdaBoost”,
2009.</p>
</div>
<div class="citation" id="d1997" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id34">D1997</a><span class="fn-bracket">]</span></span>
<ol class="upperalpha simple" start="8">
<li><p>Drucker. “Improving Regressors using Boosting Techniques”, 1997.</p></li>
</ol>
</div>
<div class="citation" id="htf" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>HTF<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id13">1</a>,<a role="doc-backlink" href="#id29">2</a>,<a role="doc-backlink" href="#id32">3</a>)</span>
<p>T. Hastie, R. Tibshirani and J. Friedman, “Elements of
Statistical Learning Ed. 2”, Springer, 2009.</p>
</div>
</div>
</aside>
</section>
</section>
</section>


      </div>
    <div class="container">
      <footer class="sk-content-footer">
            &copy; 2007 - 2023, scikit-learn developers (BSD License).
          <a href="../_sources/modules/ensemble.rst.txt" rel="nofollow">Show this page source</a>
      </footer>
    </div>
  </div>
</div>
<script src="../_static/js/vendor/bootstrap.min.js"></script>

<script>
    window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
    ga('create', 'UA-22606712-2', 'auto');
    ga('set', 'anonymizeIp', true);
    ga('send', 'pageview');
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



<script defer data-domain="scikit-learn.org" src="https://views.scientific-python.org/js/script.js">
</script>


<script src="../_static/clipboard.min.js"></script>
<script src="../_static/copybutton.js"></script>

<script>
$(document).ready(function() {
    /* Add a [>>>] button on the top-right corner of code samples to hide
     * the >>> and ... prompts and the output and thus make the code
     * copyable. */
    var div = $('.highlight-python .highlight,' +
                '.highlight-python3 .highlight,' +
                '.highlight-pycon .highlight,' +
		'.highlight-default .highlight')
    var pre = div.find('pre');

    // get the styles from the current theme
    pre.parent().parent().css('position', 'relative');

    // create and add the button to all the code blocks that contain >>>
    div.each(function(index) {
        var jthis = $(this);
        // tracebacks (.gt) contain bare text elements that need to be
        // wrapped in a span to work with .nextUntil() (see later)
        jthis.find('pre:has(.gt)').contents().filter(function() {
            return ((this.nodeType == 3) && (this.data.trim().length > 0));
        }).wrap('<span>');
    });

	/*** Add permalink buttons next to glossary terms ***/
	$('dl.glossary > dt[id]').append(function() {
		return ('<a class="headerlink" href="#' +
			    this.getAttribute('id') +
			    '" title="Permalink to this term">¶</a>');
	});
});

</script>
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
</body>
</html>