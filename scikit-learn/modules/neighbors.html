

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="1.6. Nearest Neighbors" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://scikit-learn/stable/modules/neighbors.html" />
<meta property="og:site_name" content="scikit-learn" />
<meta property="og:description" content="sklearn.neighbors provides functionality for unsupervised and supervised neighbors-based learning methods. Unsupervised nearest neighbors is the foundation of many other learning methods, notably m..." />
<meta property="og:image" content="https://scikit-learn/stable/modules/auto_examples/neighbors/images/sphx_glr_plot_classification_001.png" />
<meta property="og:image:alt" content="classification_1" />
<meta name="description" content="sklearn.neighbors provides functionality for unsupervised and supervised neighbors-based learning methods. Unsupervised nearest neighbors is the foundation of many other learning methods, notably m..." />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
  <title>1.6. Nearest Neighbors &mdash; scikit-learn 1.3.2 documentation</title>
  
  <link rel="canonical" href="http://scikit-learn.org/stable/modules/neighbors.html" />

  
  <link rel="shortcut icon" href="../_static/favicon.ico"/>
  

  <link rel="stylesheet" href="../_static/css/vendor/bootstrap.min.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../_static/plot_directive.css" type="text/css" />
  <link rel="stylesheet" href="../_static/sg_gallery.css" type="text/css" />
  <link rel="stylesheet" href="../_static/sg_gallery-binder.css" type="text/css" />
  <link rel="stylesheet" href="../_static/sg_gallery-dataframe.css" type="text/css" />
  <link rel="stylesheet" href="../_static/sg_gallery-rendered-html.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
<script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
<script src="../_static/js/vendor/jquery-3.6.3.slim.min.js"></script> 
</head>
<body>






<nav id="navbar" class="sk-docs-navbar navbar navbar-expand-md navbar-light bg-light py-0">
  <div class="container-fluid sk-docs-container px-0">
      <a class="navbar-brand py-0" href="../index.html">
        <img
          class="sk-brand-img"
          src="../_static/scikit-learn-logo-small.png"
          alt="logo"/>
      </a>
    <button
      id="sk-navbar-toggler"
      class="navbar-toggler"
      type="button"
      data-toggle="collapse"
      data-target="#navbarSupportedContent"
      aria-controls="navbarSupportedContent"
      aria-expanded="false"
      aria-label="Toggle navigation"
    >
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="sk-navbar-collapse collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav mr-auto">
        <li class="nav-item">
          <a class="sk-nav-link nav-link" href="../install.html">Install</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link" href="../user_guide.html">User Guide</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link" href="classes.html">API</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link" href="../auto_examples/index.html">Examples</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link" target="_blank" rel="noopener noreferrer" href="https://blog.scikit-learn.org/">Community</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../getting_started.html" >Getting Started</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../tutorial/index.html" >Tutorial</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../whats_new/v1.3.html" >What's new</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../glossary.html" >Glossary</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="https://scikit-learn.org/dev/developers/index.html" target="_blank" rel="noopener noreferrer">Development</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../faq.html" >FAQ</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../support.html" >Support</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../related_projects.html" >Related packages</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../roadmap.html" >Roadmap</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../governance.html" >Governance</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="../about.html" >About us</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="https://github.com/scikit-learn/scikit-learn" >GitHub</a>
        </li>
        <li class="nav-item">
          <a class="sk-nav-link nav-link nav-more-item-mobile-items" href="https://scikit-learn.org/dev/versions.html" >Other Versions and Download</a>
        </li>
        <li class="nav-item dropdown nav-more-item-dropdown">
          <a class="sk-nav-link nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">More</a>
          <div class="dropdown-menu" aria-labelledby="navbarDropdown">
              <a class="sk-nav-dropdown-item dropdown-item" href="../getting_started.html" >Getting Started</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../tutorial/index.html" >Tutorial</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../whats_new/v1.3.html" >What's new</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../glossary.html" >Glossary</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="https://scikit-learn.org/dev/developers/index.html" target="_blank" rel="noopener noreferrer">Development</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../faq.html" >FAQ</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../support.html" >Support</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../related_projects.html" >Related packages</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../roadmap.html" >Roadmap</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../governance.html" >Governance</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="../about.html" >About us</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="https://github.com/scikit-learn/scikit-learn" >GitHub</a>
              <a class="sk-nav-dropdown-item dropdown-item" href="https://scikit-learn.org/dev/versions.html" >Other Versions and Download</a>
          </div>
        </li>
      </ul>
      <div id="searchbox" role="search">
          <div class="searchformwrapper">
          <form class="search" action="../search.html" method="get">
            <input class="sk-search-text-input" type="text" name="q" aria-labelledby="searchlabel" />
            <input class="sk-search-text-btn" type="submit" value="Go" />
          </form>
          </div>
      </div>
    </div>
  </div>
</nav>
<div class="d-flex" id="sk-doc-wrapper">
    <input type="checkbox" name="sk-toggle-checkbox" id="sk-toggle-checkbox">
    <label id="sk-sidemenu-toggle" class="sk-btn-toggle-toc btn sk-btn-primary" for="sk-toggle-checkbox">Toggle Menu</label>
    <div id="sk-sidebar-wrapper" class="border-right">
      <div class="sk-sidebar-toc-wrapper">
        <div class="btn-group w-100 mb-2" role="group" aria-label="rellinks">
            <a href="sgd.html" role="button" class="btn sk-btn-rellink py-1" sk-rellink-tooltip="1.5. Stochastic Gradient Descent">Prev</a><a href="../supervised_learning.html" role="button" class="btn sk-btn-rellink py-1" sk-rellink-tooltip="1. Supervised learning">Up</a>
            <a href="gaussian_process.html" role="button" class="btn sk-btn-rellink py-1" sk-rellink-tooltip="1.7. Gaussian Processes">Next</a>
        </div>
        <div class="alert alert-danger p-1 mb-2" role="alert">
          <p class="text-center mb-0">
          <strong>scikit-learn 1.3.2</strong><br/>
          <a href="http://scikit-learn.org/dev/versions.html">Other versions</a>
          </p>
        </div>
        <div class="alert alert-warning p-1 mb-2" role="alert">
          <p class="text-center mb-0">
            Please <a class="font-weight-bold" href="../about.html#citing-scikit-learn"><string>cite us</string></a> if you use the software.
          </p>
        </div>
            <div class="sk-sidebar-toc">
              <ul>
<li><a class="reference internal" href="#">1.6. Nearest Neighbors</a><ul>
<li><a class="reference internal" href="#unsupervised-nearest-neighbors">1.6.1. Unsupervised Nearest Neighbors</a><ul>
<li><a class="reference internal" href="#finding-the-nearest-neighbors">1.6.1.1. Finding the Nearest Neighbors</a></li>
<li><a class="reference internal" href="#kdtree-and-balltree-classes">1.6.1.2. KDTree and BallTree Classes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#nearest-neighbors-classification">1.6.2. Nearest Neighbors Classification</a></li>
<li><a class="reference internal" href="#nearest-neighbors-regression">1.6.3. Nearest Neighbors Regression</a></li>
<li><a class="reference internal" href="#nearest-neighbor-algorithms">1.6.4. Nearest Neighbor Algorithms</a><ul>
<li><a class="reference internal" href="#brute-force">1.6.4.1. Brute Force</a></li>
<li><a class="reference internal" href="#k-d-tree">1.6.4.2. K-D Tree</a></li>
<li><a class="reference internal" href="#ball-tree">1.6.4.3. Ball Tree</a></li>
<li><a class="reference internal" href="#choice-of-nearest-neighbors-algorithm">1.6.4.4. Choice of Nearest Neighbors Algorithm</a></li>
<li><a class="reference internal" href="#effect-of-leaf-size">1.6.4.5. Effect of <code class="docutils literal notranslate"><span class="pre">leaf_size</span></code></a></li>
<li><a class="reference internal" href="#valid-metrics-for-nearest-neighbor-algorithms">1.6.4.6. Valid Metrics for Nearest Neighbor Algorithms</a></li>
</ul>
</li>
<li><a class="reference internal" href="#nearest-centroid-classifier">1.6.5. Nearest Centroid Classifier</a><ul>
<li><a class="reference internal" href="#nearest-shrunken-centroid">1.6.5.1. Nearest Shrunken Centroid</a></li>
</ul>
</li>
<li><a class="reference internal" href="#nearest-neighbors-transformer">1.6.6. Nearest Neighbors Transformer</a></li>
<li><a class="reference internal" href="#neighborhood-components-analysis">1.6.7. Neighborhood Components Analysis</a><ul>
<li><a class="reference internal" href="#id4">1.6.7.1. Classification</a></li>
<li><a class="reference internal" href="#dimensionality-reduction">1.6.7.2. Dimensionality reduction</a></li>
<li><a class="reference internal" href="#mathematical-formulation">1.6.7.3. Mathematical formulation</a><ul>
<li><a class="reference internal" href="#mahalanobis-distance">1.6.7.3.1. Mahalanobis distance</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation">1.6.7.4. Implementation</a></li>
<li><a class="reference internal" href="#complexity">1.6.7.5. Complexity</a><ul>
<li><a class="reference internal" href="#training">1.6.7.5.1. Training</a></li>
<li><a class="reference internal" href="#transform">1.6.7.5.2. Transform</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            </div>
      </div>
    </div>
    <div id="sk-page-content-wrapper">
      <div class="sk-page-content container-fluid body px-md-3" role="main">
        
  <section id="nearest-neighbors">
<span id="neighbors"></span><h1><span class="section-number">1.6. </span>Nearest Neighbors<a class="headerlink" href="#nearest-neighbors" title="Link to this heading">¶</a></h1>
<p><a class="reference internal" href="classes.html#module-sklearn.neighbors" title="sklearn.neighbors"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.neighbors</span></code></a> provides functionality for unsupervised and
supervised neighbors-based learning methods.  Unsupervised nearest neighbors
is the foundation of many other learning methods,
notably manifold learning and spectral clustering.  Supervised neighbors-based
learning comes in two flavors: <a class="reference internal" href="#classification">classification</a> for data with
discrete labels, and <a class="reference internal" href="#regression">regression</a> for data with continuous labels.</p>
<p>The principle behind nearest neighbor methods is to find a predefined number
of training samples closest in distance to the new point, and
predict the label from these.  The number of samples can be a user-defined
constant (k-nearest neighbor learning), or vary based
on the local density of points (radius-based neighbor learning).
The distance can, in general, be any metric measure: standard Euclidean
distance is the most common choice.
Neighbors-based methods are known as <em>non-generalizing</em> machine
learning methods, since they simply “remember” all of its training data
(possibly transformed into a fast indexing structure such as a
<a class="reference internal" href="#ball-tree"><span class="std std-ref">Ball Tree</span></a> or <a class="reference internal" href="#kd-tree"><span class="std std-ref">KD Tree</span></a>).</p>
<p>Despite its simplicity, nearest neighbors has been successful in a
large number of classification and regression problems, including
handwritten digits and satellite image scenes. Being a non-parametric method,
it is often successful in classification situations where the decision
boundary is very irregular.</p>
<p>The classes in <a class="reference internal" href="classes.html#module-sklearn.neighbors" title="sklearn.neighbors"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.neighbors</span></code></a> can handle either NumPy arrays or
<code class="docutils literal notranslate"><span class="pre">scipy.sparse</span></code> matrices as input.  For dense matrices, a large number of
possible distance metrics are supported.  For sparse matrices, arbitrary
Minkowski metrics are supported for searches.</p>
<p>There are many learning routines which rely on nearest neighbors at their
core.  One example is <a class="reference internal" href="density.html#kernel-density"><span class="std std-ref">kernel density estimation</span></a>,
discussed in the <a class="reference internal" href="density.html#density-estimation"><span class="std std-ref">density estimation</span></a> section.</p>
<section id="unsupervised-nearest-neighbors">
<span id="unsupervised-neighbors"></span><h2><span class="section-number">1.6.1. </span>Unsupervised Nearest Neighbors<a class="headerlink" href="#unsupervised-nearest-neighbors" title="Link to this heading">¶</a></h2>
<p><a class="reference internal" href="generated/sklearn.neighbors.NearestNeighbors.html#sklearn.neighbors.NearestNeighbors" title="sklearn.neighbors.NearestNeighbors"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighbors</span></code></a> implements unsupervised nearest neighbors learning.
It acts as a uniform interface to three different nearest neighbors
algorithms: <a class="reference internal" href="generated/sklearn.neighbors.BallTree.html#sklearn.neighbors.BallTree" title="sklearn.neighbors.BallTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">BallTree</span></code></a>, <a class="reference internal" href="generated/sklearn.neighbors.KDTree.html#sklearn.neighbors.KDTree" title="sklearn.neighbors.KDTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">KDTree</span></code></a>, and a
brute-force algorithm based on routines in <a class="reference internal" href="classes.html#module-sklearn.metrics.pairwise" title="sklearn.metrics.pairwise"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.metrics.pairwise</span></code></a>.
The choice of neighbors search algorithm is controlled through the keyword
<code class="docutils literal notranslate"><span class="pre">'algorithm'</span></code>, which must be one of
<code class="docutils literal notranslate"><span class="pre">['auto',</span> <span class="pre">'ball_tree',</span> <span class="pre">'kd_tree',</span> <span class="pre">'brute']</span></code>.  When the default value
<code class="docutils literal notranslate"><span class="pre">'auto'</span></code> is passed, the algorithm attempts to determine the best approach
from the training data.  For a discussion of the strengths and weaknesses
of each option, see <a class="reference internal" href="#nearest-neighbor-algorithms">Nearest Neighbor Algorithms</a>.</p>
<blockquote>
<div><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Regarding the Nearest Neighbors algorithms, if two
neighbors <span class="math notranslate nohighlight">\(k+1\)</span> and <span class="math notranslate nohighlight">\(k\)</span> have identical distances
but different labels, the result will depend on the ordering of the
training data.</p>
</div>
</div></blockquote>
<section id="finding-the-nearest-neighbors">
<h3><span class="section-number">1.6.1.1. </span>Finding the Nearest Neighbors<a class="headerlink" href="#finding-the-nearest-neighbors" title="Link to this heading">¶</a></h3>
<p>For the simple task of finding the nearest neighbors between two sets of
data, the unsupervised algorithms within <a class="reference internal" href="classes.html#module-sklearn.neighbors" title="sklearn.neighbors"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.neighbors</span></code></a> can be
used:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">NearestNeighbors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nbrs</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;ball_tree&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">distances</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [1, 0],</span>
<span class="go">       [2, 1],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [4, 3],</span>
<span class="go">       [5, 4]]...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">distances</span>
<span class="go">array([[0.        , 1.        ],</span>
<span class="go">       [0.        , 1.        ],</span>
<span class="go">       [0.        , 1.41421356],</span>
<span class="go">       [0.        , 1.        ],</span>
<span class="go">       [0.        , 1.        ],</span>
<span class="go">       [0.        , 1.41421356]])</span>
</pre></div>
</div>
<p>Because the query set matches the training set, the nearest neighbor of each
point is the point itself, at a distance of zero.</p>
<p>It is also possible to efficiently produce a sparse graph showing the
connections between neighboring points:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nbrs</span><span class="o">.</span><span class="n">kneighbors_graph</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
<span class="go">array([[1., 1., 0., 0., 0., 0.],</span>
<span class="go">       [1., 1., 0., 0., 0., 0.],</span>
<span class="go">       [0., 1., 1., 0., 0., 0.],</span>
<span class="go">       [0., 0., 0., 1., 1., 0.],</span>
<span class="go">       [0., 0., 0., 1., 1., 0.],</span>
<span class="go">       [0., 0., 0., 0., 1., 1.]])</span>
</pre></div>
</div>
<p>The dataset is structured such that points nearby in index order are nearby
in parameter space, leading to an approximately block-diagonal matrix of
K-nearest neighbors.  Such a sparse graph is useful in a variety of
circumstances which make use of spatial relationships between points for
unsupervised learning: in particular, see <a class="reference internal" href="generated/sklearn.manifold.Isomap.html#sklearn.manifold.Isomap" title="sklearn.manifold.Isomap"><code class="xref py py-class docutils literal notranslate"><span class="pre">Isomap</span></code></a>,
<a class="reference internal" href="generated/sklearn.manifold.LocallyLinearEmbedding.html#sklearn.manifold.LocallyLinearEmbedding" title="sklearn.manifold.LocallyLinearEmbedding"><code class="xref py py-class docutils literal notranslate"><span class="pre">LocallyLinearEmbedding</span></code></a>, and
<a class="reference internal" href="generated/sklearn.cluster.SpectralClustering.html#sklearn.cluster.SpectralClustering" title="sklearn.cluster.SpectralClustering"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpectralClustering</span></code></a>.</p>
</section>
<section id="kdtree-and-balltree-classes">
<h3><span class="section-number">1.6.1.2. </span>KDTree and BallTree Classes<a class="headerlink" href="#kdtree-and-balltree-classes" title="Link to this heading">¶</a></h3>
<p>Alternatively, one can use the <a class="reference internal" href="generated/sklearn.neighbors.KDTree.html#sklearn.neighbors.KDTree" title="sklearn.neighbors.KDTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">KDTree</span></code></a> or <a class="reference internal" href="generated/sklearn.neighbors.BallTree.html#sklearn.neighbors.BallTree" title="sklearn.neighbors.BallTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">BallTree</span></code></a> classes
directly to find nearest neighbors.  This is the functionality wrapped by
the <a class="reference internal" href="generated/sklearn.neighbors.NearestNeighbors.html#sklearn.neighbors.NearestNeighbors" title="sklearn.neighbors.NearestNeighbors"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestNeighbors</span></code></a> class used above.  The Ball Tree and KD Tree
have the same interface; we’ll show an example of using the KD Tree here:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KDTree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kdt</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">leaf_size</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kdt</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">return_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [1, 0],</span>
<span class="go">       [2, 1],</span>
<span class="go">       [3, 4],</span>
<span class="go">       [4, 3],</span>
<span class="go">       [5, 4]]...)</span>
</pre></div>
</div>
<p>Refer to the <a class="reference internal" href="generated/sklearn.neighbors.KDTree.html#sklearn.neighbors.KDTree" title="sklearn.neighbors.KDTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">KDTree</span></code></a> and <a class="reference internal" href="generated/sklearn.neighbors.BallTree.html#sklearn.neighbors.BallTree" title="sklearn.neighbors.BallTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">BallTree</span></code></a> class documentation
for more information on the options available for nearest neighbors searches,
including specification of query strategies, distance metrics, etc. For a list
of valid metrics use <code class="xref py py-meth docutils literal notranslate"><span class="pre">KDTree.valid_metrics</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">BallTree.valid_metrics</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KDTree</span><span class="p">,</span> <span class="n">BallTree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">KDTree</span><span class="o">.</span><span class="n">valid_metrics</span>
<span class="go">[&#39;euclidean&#39;, &#39;l2&#39;, &#39;minkowski&#39;, &#39;p&#39;, &#39;manhattan&#39;, &#39;cityblock&#39;, &#39;l1&#39;, &#39;chebyshev&#39;, &#39;infinity&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BallTree</span><span class="o">.</span><span class="n">valid_metrics</span>
<span class="go">[&#39;euclidean&#39;, &#39;l2&#39;, &#39;minkowski&#39;, &#39;p&#39;, &#39;manhattan&#39;, &#39;cityblock&#39;, &#39;l1&#39;, &#39;chebyshev&#39;, &#39;infinity&#39;, &#39;seuclidean&#39;, &#39;mahalanobis&#39;, &#39;hamming&#39;, &#39;canberra&#39;, &#39;braycurtis&#39;, &#39;jaccard&#39;, &#39;dice&#39;, &#39;rogerstanimoto&#39;, &#39;russellrao&#39;, &#39;sokalmichener&#39;, &#39;sokalsneath&#39;, &#39;haversine&#39;, &#39;pyfunc&#39;]</span>
</pre></div>
</div>
</section>
</section>
<section id="nearest-neighbors-classification">
<span id="classification"></span><h2><span class="section-number">1.6.2. </span>Nearest Neighbors Classification<a class="headerlink" href="#nearest-neighbors-classification" title="Link to this heading">¶</a></h2>
<p>Neighbors-based classification is a type of <em>instance-based learning</em> or
<em>non-generalizing learning</em>: it does not attempt to construct a general
internal model, but simply stores instances of the training data.
Classification is computed from a simple majority vote of the nearest
neighbors of each point: a query point is assigned the data class which
has the most representatives within the nearest neighbors of the point.</p>
<p>scikit-learn implements two different nearest neighbors classifiers:
<a class="reference internal" href="generated/sklearn.neighbors.KNeighborsClassifier.html#sklearn.neighbors.KNeighborsClassifier" title="sklearn.neighbors.KNeighborsClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">KNeighborsClassifier</span></code></a> implements learning based on the <span class="math notranslate nohighlight">\(k\)</span>
nearest neighbors of each query point, where <span class="math notranslate nohighlight">\(k\)</span> is an integer value
specified by the user.  <a class="reference internal" href="generated/sklearn.neighbors.RadiusNeighborsClassifier.html#sklearn.neighbors.RadiusNeighborsClassifier" title="sklearn.neighbors.RadiusNeighborsClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">RadiusNeighborsClassifier</span></code></a> implements learning
based on the number of neighbors within a fixed radius <span class="math notranslate nohighlight">\(r\)</span> of each
training point, where <span class="math notranslate nohighlight">\(r\)</span> is a floating-point value specified by
the user.</p>
<p>The <span class="math notranslate nohighlight">\(k\)</span>-neighbors classification in <a class="reference internal" href="generated/sklearn.neighbors.KNeighborsClassifier.html#sklearn.neighbors.KNeighborsClassifier" title="sklearn.neighbors.KNeighborsClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">KNeighborsClassifier</span></code></a>
is the most commonly used technique. The optimal choice of the value <span class="math notranslate nohighlight">\(k\)</span>
is highly data-dependent: in general a larger <span class="math notranslate nohighlight">\(k\)</span> suppresses the effects
of noise, but makes the classification boundaries less distinct.</p>
<p>In cases where the data is not uniformly sampled, radius-based neighbors
classification in <a class="reference internal" href="generated/sklearn.neighbors.RadiusNeighborsClassifier.html#sklearn.neighbors.RadiusNeighborsClassifier" title="sklearn.neighbors.RadiusNeighborsClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">RadiusNeighborsClassifier</span></code></a> can be a better choice.
The user specifies a fixed radius <span class="math notranslate nohighlight">\(r\)</span>, such that points in sparser
neighborhoods use fewer nearest neighbors for the classification.  For
high-dimensional parameter spaces, this method becomes less effective due
to the so-called “curse of dimensionality”.</p>
<p>The basic nearest neighbors classification uses uniform weights: that is, the
value assigned to a query point is computed from a simple majority vote of
the nearest neighbors.  Under some circumstances, it is better to weight the
neighbors such that nearer neighbors contribute more to the fit.  This can
be accomplished through the <code class="docutils literal notranslate"><span class="pre">weights</span></code> keyword.  The default value,
<code class="docutils literal notranslate"><span class="pre">weights</span> <span class="pre">=</span> <span class="pre">'uniform'</span></code>, assigns uniform weights to each neighbor.
<code class="docutils literal notranslate"><span class="pre">weights</span> <span class="pre">=</span> <span class="pre">'distance'</span></code> assigns weights proportional to the inverse of the
distance from the query point.  Alternatively, a user-defined function of the
distance can be supplied to compute the weights.</p>
<p class="centered">
<strong><a class="reference external" href="../auto_examples/neighbors/plot_classification.html"><img alt="classification_1" src="../_images/sphx_glr_plot_classification_001.png" style="width: 900.0px; height: 375.0px;" /></a></strong></p><aside class="topic">
<p class="topic-title">Examples:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../auto_examples/neighbors/plot_classification.html#sphx-glr-auto-examples-neighbors-plot-classification-py"><span class="std std-ref">Nearest Neighbors Classification</span></a>: an example of
classification using nearest neighbors.</p></li>
</ul>
</aside>
</section>
<section id="nearest-neighbors-regression">
<span id="regression"></span><h2><span class="section-number">1.6.3. </span>Nearest Neighbors Regression<a class="headerlink" href="#nearest-neighbors-regression" title="Link to this heading">¶</a></h2>
<p>Neighbors-based regression can be used in cases where the data labels are
continuous rather than discrete variables.  The label assigned to a query
point is computed based on the mean of the labels of its nearest neighbors.</p>
<p>scikit-learn implements two different neighbors regressors:
<a class="reference internal" href="generated/sklearn.neighbors.KNeighborsRegressor.html#sklearn.neighbors.KNeighborsRegressor" title="sklearn.neighbors.KNeighborsRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">KNeighborsRegressor</span></code></a> implements learning based on the <span class="math notranslate nohighlight">\(k\)</span>
nearest neighbors of each query point, where <span class="math notranslate nohighlight">\(k\)</span> is an integer
value specified by the user.  <a class="reference internal" href="generated/sklearn.neighbors.RadiusNeighborsRegressor.html#sklearn.neighbors.RadiusNeighborsRegressor" title="sklearn.neighbors.RadiusNeighborsRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">RadiusNeighborsRegressor</span></code></a> implements
learning based on the neighbors within a fixed radius <span class="math notranslate nohighlight">\(r\)</span> of the
query point, where <span class="math notranslate nohighlight">\(r\)</span> is a floating-point value specified by the
user.</p>
<p>The basic nearest neighbors regression uses uniform weights: that is,
each point in the local neighborhood contributes uniformly to the
classification of a query point.  Under some circumstances, it can be
advantageous to weight points such that nearby points contribute more
to the regression than faraway points.  This can be accomplished through
the <code class="docutils literal notranslate"><span class="pre">weights</span></code> keyword.  The default value, <code class="docutils literal notranslate"><span class="pre">weights</span> <span class="pre">=</span> <span class="pre">'uniform'</span></code>,
assigns equal weights to all points.  <code class="docutils literal notranslate"><span class="pre">weights</span> <span class="pre">=</span> <span class="pre">'distance'</span></code> assigns
weights proportional to the inverse of the distance from the query point.
Alternatively, a user-defined function of the distance can be supplied,
which will be used to compute the weights.</p>
<figure class="align-center">
<a class="reference external image-reference" href="../auto_examples/neighbors/plot_regression.html"><img alt="../_images/sphx_glr_plot_regression_001.png" src="../_images/sphx_glr_plot_regression_001.png" style="width: 480.0px; height: 360.0px;" /></a>
</figure>
<p>The use of multi-output nearest neighbors for regression is demonstrated in
<a class="reference internal" href="../auto_examples/miscellaneous/plot_multioutput_face_completion.html#sphx-glr-auto-examples-miscellaneous-plot-multioutput-face-completion-py"><span class="std std-ref">Face completion with a multi-output estimators</span></a>. In this example, the inputs
X are the pixels of the upper half of faces and the outputs Y are the pixels of
the lower half of those faces.</p>
<figure class="align-center">
<a class="reference external image-reference" href="../auto_examples/miscellaneous/plot_multioutput_face_completion.html"><img alt="../_images/sphx_glr_plot_multioutput_face_completion_001.png" src="../_images/sphx_glr_plot_multioutput_face_completion_001.png" style="width: 750.0px; height: 847.5px;" /></a>
</figure>
<aside class="topic">
<p class="topic-title">Examples:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../auto_examples/neighbors/plot_regression.html#sphx-glr-auto-examples-neighbors-plot-regression-py"><span class="std std-ref">Nearest Neighbors regression</span></a>: an example of regression
using nearest neighbors.</p></li>
<li><p><a class="reference internal" href="../auto_examples/miscellaneous/plot_multioutput_face_completion.html#sphx-glr-auto-examples-miscellaneous-plot-multioutput-face-completion-py"><span class="std std-ref">Face completion with a multi-output estimators</span></a>: an example of
multi-output regression using nearest neighbors.</p></li>
</ul>
</aside>
</section>
<section id="nearest-neighbor-algorithms">
<h2><span class="section-number">1.6.4. </span>Nearest Neighbor Algorithms<a class="headerlink" href="#nearest-neighbor-algorithms" title="Link to this heading">¶</a></h2>
<section id="brute-force">
<span id="id1"></span><h3><span class="section-number">1.6.4.1. </span>Brute Force<a class="headerlink" href="#brute-force" title="Link to this heading">¶</a></h3>
<p>Fast computation of nearest neighbors is an active area of research in
machine learning. The most naive neighbor search implementation involves
the brute-force computation of distances between all pairs of points in the
dataset: for <span class="math notranslate nohighlight">\(N\)</span> samples in <span class="math notranslate nohighlight">\(D\)</span> dimensions, this approach scales
as <span class="math notranslate nohighlight">\(O[D N^2]\)</span>.  Efficient brute-force neighbors searches can be very
competitive for small data samples.
However, as the number of samples <span class="math notranslate nohighlight">\(N\)</span> grows, the brute-force
approach quickly becomes infeasible.  In the classes within
<a class="reference internal" href="classes.html#module-sklearn.neighbors" title="sklearn.neighbors"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.neighbors</span></code></a>, brute-force neighbors searches are specified
using the keyword <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">'brute'</span></code>, and are computed using the
routines available in <a class="reference internal" href="classes.html#module-sklearn.metrics.pairwise" title="sklearn.metrics.pairwise"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.metrics.pairwise</span></code></a>.</p>
</section>
<section id="k-d-tree">
<span id="kd-tree"></span><h3><span class="section-number">1.6.4.2. </span>K-D Tree<a class="headerlink" href="#k-d-tree" title="Link to this heading">¶</a></h3>
<p>To address the computational inefficiencies of the brute-force approach, a
variety of tree-based data structures have been invented.  In general, these
structures attempt to reduce the required number of distance calculations
by efficiently encoding aggregate distance information for the sample.
The basic idea is that if point <span class="math notranslate nohighlight">\(A\)</span> is very distant from point
<span class="math notranslate nohighlight">\(B\)</span>, and point <span class="math notranslate nohighlight">\(B\)</span> is very close to point <span class="math notranslate nohighlight">\(C\)</span>,
then we know that points <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(C\)</span>
are very distant, <em>without having to explicitly calculate their distance</em>.
In this way, the computational cost of a nearest neighbors search can be
reduced to <span class="math notranslate nohighlight">\(O[D N \log(N)]\)</span> or better. This is a significant
improvement over brute-force for large <span class="math notranslate nohighlight">\(N\)</span>.</p>
<p>An early approach to taking advantage of this aggregate information was
the <em>KD tree</em> data structure (short for <em>K-dimensional tree</em>), which
generalizes two-dimensional <em>Quad-trees</em> and 3-dimensional <em>Oct-trees</em>
to an arbitrary number of dimensions.  The KD tree is a binary tree
structure which recursively partitions the parameter space along the data
axes, dividing it into nested orthotropic regions into which data points
are filed.  The construction of a KD tree is very fast: because partitioning
is performed only along the data axes, no <span class="math notranslate nohighlight">\(D\)</span>-dimensional distances
need to be computed. Once constructed, the nearest neighbor of a query
point can be determined with only <span class="math notranslate nohighlight">\(O[\log(N)]\)</span> distance computations.
Though the KD tree approach is very fast for low-dimensional (<span class="math notranslate nohighlight">\(D &lt; 20\)</span>)
neighbors searches, it becomes inefficient as <span class="math notranslate nohighlight">\(D\)</span> grows very large:
this is one manifestation of the so-called “curse of dimensionality”.
In scikit-learn, KD tree neighbors searches are specified using the
keyword <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">'kd_tree'</span></code>, and are computed using the class
<a class="reference internal" href="generated/sklearn.neighbors.KDTree.html#sklearn.neighbors.KDTree" title="sklearn.neighbors.KDTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">KDTree</span></code></a>.</p>
<aside class="topic">
<p class="topic-title">References:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://dl.acm.org/citation.cfm?doid=361002.361007">“Multidimensional binary search trees used for associative searching”</a>,
Bentley, J.L., Communications of the ACM (1975)</p></li>
</ul>
</aside>
</section>
<section id="ball-tree">
<span id="id2"></span><h3><span class="section-number">1.6.4.3. </span>Ball Tree<a class="headerlink" href="#ball-tree" title="Link to this heading">¶</a></h3>
<p>To address the inefficiencies of KD Trees in higher dimensions, the <em>ball tree</em>
data structure was developed.  Where KD trees partition data along
Cartesian axes, ball trees partition data in a series of nesting
hyper-spheres.  This makes tree construction more costly than that of the
KD tree, but results in a data structure which can be very efficient on
highly structured data, even in very high dimensions.</p>
<p>A ball tree recursively divides the data into
nodes defined by a centroid <span class="math notranslate nohighlight">\(C\)</span> and radius <span class="math notranslate nohighlight">\(r\)</span>, such that each
point in the node lies within the hyper-sphere defined by <span class="math notranslate nohighlight">\(r\)</span> and
<span class="math notranslate nohighlight">\(C\)</span>. The number of candidate points for a neighbor search
is reduced through use of the <em>triangle inequality</em>:</p>
<div class="math notranslate nohighlight">
\[|x+y| \leq |x| + |y|\]</div>
<p>With this setup, a single distance calculation between a test point and
the centroid is sufficient to determine a lower and upper bound on the
distance to all points within the node.
Because of the spherical geometry of the ball tree nodes, it can out-perform
a <em>KD-tree</em> in high dimensions, though the actual performance is highly
dependent on the structure of the training data.
In scikit-learn, ball-tree-based
neighbors searches are specified using the keyword <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">'ball_tree'</span></code>,
and are computed using the class <a class="reference internal" href="generated/sklearn.neighbors.BallTree.html#sklearn.neighbors.BallTree" title="sklearn.neighbors.BallTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">BallTree</span></code></a>.
Alternatively, the user can work with the <a class="reference internal" href="generated/sklearn.neighbors.BallTree.html#sklearn.neighbors.BallTree" title="sklearn.neighbors.BallTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">BallTree</span></code></a> class directly.</p>
<aside class="topic">
<p class="topic-title">References:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://citeseerx.ist.psu.edu/doc_view/pid/17ac002939f8e950ffb32ec4dc8e86bdd8cb5ff1">“Five Balltree Construction Algorithms”</a>,
Omohundro, S.M., International Computer Science Institute
Technical Report (1989)</p></li>
</ul>
</aside>
</section>
<section id="choice-of-nearest-neighbors-algorithm">
<h3><span class="section-number">1.6.4.4. </span>Choice of Nearest Neighbors Algorithm<a class="headerlink" href="#choice-of-nearest-neighbors-algorithm" title="Link to this heading">¶</a></h3>
<p>The optimal algorithm for a given dataset is a complicated choice, and
depends on a number of factors:</p>
<ul>
<li><p>number of samples <span class="math notranslate nohighlight">\(N\)</span> (i.e. <code class="docutils literal notranslate"><span class="pre">n_samples</span></code>) and dimensionality
<span class="math notranslate nohighlight">\(D\)</span> (i.e. <code class="docutils literal notranslate"><span class="pre">n_features</span></code>).</p>
<ul class="simple">
<li><p><em>Brute force</em> query time grows as <span class="math notranslate nohighlight">\(O[D N]\)</span></p></li>
<li><p><em>Ball tree</em> query time grows as approximately <span class="math notranslate nohighlight">\(O[D \log(N)]\)</span></p></li>
<li><p><em>KD tree</em> query time changes with <span class="math notranslate nohighlight">\(D\)</span> in a way that is difficult
to precisely characterise.  For small <span class="math notranslate nohighlight">\(D\)</span> (less than 20 or so)
the cost is approximately <span class="math notranslate nohighlight">\(O[D\log(N)]\)</span>, and the KD tree
query can be very efficient.
For larger <span class="math notranslate nohighlight">\(D\)</span>, the cost increases to nearly <span class="math notranslate nohighlight">\(O[DN]\)</span>, and
the overhead due to the tree
structure can lead to queries which are slower than brute force.</p></li>
</ul>
<p>For small data sets (<span class="math notranslate nohighlight">\(N\)</span> less than 30 or so), <span class="math notranslate nohighlight">\(\log(N)\)</span> is
comparable to <span class="math notranslate nohighlight">\(N\)</span>, and brute force algorithms can be more efficient
than a tree-based approach.  Both <a class="reference internal" href="generated/sklearn.neighbors.KDTree.html#sklearn.neighbors.KDTree" title="sklearn.neighbors.KDTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">KDTree</span></code></a> and <a class="reference internal" href="generated/sklearn.neighbors.BallTree.html#sklearn.neighbors.BallTree" title="sklearn.neighbors.BallTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">BallTree</span></code></a>
address this through providing a <em>leaf size</em> parameter: this controls the
number of samples at which a query switches to brute-force.  This allows both
algorithms to approach the efficiency of a brute-force computation for small
<span class="math notranslate nohighlight">\(N\)</span>.</p>
</li>
<li><p>data structure: <em>intrinsic dimensionality</em> of the data and/or <em>sparsity</em>
of the data. Intrinsic dimensionality refers to the dimension
<span class="math notranslate nohighlight">\(d \le D\)</span> of a manifold on which the data lies, which can be linearly
or non-linearly embedded in the parameter space. Sparsity refers to the
degree to which the data fills the parameter space (this is to be
distinguished from the concept as used in “sparse” matrices.  The data
matrix may have no zero entries, but the <strong>structure</strong> can still be
“sparse” in this sense).</p>
<ul class="simple">
<li><p><em>Brute force</em> query time is unchanged by data structure.</p></li>
<li><p><em>Ball tree</em> and <em>KD tree</em> query times can be greatly influenced
by data structure.  In general, sparser data with a smaller intrinsic
dimensionality leads to faster query times.  Because the KD tree
internal representation is aligned with the parameter axes, it will not
generally show as much improvement as ball tree for arbitrarily
structured data.</p></li>
</ul>
<p>Datasets used in machine learning tend to be very structured, and are
very well-suited for tree-based queries.</p>
</li>
<li><p>number of neighbors <span class="math notranslate nohighlight">\(k\)</span> requested for a query point.</p>
<ul class="simple">
<li><p><em>Brute force</em> query time is largely unaffected by the value of <span class="math notranslate nohighlight">\(k\)</span></p></li>
<li><p><em>Ball tree</em> and <em>KD tree</em> query time will become slower as <span class="math notranslate nohighlight">\(k\)</span>
increases.  This is due to two effects: first, a larger <span class="math notranslate nohighlight">\(k\)</span> leads
to the necessity to search a larger portion of the parameter space.
Second, using <span class="math notranslate nohighlight">\(k &gt; 1\)</span> requires internal queueing of results
as the tree is traversed.</p></li>
</ul>
<p>As <span class="math notranslate nohighlight">\(k\)</span> becomes large compared to <span class="math notranslate nohighlight">\(N\)</span>, the ability to prune
branches in a tree-based query is reduced.  In this situation, Brute force
queries can be more efficient.</p>
</li>
<li><p>number of query points.  Both the ball tree and the KD Tree
require a construction phase.  The cost of this construction becomes
negligible when amortized over many queries.  If only a small number of
queries will be performed, however, the construction can make up
a significant fraction of the total cost.  If very few query points
will be required, brute force is better than a tree-based method.</p></li>
</ul>
<p>Currently, <code class="docutils literal notranslate"><span class="pre">algorithm</span> <span class="pre">=</span> <span class="pre">'auto'</span></code> selects <code class="docutils literal notranslate"><span class="pre">'brute'</span></code> if any of the following
conditions are verified:</p>
<ul class="simple">
<li><p>input data is sparse</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">metric</span> <span class="pre">=</span> <span class="pre">'precomputed'</span></code></p></li>
<li><p><span class="math notranslate nohighlight">\(D &gt; 15\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(k &gt;= N/2\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">effective_metric_</span></code> isn’t in the <code class="docutils literal notranslate"><span class="pre">VALID_METRICS</span></code> list for either
<code class="docutils literal notranslate"><span class="pre">'kd_tree'</span></code> or <code class="docutils literal notranslate"><span class="pre">'ball_tree'</span></code></p></li>
</ul>
<p>Otherwise, it selects the first out of <code class="docutils literal notranslate"><span class="pre">'kd_tree'</span></code> and <code class="docutils literal notranslate"><span class="pre">'ball_tree'</span></code> that
has <code class="docutils literal notranslate"><span class="pre">effective_metric_</span></code> in its <code class="docutils literal notranslate"><span class="pre">VALID_METRICS</span></code> list. This heuristic is
based on the following assumptions:</p>
<ul class="simple">
<li><p>the number of query points is at least the same order as the number of
training points</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">leaf_size</span></code> is close to its default value of <code class="docutils literal notranslate"><span class="pre">30</span></code></p></li>
<li><p>when <span class="math notranslate nohighlight">\(D &gt; 15\)</span>, the intrinsic dimensionality of the data is generally
too high for tree-based methods</p></li>
</ul>
</section>
<section id="effect-of-leaf-size">
<h3><span class="section-number">1.6.4.5. </span>Effect of <code class="docutils literal notranslate"><span class="pre">leaf_size</span></code><a class="headerlink" href="#effect-of-leaf-size" title="Link to this heading">¶</a></h3>
<p>As noted above, for small sample sizes a brute force search can be more
efficient than a tree-based query.  This fact is accounted for in the ball
tree and KD tree by internally switching to brute force searches within
leaf nodes.  The level of this switch can be specified with the parameter
<code class="docutils literal notranslate"><span class="pre">leaf_size</span></code>.  This parameter choice has many effects:</p>
<dl class="simple">
<dt><strong>construction time</strong></dt><dd><p>A larger <code class="docutils literal notranslate"><span class="pre">leaf_size</span></code> leads to a faster tree construction time, because
fewer nodes need to be created</p>
</dd>
<dt><strong>query time</strong></dt><dd><p>Both a large or small <code class="docutils literal notranslate"><span class="pre">leaf_size</span></code> can lead to suboptimal query cost.
For <code class="docutils literal notranslate"><span class="pre">leaf_size</span></code> approaching 1, the overhead involved in traversing
nodes can significantly slow query times.  For <code class="docutils literal notranslate"><span class="pre">leaf_size</span></code> approaching
the size of the training set, queries become essentially brute force.
A good compromise between these is <code class="docutils literal notranslate"><span class="pre">leaf_size</span> <span class="pre">=</span> <span class="pre">30</span></code>, the default value
of the parameter.</p>
</dd>
<dt><strong>memory</strong></dt><dd><p>As <code class="docutils literal notranslate"><span class="pre">leaf_size</span></code> increases, the memory required to store a tree structure
decreases.  This is especially important in the case of ball tree, which
stores a <span class="math notranslate nohighlight">\(D\)</span>-dimensional centroid for each node.  The required
storage space for <a class="reference internal" href="generated/sklearn.neighbors.BallTree.html#sklearn.neighbors.BallTree" title="sklearn.neighbors.BallTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">BallTree</span></code></a> is approximately <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">leaf_size</span></code> times
the size of the training set.</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">leaf_size</span></code> is not referenced for brute force queries.</p>
</section>
<section id="valid-metrics-for-nearest-neighbor-algorithms">
<h3><span class="section-number">1.6.4.6. </span>Valid Metrics for Nearest Neighbor Algorithms<a class="headerlink" href="#valid-metrics-for-nearest-neighbor-algorithms" title="Link to this heading">¶</a></h3>
<p>For a list of available metrics, see the documentation of the
<a class="reference internal" href="generated/sklearn.metrics.DistanceMetric.html#sklearn.metrics.DistanceMetric" title="sklearn.metrics.DistanceMetric"><code class="xref py py-class docutils literal notranslate"><span class="pre">DistanceMetric</span></code></a> class and the metrics listed in
<code class="docutils literal notranslate"><span class="pre">sklearn.metrics.pairwise.PAIRWISE_DISTANCE_FUNCTIONS</span></code>. Note that the “cosine”
metric uses <a class="reference internal" href="generated/sklearn.metrics.pairwise.cosine_distances.html#sklearn.metrics.pairwise.cosine_distances" title="sklearn.metrics.pairwise.cosine_distances"><code class="xref py py-func docutils literal notranslate"><span class="pre">cosine_distances</span></code></a>.</p>
<p>A list of valid metrics for any of the above algorithms can be obtained by using their
<code class="docutils literal notranslate"><span class="pre">valid_metric</span></code> attribute. For example, valid metrics for <code class="docutils literal notranslate"><span class="pre">KDTree</span></code> can be generated by:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KDTree</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">KDTree</span><span class="o">.</span><span class="n">valid_metrics</span><span class="p">))</span>
<span class="go">[&#39;chebyshev&#39;, &#39;cityblock&#39;, &#39;euclidean&#39;, &#39;infinity&#39;, &#39;l1&#39;, &#39;l2&#39;, &#39;manhattan&#39;, &#39;minkowski&#39;, &#39;p&#39;]</span>
</pre></div>
</div>
</section>
</section>
<section id="nearest-centroid-classifier">
<span id="id3"></span><h2><span class="section-number">1.6.5. </span>Nearest Centroid Classifier<a class="headerlink" href="#nearest-centroid-classifier" title="Link to this heading">¶</a></h2>
<p>The <a class="reference internal" href="generated/sklearn.neighbors.NearestCentroid.html#sklearn.neighbors.NearestCentroid" title="sklearn.neighbors.NearestCentroid"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestCentroid</span></code></a> classifier is a simple algorithm that represents
each class by the centroid of its members. In effect, this makes it
similar to the label updating phase of the <a class="reference internal" href="generated/sklearn.cluster.KMeans.html#sklearn.cluster.KMeans" title="sklearn.cluster.KMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">KMeans</span></code></a> algorithm.
It also has no parameters to choose, making it a good baseline classifier. It
does, however, suffer on non-convex classes, as well as when classes have
drastically different variances, as equal variance in all dimensions is
assumed. See Linear Discriminant Analysis (<a class="reference internal" href="generated/sklearn.discriminant_analysis.LinearDiscriminantAnalysis.html#sklearn.discriminant_analysis.LinearDiscriminantAnalysis" title="sklearn.discriminant_analysis.LinearDiscriminantAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearDiscriminantAnalysis</span></code></a>)
and Quadratic Discriminant Analysis (<a class="reference internal" href="generated/sklearn.discriminant_analysis.QuadraticDiscriminantAnalysis.html#sklearn.discriminant_analysis.QuadraticDiscriminantAnalysis" title="sklearn.discriminant_analysis.QuadraticDiscriminantAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuadraticDiscriminantAnalysis</span></code></a>)
for more complex methods that do not make this assumption. Usage of the default
<a class="reference internal" href="generated/sklearn.neighbors.NearestCentroid.html#sklearn.neighbors.NearestCentroid" title="sklearn.neighbors.NearestCentroid"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestCentroid</span></code></a> is simple:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">NearestCentroid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">NearestCentroid</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">NearestCentroid()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">([[</span><span class="o">-</span><span class="mf">0.8</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>
<span class="go">[1]</span>
</pre></div>
</div>
<section id="nearest-shrunken-centroid">
<h3><span class="section-number">1.6.5.1. </span>Nearest Shrunken Centroid<a class="headerlink" href="#nearest-shrunken-centroid" title="Link to this heading">¶</a></h3>
<p>The <a class="reference internal" href="generated/sklearn.neighbors.NearestCentroid.html#sklearn.neighbors.NearestCentroid" title="sklearn.neighbors.NearestCentroid"><code class="xref py py-class docutils literal notranslate"><span class="pre">NearestCentroid</span></code></a> classifier has a <code class="docutils literal notranslate"><span class="pre">shrink_threshold</span></code> parameter,
which implements the nearest shrunken centroid classifier. In effect, the value
of each feature for each centroid is divided by the within-class variance of
that feature. The feature values are then reduced by <code class="docutils literal notranslate"><span class="pre">shrink_threshold</span></code>. Most
notably, if a particular feature value crosses zero, it is set
to zero. In effect, this removes the feature from affecting the classification.
This is useful, for example, for removing noisy features.</p>
<p>In the example below, using a small shrink threshold increases the accuracy of
the model from 0.81 to 0.82.</p>
<p class="centered">
<strong><a class="reference external" href="../auto_examples/neighbors/plot_nearest_centroid.html"><img alt="nearest_centroid_1" src="../_images/sphx_glr_plot_nearest_centroid_001.png" style="width: 320.0px; height: 240.0px;" /></a> <a class="reference external" href="../auto_examples/neighbors/plot_nearest_centroid.html"><img alt="nearest_centroid_2" src="../_images/sphx_glr_plot_nearest_centroid_002.png" style="width: 320.0px; height: 240.0px;" /></a></strong></p><aside class="topic">
<p class="topic-title">Examples:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../auto_examples/neighbors/plot_nearest_centroid.html#sphx-glr-auto-examples-neighbors-plot-nearest-centroid-py"><span class="std std-ref">Nearest Centroid Classification</span></a>: an example of
classification using nearest centroid with different shrink thresholds.</p></li>
</ul>
</aside>
</section>
</section>
<section id="nearest-neighbors-transformer">
<span id="neighbors-transformer"></span><h2><span class="section-number">1.6.6. </span>Nearest Neighbors Transformer<a class="headerlink" href="#nearest-neighbors-transformer" title="Link to this heading">¶</a></h2>
<p>Many scikit-learn estimators rely on nearest neighbors: Several classifiers and
regressors such as <a class="reference internal" href="generated/sklearn.neighbors.KNeighborsClassifier.html#sklearn.neighbors.KNeighborsClassifier" title="sklearn.neighbors.KNeighborsClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">KNeighborsClassifier</span></code></a> and
<a class="reference internal" href="generated/sklearn.neighbors.KNeighborsRegressor.html#sklearn.neighbors.KNeighborsRegressor" title="sklearn.neighbors.KNeighborsRegressor"><code class="xref py py-class docutils literal notranslate"><span class="pre">KNeighborsRegressor</span></code></a>, but also some clustering methods such as
<a class="reference internal" href="generated/sklearn.cluster.DBSCAN.html#sklearn.cluster.DBSCAN" title="sklearn.cluster.DBSCAN"><code class="xref py py-class docutils literal notranslate"><span class="pre">DBSCAN</span></code></a> and
<a class="reference internal" href="generated/sklearn.cluster.SpectralClustering.html#sklearn.cluster.SpectralClustering" title="sklearn.cluster.SpectralClustering"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpectralClustering</span></code></a>, and some manifold embeddings such
as <a class="reference internal" href="generated/sklearn.manifold.TSNE.html#sklearn.manifold.TSNE" title="sklearn.manifold.TSNE"><code class="xref py py-class docutils literal notranslate"><span class="pre">TSNE</span></code></a> and <a class="reference internal" href="generated/sklearn.manifold.Isomap.html#sklearn.manifold.Isomap" title="sklearn.manifold.Isomap"><code class="xref py py-class docutils literal notranslate"><span class="pre">Isomap</span></code></a>.</p>
<p>All these estimators can compute internally the nearest neighbors, but most of
them also accept precomputed nearest neighbors <a class="reference internal" href="../glossary.html#term-sparse-graph"><span class="xref std std-term">sparse graph</span></a>,
as given by <a class="reference internal" href="generated/sklearn.neighbors.kneighbors_graph.html#sklearn.neighbors.kneighbors_graph" title="sklearn.neighbors.kneighbors_graph"><code class="xref py py-func docutils literal notranslate"><span class="pre">kneighbors_graph</span></code></a> and
<a class="reference internal" href="generated/sklearn.neighbors.radius_neighbors_graph.html#sklearn.neighbors.radius_neighbors_graph" title="sklearn.neighbors.radius_neighbors_graph"><code class="xref py py-func docutils literal notranslate"><span class="pre">radius_neighbors_graph</span></code></a>. With mode
<code class="docutils literal notranslate"><span class="pre">mode='connectivity'</span></code>, these functions return a binary adjacency sparse graph
as required, for instance, in <a class="reference internal" href="generated/sklearn.cluster.SpectralClustering.html#sklearn.cluster.SpectralClustering" title="sklearn.cluster.SpectralClustering"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpectralClustering</span></code></a>.
Whereas with <code class="docutils literal notranslate"><span class="pre">mode='distance'</span></code>, they return a distance sparse graph as required,
for instance, in <a class="reference internal" href="generated/sklearn.cluster.DBSCAN.html#sklearn.cluster.DBSCAN" title="sklearn.cluster.DBSCAN"><code class="xref py py-class docutils literal notranslate"><span class="pre">DBSCAN</span></code></a>. To include these functions in
a scikit-learn pipeline, one can also use the corresponding classes
<a class="reference internal" href="generated/sklearn.neighbors.KNeighborsTransformer.html#sklearn.neighbors.KNeighborsTransformer" title="sklearn.neighbors.KNeighborsTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">KNeighborsTransformer</span></code></a> and <a class="reference internal" href="generated/sklearn.neighbors.RadiusNeighborsTransformer.html#sklearn.neighbors.RadiusNeighborsTransformer" title="sklearn.neighbors.RadiusNeighborsTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">RadiusNeighborsTransformer</span></code></a>.
The benefits of this sparse graph API are multiple.</p>
<p>First, the precomputed graph can be re-used multiple times, for instance while
varying a parameter of the estimator. This can be done manually by the user, or
using the caching properties of the scikit-learn pipeline:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">tempfile</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.manifold</span> <span class="kn">import</span> <span class="n">Isomap</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsTransformer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">make_pipeline</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_regression</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache_path</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">gettempdir</span><span class="p">()</span>  <span class="c1"># we use a temporary folder here</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">make_regression</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n_features</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">estimator</span> <span class="o">=</span> <span class="n">make_pipeline</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">KNeighborsTransformer</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;distance&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Isomap</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;precomputed&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">memory</span><span class="o">=</span><span class="n">cache_path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_embedded</span> <span class="o">=</span> <span class="n">estimator</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_embedded</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(50, 3)</span>
</pre></div>
</div>
<p>Second, precomputing the graph can give finer control on the nearest neighbors
estimation, for instance enabling multiprocessing though the parameter
<code class="docutils literal notranslate"><span class="pre">n_jobs</span></code>, which might not be available in all estimators.</p>
<p>Finally, the precomputation can be performed by custom estimators to use
different implementations, such as approximate nearest neighbors methods, or
implementation with special data types. The precomputed neighbors
<a class="reference internal" href="../glossary.html#term-sparse-graph"><span class="xref std std-term">sparse graph</span></a> needs to be formatted as in
<a class="reference internal" href="generated/sklearn.neighbors.radius_neighbors_graph.html#sklearn.neighbors.radius_neighbors_graph" title="sklearn.neighbors.radius_neighbors_graph"><code class="xref py py-func docutils literal notranslate"><span class="pre">radius_neighbors_graph</span></code></a> output:</p>
<ul class="simple">
<li><p>a CSR matrix (although COO, CSC or LIL will be accepted).</p></li>
<li><p>only explicitly store nearest neighborhoods of each sample with respect to the
training data. This should include those at 0 distance from a query point,
including the matrix diagonal when computing the nearest neighborhoods
between the training data and itself.</p></li>
<li><p>each row’s <code class="docutils literal notranslate"><span class="pre">data</span></code> should store the distance in increasing order (optional.
Unsorted data will be stable-sorted, adding a computational overhead).</p></li>
<li><p>all values in data should be non-negative.</p></li>
<li><p>there should be no duplicate <code class="docutils literal notranslate"><span class="pre">indices</span></code> in any row
(see <a class="reference external" href="https://github.com/scipy/scipy/issues/5807">https://github.com/scipy/scipy/issues/5807</a>).</p></li>
<li><p>if the algorithm being passed the precomputed matrix uses k nearest neighbors
(as opposed to radius neighborhood), at least k neighbors must be stored in
each row (or k+1, as explained in the following note).</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When a specific number of neighbors is queried (using
<a class="reference internal" href="generated/sklearn.neighbors.KNeighborsTransformer.html#sklearn.neighbors.KNeighborsTransformer" title="sklearn.neighbors.KNeighborsTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">KNeighborsTransformer</span></code></a>), the definition of <code class="docutils literal notranslate"><span class="pre">n_neighbors</span></code> is ambiguous
since it can either include each training point as its own neighbor, or
exclude them. Neither choice is perfect, since including them leads to a
different number of non-self neighbors during training and testing, while
excluding them leads to a difference between <code class="docutils literal notranslate"><span class="pre">fit(X).transform(X)</span></code> and
<code class="docutils literal notranslate"><span class="pre">fit_transform(X)</span></code>, which is against scikit-learn API.
In <a class="reference internal" href="generated/sklearn.neighbors.KNeighborsTransformer.html#sklearn.neighbors.KNeighborsTransformer" title="sklearn.neighbors.KNeighborsTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">KNeighborsTransformer</span></code></a> we use the definition which includes each
training point as its own neighbor in the count of <code class="docutils literal notranslate"><span class="pre">n_neighbors</span></code>. However,
for compatibility reasons with other estimators which use the other
definition, one extra neighbor will be computed when <code class="docutils literal notranslate"><span class="pre">mode</span> <span class="pre">==</span> <span class="pre">'distance'</span></code>.
To maximise compatibility with all estimators, a safe choice is to always
include one extra neighbor in a custom nearest neighbors estimator, since
unnecessary neighbors will be filtered by following estimators.</p>
</div>
<aside class="topic">
<p class="topic-title">Examples:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../auto_examples/neighbors/approximate_nearest_neighbors.html#sphx-glr-auto-examples-neighbors-approximate-nearest-neighbors-py"><span class="std std-ref">Approximate nearest neighbors in TSNE</span></a>:
an example of pipelining <a class="reference internal" href="generated/sklearn.neighbors.KNeighborsTransformer.html#sklearn.neighbors.KNeighborsTransformer" title="sklearn.neighbors.KNeighborsTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">KNeighborsTransformer</span></code></a> and
<a class="reference internal" href="generated/sklearn.manifold.TSNE.html#sklearn.manifold.TSNE" title="sklearn.manifold.TSNE"><code class="xref py py-class docutils literal notranslate"><span class="pre">TSNE</span></code></a>. Also proposes two custom nearest neighbors
estimators based on external packages.</p></li>
<li><p><a class="reference internal" href="../auto_examples/neighbors/plot_caching_nearest_neighbors.html#sphx-glr-auto-examples-neighbors-plot-caching-nearest-neighbors-py"><span class="std std-ref">Caching nearest neighbors</span></a>:
an example of pipelining <a class="reference internal" href="generated/sklearn.neighbors.KNeighborsTransformer.html#sklearn.neighbors.KNeighborsTransformer" title="sklearn.neighbors.KNeighborsTransformer"><code class="xref py py-class docutils literal notranslate"><span class="pre">KNeighborsTransformer</span></code></a> and
<a class="reference internal" href="generated/sklearn.neighbors.KNeighborsClassifier.html#sklearn.neighbors.KNeighborsClassifier" title="sklearn.neighbors.KNeighborsClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">KNeighborsClassifier</span></code></a> to enable caching of the neighbors graph
during a hyper-parameter grid-search.</p></li>
</ul>
</aside>
</section>
<section id="neighborhood-components-analysis">
<span id="nca"></span><h2><span class="section-number">1.6.7. </span>Neighborhood Components Analysis<a class="headerlink" href="#neighborhood-components-analysis" title="Link to this heading">¶</a></h2>
<p>Neighborhood Components Analysis (NCA, <a class="reference internal" href="generated/sklearn.neighbors.NeighborhoodComponentsAnalysis.html#sklearn.neighbors.NeighborhoodComponentsAnalysis" title="sklearn.neighbors.NeighborhoodComponentsAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">NeighborhoodComponentsAnalysis</span></code></a>)
is a distance metric learning algorithm which aims to improve the accuracy of
nearest neighbors classification compared to the standard Euclidean distance.
The algorithm directly maximizes a stochastic variant of the leave-one-out
k-nearest neighbors (KNN) score on the training set. It can also learn a
low-dimensional linear projection of data that can be used for data
visualization and fast classification.</p>
<p class="centered">
<strong><a class="reference external" href="../auto_examples/neighbors/plot_nca_illustration.html"><img alt="nca_illustration_1" src="../_images/sphx_glr_plot_nca_illustration_001.png" style="width: 320.0px; height: 240.0px;" /></a> <a class="reference external" href="../auto_examples/neighbors/plot_nca_illustration.html"><img alt="nca_illustration_2" src="../_images/sphx_glr_plot_nca_illustration_002.png" style="width: 320.0px; height: 240.0px;" /></a></strong></p><p>In the above illustrating figure, we consider some points from a randomly
generated dataset. We focus on the stochastic KNN classification of point no.
3. The thickness of a link between sample 3 and another point is proportional
to their distance, and can be seen as the relative weight (or probability) that
a stochastic nearest neighbor prediction rule would assign to this point. In
the original space, sample 3 has many stochastic neighbors from various
classes, so the right class is not very likely. However, in the projected space
learned by NCA, the only stochastic neighbors with non-negligible weight are
from the same class as sample 3, guaranteeing that the latter will be well
classified. See the <a class="reference internal" href="#nca-mathematical-formulation"><span class="std std-ref">mathematical formulation</span></a>
for more details.</p>
<section id="id4">
<h3><span class="section-number">1.6.7.1. </span>Classification<a class="headerlink" href="#id4" title="Link to this heading">¶</a></h3>
<p>Combined with a nearest neighbors classifier (<a class="reference internal" href="generated/sklearn.neighbors.KNeighborsClassifier.html#sklearn.neighbors.KNeighborsClassifier" title="sklearn.neighbors.KNeighborsClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">KNeighborsClassifier</span></code></a>),
NCA is attractive for classification because it can naturally handle
multi-class problems without any increase in the model size, and does not
introduce additional parameters that require fine-tuning by the user.</p>
<p>NCA classification has been shown to work well in practice for data sets of
varying size and difficulty. In contrast to related methods such as Linear
Discriminant Analysis, NCA does not make any assumptions about the class
distributions. The nearest neighbor classification can naturally produce highly
irregular decision boundaries.</p>
<p>To use this model for classification, one needs to combine a
<a class="reference internal" href="generated/sklearn.neighbors.NeighborhoodComponentsAnalysis.html#sklearn.neighbors.NeighborhoodComponentsAnalysis" title="sklearn.neighbors.NeighborhoodComponentsAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">NeighborhoodComponentsAnalysis</span></code></a> instance that learns the optimal
transformation with a <a class="reference internal" href="generated/sklearn.neighbors.KNeighborsClassifier.html#sklearn.neighbors.KNeighborsClassifier" title="sklearn.neighbors.KNeighborsClassifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">KNeighborsClassifier</span></code></a> instance that performs the
classification in the projected space. Here is an example using the two
classes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="p">(</span><span class="n">NeighborhoodComponentsAnalysis</span><span class="p">,</span>
<span class="gp">... </span><span class="n">KNeighborsClassifier</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">load_iris</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">load_iris</span><span class="p">(</span><span class="n">return_X_y</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
<span class="gp">... </span><span class="n">stratify</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nca</span> <span class="o">=</span> <span class="n">NeighborhoodComponentsAnalysis</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nca_pipe</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">([(</span><span class="s1">&#39;nca&#39;</span><span class="p">,</span> <span class="n">nca</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;knn&#39;</span><span class="p">,</span> <span class="n">knn</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nca_pipe</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="go">Pipeline(...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nca_pipe</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">))</span>
<span class="go">0.96190476...</span>
</pre></div>
</div>
<p class="centered">
<strong><a class="reference external" href="../auto_examples/neighbors/plot_nca_classification.html"><img alt="nca_classification_1" src="../_images/sphx_glr_plot_nca_classification_001.png" style="width: 320.0px; height: 240.0px;" /></a> <a class="reference external" href="../auto_examples/neighbors/plot_nca_classification.html"><img alt="nca_classification_2" src="../_images/sphx_glr_plot_nca_classification_002.png" style="width: 320.0px; height: 240.0px;" /></a></strong></p><p>The plot shows decision boundaries for Nearest Neighbor Classification and
Neighborhood Components Analysis classification on the iris dataset, when
training and scoring on only two features, for visualisation purposes.</p>
</section>
<section id="dimensionality-reduction">
<span id="nca-dim-reduction"></span><h3><span class="section-number">1.6.7.2. </span>Dimensionality reduction<a class="headerlink" href="#dimensionality-reduction" title="Link to this heading">¶</a></h3>
<p>NCA can be used to perform supervised dimensionality reduction. The input data
are projected onto a linear subspace consisting of the directions which
minimize the NCA objective. The desired dimensionality can be set using the
parameter <code class="docutils literal notranslate"><span class="pre">n_components</span></code>. For instance, the following figure shows a
comparison of dimensionality reduction with Principal Component Analysis
(<a class="reference internal" href="generated/sklearn.decomposition.PCA.html#sklearn.decomposition.PCA" title="sklearn.decomposition.PCA"><code class="xref py py-class docutils literal notranslate"><span class="pre">PCA</span></code></a>), Linear Discriminant Analysis
(<a class="reference internal" href="generated/sklearn.discriminant_analysis.LinearDiscriminantAnalysis.html#sklearn.discriminant_analysis.LinearDiscriminantAnalysis" title="sklearn.discriminant_analysis.LinearDiscriminantAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearDiscriminantAnalysis</span></code></a>) and
Neighborhood Component Analysis (<a class="reference internal" href="generated/sklearn.neighbors.NeighborhoodComponentsAnalysis.html#sklearn.neighbors.NeighborhoodComponentsAnalysis" title="sklearn.neighbors.NeighborhoodComponentsAnalysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">NeighborhoodComponentsAnalysis</span></code></a>) on
the Digits dataset, a dataset with size <span class="math notranslate nohighlight">\(n_{samples} = 1797\)</span> and
<span class="math notranslate nohighlight">\(n_{features} = 64\)</span>. The data set is split into a training and a test set
of equal size, then standardized. For evaluation the 3-nearest neighbor
classification accuracy is computed on the 2-dimensional projected points found
by each method. Each data sample belongs to one of 10 classes.</p>
<p class="centered">
<strong><a class="reference external" href="../auto_examples/neighbors/plot_nca_dim_reduction.html"><img alt="nca_dim_reduction_1" src="../_images/sphx_glr_plot_nca_dim_reduction_001.png" style="width: 32%;" /></a> <a class="reference external" href="../auto_examples/neighbors/plot_nca_dim_reduction.html"><img alt="nca_dim_reduction_2" src="../_images/sphx_glr_plot_nca_dim_reduction_002.png" style="width: 32%;" /></a> <a class="reference external" href="../auto_examples/neighbors/plot_nca_dim_reduction.html"><img alt="nca_dim_reduction_3" src="../_images/sphx_glr_plot_nca_dim_reduction_003.png" style="width: 32%;" /></a></strong></p><aside class="topic">
<p class="topic-title">Examples:</p>
<ul class="simple">
<li><p><a class="reference internal" href="../auto_examples/neighbors/plot_nca_classification.html#sphx-glr-auto-examples-neighbors-plot-nca-classification-py"><span class="std std-ref">Comparing Nearest Neighbors with and without Neighborhood Components Analysis</span></a></p></li>
<li><p><a class="reference internal" href="../auto_examples/neighbors/plot_nca_dim_reduction.html#sphx-glr-auto-examples-neighbors-plot-nca-dim-reduction-py"><span class="std std-ref">Dimensionality Reduction with Neighborhood Components Analysis</span></a></p></li>
<li><p><a class="reference internal" href="../auto_examples/manifold/plot_lle_digits.html#sphx-glr-auto-examples-manifold-plot-lle-digits-py"><span class="std std-ref">Manifold learning on handwritten digits: Locally Linear Embedding, Isomap…</span></a></p></li>
</ul>
</aside>
</section>
<section id="mathematical-formulation">
<span id="nca-mathematical-formulation"></span><h3><span class="section-number">1.6.7.3. </span>Mathematical formulation<a class="headerlink" href="#mathematical-formulation" title="Link to this heading">¶</a></h3>
<p>The goal of NCA is to learn an optimal linear transformation matrix of size
<code class="docutils literal notranslate"><span class="pre">(n_components,</span> <span class="pre">n_features)</span></code>, which maximises the sum over all samples
<span class="math notranslate nohighlight">\(i\)</span> of the probability <span class="math notranslate nohighlight">\(p_i\)</span> that <span class="math notranslate nohighlight">\(i\)</span> is correctly
classified, i.e.:</p>
<div class="math notranslate nohighlight">
\[\underset{L}{\arg\max} \sum\limits_{i=0}^{N - 1} p_{i}\]</div>
<p>with <span class="math notranslate nohighlight">\(N\)</span> = <code class="docutils literal notranslate"><span class="pre">n_samples</span></code> and <span class="math notranslate nohighlight">\(p_i\)</span> the probability of sample
<span class="math notranslate nohighlight">\(i\)</span> being correctly classified according to a stochastic nearest
neighbors rule in the learned embedded space:</p>
<div class="math notranslate nohighlight">
\[p_{i}=\sum\limits_{j \in C_i}{p_{i j}}\]</div>
<p>where <span class="math notranslate nohighlight">\(C_i\)</span> is the set of points in the same class as sample <span class="math notranslate nohighlight">\(i\)</span>,
and <span class="math notranslate nohighlight">\(p_{i j}\)</span> is the softmax over Euclidean distances in the embedded
space:</p>
<div class="math notranslate nohighlight">
\[p_{i j} = \frac{\exp(-||L x_i - L x_j||^2)}{\sum\limits_{k \ne
          i} {\exp{-(||L x_i - L x_k||^2)}}} , \quad p_{i i} = 0\]</div>
<section id="mahalanobis-distance">
<h4><span class="section-number">1.6.7.3.1. </span>Mahalanobis distance<a class="headerlink" href="#mahalanobis-distance" title="Link to this heading">¶</a></h4>
<p>NCA can be seen as learning a (squared) Mahalanobis distance metric:</p>
<div class="math notranslate nohighlight">
\[|| L(x_i - x_j)||^2 = (x_i - x_j)^TM(x_i - x_j),\]</div>
<p>where <span class="math notranslate nohighlight">\(M = L^T L\)</span> is a symmetric positive semi-definite matrix of size
<code class="docutils literal notranslate"><span class="pre">(n_features,</span> <span class="pre">n_features)</span></code>.</p>
</section>
</section>
<section id="implementation">
<h3><span class="section-number">1.6.7.4. </span>Implementation<a class="headerlink" href="#implementation" title="Link to this heading">¶</a></h3>
<p>This implementation follows what is explained in the original paper <a class="footnote-reference brackets" href="#id6" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. For
the optimisation method, it currently uses scipy’s L-BFGS-B with a full
gradient computation at each iteration, to avoid to tune the learning rate and
provide stable learning.</p>
<p>See the examples below and the docstring of
<a class="reference internal" href="generated/sklearn.neighbors.NeighborhoodComponentsAnalysis.html#sklearn.neighbors.NeighborhoodComponentsAnalysis.fit" title="sklearn.neighbors.NeighborhoodComponentsAnalysis.fit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">NeighborhoodComponentsAnalysis.fit</span></code></a> for further information.</p>
</section>
<section id="complexity">
<h3><span class="section-number">1.6.7.5. </span>Complexity<a class="headerlink" href="#complexity" title="Link to this heading">¶</a></h3>
<section id="training">
<h4><span class="section-number">1.6.7.5.1. </span>Training<a class="headerlink" href="#training" title="Link to this heading">¶</a></h4>
<p>NCA stores a matrix of pairwise distances, taking <code class="docutils literal notranslate"><span class="pre">n_samples</span> <span class="pre">**</span> <span class="pre">2</span></code> memory.
Time complexity depends on the number of iterations done by the optimisation
algorithm. However, one can set the maximum number of iterations with the
argument <code class="docutils literal notranslate"><span class="pre">max_iter</span></code>. For each iteration, time complexity is
<code class="docutils literal notranslate"><span class="pre">O(n_components</span> <span class="pre">x</span> <span class="pre">n_samples</span> <span class="pre">x</span> <span class="pre">min(n_samples,</span> <span class="pre">n_features))</span></code>.</p>
</section>
<section id="transform">
<h4><span class="section-number">1.6.7.5.2. </span>Transform<a class="headerlink" href="#transform" title="Link to this heading">¶</a></h4>
<p>Here the <code class="docutils literal notranslate"><span class="pre">transform</span></code> operation returns <span class="math notranslate nohighlight">\(LX^T\)</span>, therefore its time
complexity equals <code class="docutils literal notranslate"><span class="pre">n_components</span> <span class="pre">*</span> <span class="pre">n_features</span> <span class="pre">*</span> <span class="pre">n_samples_test</span></code>. There is no
added space complexity in the operation.</p>
<aside class="topic">
<p class="topic-title">References:</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id6" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://www.cs.nyu.edu/~roweis/papers/ncanips.pdf">“Neighbourhood Components Analysis”</a>,
J. Goldberger, S. Roweis, G. Hinton, R. Salakhutdinov, Advances in
Neural Information Processing Systems, Vol. 17, May 2005, pp. 513-520.</p>
</aside>
</aside>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Neighbourhood_components_analysis">Wikipedia entry on Neighborhood Components Analysis</a></p>
</aside>
</section>
</section>
</section>
</section>


      </div>
    <div class="container">
      <footer class="sk-content-footer">
            &copy; 2007 - 2023, scikit-learn developers (BSD License).
          <a href="../_sources/modules/neighbors.rst.txt" rel="nofollow">Show this page source</a>
      </footer>
    </div>
  </div>
</div>
<script src="../_static/js/vendor/bootstrap.min.js"></script>

<script>
    window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
    ga('create', 'UA-22606712-2', 'auto');
    ga('set', 'anonymizeIp', true);
    ga('send', 'pageview');
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



<script defer data-domain="scikit-learn.org" src="https://views.scientific-python.org/js/script.js">
</script>


<script src="../_static/clipboard.min.js"></script>
<script src="../_static/copybutton.js"></script>

<script>
$(document).ready(function() {
    /* Add a [>>>] button on the top-right corner of code samples to hide
     * the >>> and ... prompts and the output and thus make the code
     * copyable. */
    var div = $('.highlight-python .highlight,' +
                '.highlight-python3 .highlight,' +
                '.highlight-pycon .highlight,' +
		'.highlight-default .highlight')
    var pre = div.find('pre');

    // get the styles from the current theme
    pre.parent().parent().css('position', 'relative');

    // create and add the button to all the code blocks that contain >>>
    div.each(function(index) {
        var jthis = $(this);
        // tracebacks (.gt) contain bare text elements that need to be
        // wrapped in a span to work with .nextUntil() (see later)
        jthis.find('pre:has(.gt)').contents().filter(function() {
            return ((this.nodeType == 3) && (this.data.trim().length > 0));
        }).wrap('<span>');
    });

	/*** Add permalink buttons next to glossary terms ***/
	$('dl.glossary > dt[id]').append(function() {
		return ('<a class="headerlink" href="#' +
			    this.getAttribute('id') +
			    '" title="Permalink to this term">¶</a>');
	});
});

</script>
    
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    
</body>
</html>