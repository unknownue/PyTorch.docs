<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>Array Iterator API &mdash; NumPy v1.18 Manual</title>
    
    <link rel="stylesheet" type="text/css" href="../../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" >
    <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.18.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../_static/js/copybutton.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" >
    <link rel="index" title="Index" href="../../genindex.html" >
    <link rel="search" title="Search" href="../../search.html" >
    <link rel="top" title="NumPy v1.18 Manual" href="../../index.html" >
    <link rel="up" title="NumPy C-API" href="index.html" >
    <link rel="next" title="UFunc API" href="ufunc.html" >
    <link rel="prev" title="Array API" href="array.html" > 
  </head>
  <body>
<div class="container">
  <div class="top-scipy-org-logo-header" style="background-color: #a2bae8;">
    <a href="../../index.html">
      <img border=0 alt="NumPy" src="../../_static/numpy_logo.png"></a>
    </div>
  </div>
</div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        <li class="active"><a href="https://numpy.org/">NumPy.org</a></li>
        <li class="active"><a href="https://numpy.org/doc">Docs</a></li>
        
        <li class="active"><a href="../../index.html">NumPy v1.18 Manual</a></li>
        

          <li class="active"><a href="../index.html" >NumPy Reference</a></li>
          <li class="active"><a href="index.html" accesskey="U">NumPy C-API</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="ufunc.html" title="UFunc API"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="array.html" title="Array API"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Array Iterator API</a><ul>
<li><a class="reference internal" href="#array-iterator">Array Iterator</a></li>
<li><a class="reference internal" href="#simple-iteration-example">Simple Iteration Example</a></li>
<li><a class="reference internal" href="#simple-multi-iteration-example">Simple Multi-Iteration Example</a></li>
<li><a class="reference internal" href="#iterator-data-types">Iterator Data Types</a></li>
<li><a class="reference internal" href="#construction-and-destruction">Construction and Destruction</a></li>
<li><a class="reference internal" href="#functions-for-iteration">Functions For Iteration</a></li>
<li><a class="reference internal" href="#converting-from-previous-numpy-iterators">Converting from Previous NumPy Iterators</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="array.html"
                        title="previous chapter">Array API</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="ufunc.html"
                        title="next chapter">UFunc API</a></p>
<div id="searchbox" style="display: none" role="search">
  <h4>Quick search</h4>
    <div>
    <form class="search" action="../../search.html" method="get">
      <input type="text" style="width: inherit;" name="q" />
      <input type="submit" value="search" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="array-iterator-api">
<h1>Array Iterator API<a class="headerlink" href="#array-iterator-api" title="Permalink to this headline">¶</a></h1>
<div class="versionadded" id="index-0">
<p><span class="versionmodified added">New in version 1.6.</span></p>
</div>
<div class="section" id="array-iterator">
<h2>Array Iterator<a class="headerlink" href="#array-iterator" title="Permalink to this headline">¶</a></h2>
<p>The array iterator encapsulates many of the key features in ufuncs,
allowing user code to support features like output parameters,
preservation of memory layouts, and buffering of data with the wrong
alignment or type, without requiring difficult coding.</p>
<p>This page documents the API for the iterator.
The iterator is named <code class="docutils literal notranslate"><span class="pre">NpyIter</span></code> and functions are
named <code class="docutils literal notranslate"><span class="pre">NpyIter_*</span></code>.</p>
<p>There is an <a class="reference internal" href="../arrays.nditer.html#arrays-nditer"><span class="std std-ref">introductory guide to array iteration</span></a>
which may be of interest for those using this C API. In many instances,
testing out ideas by creating the iterator in Python is a good idea
before writing the C iteration code.</p>
</div>
<div class="section" id="simple-iteration-example">
<h2>Simple Iteration Example<a class="headerlink" href="#simple-iteration-example" title="Permalink to this headline">¶</a></h2>
<p>The best way to become familiar with the iterator is to look at its
usage within the NumPy codebase itself. For example, here is a slightly
tweaked version of the code for <a class="reference internal" href="array.html#c.PyArray_CountNonzero" title="PyArray_CountNonzero"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_CountNonzero</span></code></a>, which counts the
number of non-zero elements in an array.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">npy_intp</span> <span class="nf">PyArray_CountNonzero</span><span class="p">(</span><span class="n">PyArrayObject</span><span class="o">*</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Nonzero boolean function */</span>
    <span class="n">PyArray_NonzeroFunc</span><span class="o">*</span> <span class="n">nonzero</span> <span class="o">=</span> <span class="n">PyArray_DESCR</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">nonzero</span><span class="p">;</span>

    <span class="n">NpyIter</span><span class="o">*</span> <span class="n">iter</span><span class="p">;</span>
    <span class="n">NpyIter_IterNextFunc</span> <span class="o">*</span><span class="n">iternext</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">**</span> <span class="n">dataptr</span><span class="p">;</span>
    <span class="n">npy_intp</span> <span class="n">nonzero_count</span><span class="p">;</span>
    <span class="n">npy_intp</span><span class="o">*</span> <span class="n">strideptr</span><span class="p">,</span><span class="o">*</span> <span class="n">innersizeptr</span><span class="p">;</span>

    <span class="cm">/* Handle zero-sized arrays specially */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyArray_SIZE</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*</span>
<span class="cm">     * Create and use an iterator to count the nonzeros.</span>
<span class="cm">     *   flag NPY_ITER_READONLY</span>
<span class="cm">     *     - The array is never written to.</span>
<span class="cm">     *   flag NPY_ITER_EXTERNAL_LOOP</span>
<span class="cm">     *     - Inner loop is done outside the iterator for efficiency.</span>
<span class="cm">     *   flag NPY_ITER_NPY_ITER_REFS_OK</span>
<span class="cm">     *     - Reference types are acceptable.</span>
<span class="cm">     *   order NPY_KEEPORDER</span>
<span class="cm">     *     - Visit elements in memory order, regardless of strides.</span>
<span class="cm">     *       This is good for performance when the specific order</span>
<span class="cm">     *       elements are visited is unimportant.</span>
<span class="cm">     *   casting NPY_NO_CASTING</span>
<span class="cm">     *     - No casting is required for this operation.</span>
<span class="cm">     */</span>
    <span class="n">iter</span> <span class="o">=</span> <span class="n">NpyIter_New</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">NPY_ITER_READONLY</span><span class="o">|</span>
                             <span class="n">NPY_ITER_EXTERNAL_LOOP</span><span class="o">|</span>
                             <span class="n">NPY_ITER_REFS_OK</span><span class="p">,</span>
                        <span class="n">NPY_KEEPORDER</span><span class="p">,</span> <span class="n">NPY_NO_CASTING</span><span class="p">,</span>
                        <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*</span>
<span class="cm">     * The iternext function gets stored in a local variable</span>
<span class="cm">     * so it can be called repeatedly in an efficient manner.</span>
<span class="cm">     */</span>
    <span class="n">iternext</span> <span class="o">=</span> <span class="n">NpyIter_GetIterNext</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iternext</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NpyIter_Deallocate</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* The location of the data pointer which the iterator may update */</span>
    <span class="n">dataptr</span> <span class="o">=</span> <span class="n">NpyIter_GetDataPtrArray</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
    <span class="cm">/* The location of the stride which the iterator may update */</span>
    <span class="n">strideptr</span> <span class="o">=</span> <span class="n">NpyIter_GetInnerStrideArray</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
    <span class="cm">/* The location of the inner loop size which the iterator may update */</span>
    <span class="n">innersizeptr</span> <span class="o">=</span> <span class="n">NpyIter_GetInnerLoopSizePtr</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

    <span class="n">nonzero_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="cm">/* Get the inner loop data/stride/count values */</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="o">*</span><span class="n">dataptr</span><span class="p">;</span>
        <span class="n">npy_intp</span> <span class="n">stride</span> <span class="o">=</span> <span class="o">*</span><span class="n">strideptr</span><span class="p">;</span>
        <span class="n">npy_intp</span> <span class="n">count</span> <span class="o">=</span> <span class="o">*</span><span class="n">innersizeptr</span><span class="p">;</span>

        <span class="cm">/* This is a typical inner loop for NPY_ITER_EXTERNAL_LOOP */</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nonzero</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">self</span><span class="p">))</span> <span class="p">{</span>
                <span class="o">++</span><span class="n">nonzero_count</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">data</span> <span class="o">+=</span> <span class="n">stride</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Increment the iterator to the next inner loop */</span>
    <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">iternext</span><span class="p">(</span><span class="n">iter</span><span class="p">));</span>

    <span class="n">NpyIter_Deallocate</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">nonzero_count</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="simple-multi-iteration-example">
<h2>Simple Multi-Iteration Example<a class="headerlink" href="#simple-multi-iteration-example" title="Permalink to this headline">¶</a></h2>
<p>Here is a simple copy function using the iterator.  The <code class="docutils literal notranslate"><span class="pre">order</span></code> parameter
is used to control the memory layout of the allocated result, typically
<a class="reference internal" href="array.html#c.NPY_KEEPORDER" title="NPY_KEEPORDER"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_KEEPORDER</span></code></a> is desired.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PyObject</span> <span class="o">*</span><span class="nf">CopyArray</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="n">NPY_ORDER</span> <span class="n">order</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">NpyIter</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
    <span class="n">NpyIter_IterNextFunc</span> <span class="o">*</span><span class="n">iternext</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
    <span class="n">npy_uint32</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">npy_uint32</span> <span class="n">op_flags</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">npy_intp</span> <span class="n">itemsize</span><span class="p">,</span> <span class="o">*</span><span class="n">innersizeptr</span><span class="p">,</span> <span class="n">innerstride</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">**</span><span class="n">dataptrarray</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">     * No inner iteration - inner loop is handled by CopyArray code</span>
<span class="cm">     */</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">NPY_ITER_EXTERNAL_LOOP</span><span class="p">;</span>
    <span class="cm">/*</span>
<span class="cm">     * Tell the constructor to automatically allocate the output.</span>
<span class="cm">     * The data type of the output will match that of the input.</span>
<span class="cm">     */</span>
    <span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span>
    <span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">op_flags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">NPY_ITER_READONLY</span><span class="p">;</span>
    <span class="n">op_flags</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">NPY_ITER_WRITEONLY</span> <span class="o">|</span> <span class="n">NPY_ITER_ALLOCATE</span><span class="p">;</span>

    <span class="cm">/* Construct the iterator */</span>
    <span class="n">iter</span> <span class="o">=</span> <span class="n">NpyIter_MultiNew</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">NPY_NO_CASTING</span><span class="p">,</span>
                            <span class="n">op_flags</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*</span>
<span class="cm">     * Make a copy of the iternext function pointer and</span>
<span class="cm">     * a few other variables the inner loop needs.</span>
<span class="cm">     */</span>
    <span class="n">iternext</span> <span class="o">=</span> <span class="n">NpyIter_GetIterNext</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">innerstride</span> <span class="o">=</span> <span class="n">NpyIter_GetInnerStrideArray</span><span class="p">(</span><span class="n">iter</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">itemsize</span> <span class="o">=</span> <span class="n">NpyIter_GetDescrArray</span><span class="p">(</span><span class="n">iter</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">elsize</span><span class="p">;</span>
    <span class="cm">/*</span>
<span class="cm">     * The inner loop size and data pointers may change during the</span>
<span class="cm">     * loop, so just cache the addresses.</span>
<span class="cm">     */</span>
    <span class="n">innersizeptr</span> <span class="o">=</span> <span class="n">NpyIter_GetInnerLoopSizePtr</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
    <span class="n">dataptrarray</span> <span class="o">=</span> <span class="n">NpyIter_GetDataPtrArray</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * Note that because the iterator allocated the output,</span>
<span class="cm">     * it matches the iteration order and is packed tightly,</span>
<span class="cm">     * so we don&#39;t need to check it like the input.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">innerstride</span> <span class="o">==</span> <span class="n">itemsize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="n">memcpy</span><span class="p">(</span><span class="n">dataptrarray</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dataptrarray</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                    <span class="n">itemsize</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">innersizeptr</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">iternext</span><span class="p">(</span><span class="n">iter</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* For efficiency, should specialize this based on item size... */</span>
        <span class="n">npy_intp</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="n">npy_intp</span> <span class="n">size</span> <span class="o">=</span> <span class="o">*</span><span class="n">innersizeptr</span><span class="p">;</span>
            <span class="kt">char</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="n">dataptrarray</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">dataptrarray</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
            <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">src</span> <span class="o">+=</span> <span class="n">innerstride</span><span class="p">,</span> <span class="n">dst</span> <span class="o">+=</span> <span class="n">itemsize</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">itemsize</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">iternext</span><span class="p">(</span><span class="n">iter</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="cm">/* Get the result from the iterator object array */</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">NpyIter_GetOperandArray</span><span class="p">(</span><span class="n">iter</span><span class="p">)[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">NpyIter_Deallocate</span><span class="p">(</span><span class="n">iter</span><span class="p">)</span> <span class="o">!=</span> <span class="n">NPY_SUCCEED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="iterator-data-types">
<h2>Iterator Data Types<a class="headerlink" href="#iterator-data-types" title="Permalink to this headline">¶</a></h2>
<p>The iterator layout is an internal detail, and user code only sees
an incomplete struct.</p>
<dl class="type">
<dt id="c.NpyIter">
<code class="sig-name descname">NpyIter</code><a class="headerlink" href="#c.NpyIter" title="Permalink to this definition">¶</a></dt>
<dd><p>This is an opaque pointer type for the iterator. Access to its contents
can only be done through the iterator API.</p>
</dd></dl>

<dl class="type">
<dt id="c.NpyIter_Type">
<code class="sig-name descname">NpyIter_Type</code><a class="headerlink" href="#c.NpyIter_Type" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the type which exposes the iterator to Python. Currently, no
API is exposed which provides access to the values of a Python-created
iterator. If an iterator is created in Python, it must be used in Python
and vice versa. Such an API will likely be created in a future version.</p>
</dd></dl>

<dl class="type">
<dt id="c.NpyIter_IterNextFunc">
<code class="sig-name descname">NpyIter_IterNextFunc</code><a class="headerlink" href="#c.NpyIter_IterNextFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function pointer for the iteration loop, returned by
<a class="reference internal" href="#c.NpyIter_GetIterNext" title="NpyIter_GetIterNext"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_GetIterNext</span></code></a>.</p>
</dd></dl>

<dl class="type">
<dt id="c.NpyIter_GetMultiIndexFunc">
<code class="sig-name descname">NpyIter_GetMultiIndexFunc</code><a class="headerlink" href="#c.NpyIter_GetMultiIndexFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function pointer for getting the current iterator multi-index,
returned by <a class="reference internal" href="#c.NpyIter_GetGetMultiIndex" title="NpyIter_GetGetMultiIndex"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_GetGetMultiIndex</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="construction-and-destruction">
<h2>Construction and Destruction<a class="headerlink" href="#construction-and-destruction" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.NpyIter_New">
<a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>* <code class="sig-name descname">NpyIter_New</code><span class="sig-paren">(</span><a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>*<em> op</em>, <a class="reference internal" href="dtype.html#c.npy_uint32" title="npy_uint32">npy_uint32</a><em> flags</em>, <a class="reference internal" href="array.html#c.NPY_ORDER" title="NPY_ORDER">NPY_ORDER</a><em> order</em>, <a class="reference internal" href="array.html#c.NPY_CASTING" title="NPY_CASTING">NPY_CASTING</a><em> casting</em>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>*<em> dtype</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_New" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an iterator for the given numpy array object <code class="docutils literal notranslate"><span class="pre">op</span></code>.</p>
<p>Flags that may be passed in <code class="docutils literal notranslate"><span class="pre">flags</span></code> are any combination
of the global and per-operand flags documented in
<a class="reference internal" href="#c.NpyIter_MultiNew" title="NpyIter_MultiNew"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_MultiNew</span></code></a>, except for <a class="reference internal" href="#c.NPY_ITER_ALLOCATE" title="NPY_ITER_ALLOCATE"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_ALLOCATE</span></code></a>.</p>
<p>Any of the <a class="reference internal" href="array.html#c.NPY_ORDER" title="NPY_ORDER"><code class="xref c c-type docutils literal notranslate"><span class="pre">NPY_ORDER</span></code></a> enum values may be passed to <code class="docutils literal notranslate"><span class="pre">order</span></code>.  For
efficient iteration, <a class="reference internal" href="array.html#c.NPY_KEEPORDER" title="NPY_KEEPORDER"><code class="xref c c-type docutils literal notranslate"><span class="pre">NPY_KEEPORDER</span></code></a> is the best option, and
the other orders enforce the particular iteration pattern.</p>
<p>Any of the <a class="reference internal" href="array.html#c.NPY_CASTING" title="NPY_CASTING"><code class="xref c c-type docutils literal notranslate"><span class="pre">NPY_CASTING</span></code></a> enum values may be passed to <code class="docutils literal notranslate"><span class="pre">casting</span></code>.
The values include <a class="reference internal" href="array.html#c.NPY_NO_CASTING" title="NPY_NO_CASTING"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_NO_CASTING</span></code></a>, <a class="reference internal" href="array.html#c.NPY_EQUIV_CASTING" title="NPY_EQUIV_CASTING"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_EQUIV_CASTING</span></code></a>,
<a class="reference internal" href="array.html#c.NPY_SAFE_CASTING" title="NPY_SAFE_CASTING"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_SAFE_CASTING</span></code></a>, <a class="reference internal" href="array.html#c.NPY_SAME_KIND_CASTING" title="NPY_SAME_KIND_CASTING"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_SAME_KIND_CASTING</span></code></a>, and
<a class="reference internal" href="array.html#c.NPY_UNSAFE_CASTING" title="NPY_UNSAFE_CASTING"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_UNSAFE_CASTING</span></code></a>.  To allow the casts to occur, copying or
buffering must also be enabled.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">dtype</span></code> isn’t <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, then it requires that data type.
If copying is allowed, it will make a temporary copy if the data
is castable.  If <a class="reference internal" href="#c.NPY_ITER_UPDATEIFCOPY" title="NPY_ITER_UPDATEIFCOPY"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_UPDATEIFCOPY</span></code></a> is enabled, it will
also copy the data back with another cast upon iterator destruction.</p>
<p>Returns NULL if there is an error, otherwise returns the allocated
iterator.</p>
<p>To make an iterator similar to the old iterator, this should work.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">iter</span> <span class="o">=</span> <span class="n">NpyIter_New</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">NPY_ITER_READWRITE</span><span class="p">,</span>
                    <span class="n">NPY_CORDER</span><span class="p">,</span> <span class="n">NPY_NO_CASTING</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></div>
</div>
<p>If you want to edit an array with aligned <code class="docutils literal notranslate"><span class="pre">double</span></code> code,
but the order doesn’t matter, you would use this.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">dtype</span> <span class="o">=</span> <span class="n">PyArray_DescrFromType</span><span class="p">(</span><span class="n">NPY_DOUBLE</span><span class="p">);</span>
<span class="n">iter</span> <span class="o">=</span> <span class="n">NpyIter_New</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">NPY_ITER_READWRITE</span><span class="o">|</span>
                    <span class="n">NPY_ITER_BUFFERED</span><span class="o">|</span>
                    <span class="n">NPY_ITER_NBO</span><span class="o">|</span>
                    <span class="n">NPY_ITER_ALIGNED</span><span class="p">,</span>
                    <span class="n">NPY_KEEPORDER</span><span class="p">,</span>
                    <span class="n">NPY_SAME_KIND_CASTING</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="p">);</span>
<span class="n">Py_DECREF</span><span class="p">(</span><span class="n">dtype</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_MultiNew">
<a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>* <code class="sig-name descname">NpyIter_MultiNew</code><span class="sig-paren">(</span><a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a><em> nop</em>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>**<em> op</em>, <a class="reference internal" href="dtype.html#c.npy_uint32" title="npy_uint32">npy_uint32</a><em> flags</em>, <a class="reference internal" href="array.html#c.NPY_ORDER" title="NPY_ORDER">NPY_ORDER</a><em> order</em>, <a class="reference internal" href="array.html#c.NPY_CASTING" title="NPY_CASTING">NPY_CASTING</a><em> casting</em>, <a class="reference internal" href="dtype.html#c.npy_uint32" title="npy_uint32">npy_uint32</a>*<em> op_flags</em>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>**<em> op_dtypes</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_MultiNew" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an iterator for broadcasting the <code class="docutils literal notranslate"><span class="pre">nop</span></code> array objects provided
in <code class="docutils literal notranslate"><span class="pre">op</span></code>, using regular NumPy broadcasting rules.</p>
<p>Any of the <a class="reference internal" href="array.html#c.NPY_ORDER" title="NPY_ORDER"><code class="xref c c-type docutils literal notranslate"><span class="pre">NPY_ORDER</span></code></a> enum values may be passed to <code class="docutils literal notranslate"><span class="pre">order</span></code>.  For
efficient iteration, <a class="reference internal" href="array.html#c.NPY_KEEPORDER" title="NPY_KEEPORDER"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_KEEPORDER</span></code></a> is the best option, and the
other orders enforce the particular iteration pattern.  When using
<a class="reference internal" href="array.html#c.NPY_KEEPORDER" title="NPY_KEEPORDER"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_KEEPORDER</span></code></a>, if you also want to ensure that the iteration is
not reversed along an axis, you should pass the flag
<a class="reference internal" href="#c.NPY_ITER_DONT_NEGATE_STRIDES" title="NPY_ITER_DONT_NEGATE_STRIDES"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_DONT_NEGATE_STRIDES</span></code></a>.</p>
<p>Any of the <a class="reference internal" href="array.html#c.NPY_CASTING" title="NPY_CASTING"><code class="xref c c-type docutils literal notranslate"><span class="pre">NPY_CASTING</span></code></a> enum values may be passed to <code class="docutils literal notranslate"><span class="pre">casting</span></code>.
The values include <a class="reference internal" href="array.html#c.NPY_NO_CASTING" title="NPY_NO_CASTING"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_NO_CASTING</span></code></a>, <a class="reference internal" href="array.html#c.NPY_EQUIV_CASTING" title="NPY_EQUIV_CASTING"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_EQUIV_CASTING</span></code></a>,
<a class="reference internal" href="array.html#c.NPY_SAFE_CASTING" title="NPY_SAFE_CASTING"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_SAFE_CASTING</span></code></a>, <a class="reference internal" href="array.html#c.NPY_SAME_KIND_CASTING" title="NPY_SAME_KIND_CASTING"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_SAME_KIND_CASTING</span></code></a>, and
<a class="reference internal" href="array.html#c.NPY_UNSAFE_CASTING" title="NPY_UNSAFE_CASTING"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_UNSAFE_CASTING</span></code></a>.  To allow the casts to occur, copying or
buffering must also be enabled.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">op_dtypes</span></code> isn’t <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, it specifies a data type or <code class="docutils literal notranslate"><span class="pre">NULL</span></code>
for each <code class="docutils literal notranslate"><span class="pre">op[i]</span></code>.</p>
<p>Returns NULL if there is an error, otherwise returns the allocated
iterator.</p>
<p>Flags that may be passed in <code class="docutils literal notranslate"><span class="pre">flags</span></code>, applying to the whole
iterator, are:</p>
<blockquote>
<div><dl class="var">
<dt id="c.NPY_ITER_C_INDEX">
<code class="sig-name descname">NPY_ITER_C_INDEX</code><a class="headerlink" href="#c.NPY_ITER_C_INDEX" title="Permalink to this definition">¶</a></dt>
<dd><p>Causes the iterator to track a raveled flat index matching C
order. This option cannot be used with <a class="reference internal" href="#c.NPY_ITER_F_INDEX" title="NPY_ITER_F_INDEX"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_F_INDEX</span></code></a>.</p>
</dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_F_INDEX">
<code class="sig-name descname">NPY_ITER_F_INDEX</code><a class="headerlink" href="#c.NPY_ITER_F_INDEX" title="Permalink to this definition">¶</a></dt>
<dd><p>Causes the iterator to track a raveled flat index matching Fortran
order. This option cannot be used with <a class="reference internal" href="#c.NPY_ITER_C_INDEX" title="NPY_ITER_C_INDEX"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_C_INDEX</span></code></a>.</p>
</dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_MULTI_INDEX">
<code class="sig-name descname">NPY_ITER_MULTI_INDEX</code><a class="headerlink" href="#c.NPY_ITER_MULTI_INDEX" title="Permalink to this definition">¶</a></dt>
<dd><p>Causes the iterator to track a multi-index.
This prevents the iterator from coalescing axes to
produce bigger inner loops. If the loop is also not buffered
and no index is being tracked (<em class="xref py py-obj">NpyIter_RemoveAxis</em> can be called),
then the iterator size can be <code class="docutils literal notranslate"><span class="pre">-1</span></code> to indicate that the iterator
is too large. This can happen due to complex broadcasting and
will result in errors being created when the setting the iterator
range, removing the multi index, or getting the next function.
However, it is possible to remove axes again and use the iterator
normally if the size is small enough after removal.</p>
</dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_EXTERNAL_LOOP">
<code class="sig-name descname">NPY_ITER_EXTERNAL_LOOP</code><a class="headerlink" href="#c.NPY_ITER_EXTERNAL_LOOP" title="Permalink to this definition">¶</a></dt>
<dd><p>Causes the iterator to skip iteration of the innermost
loop, requiring the user of the iterator to handle it.</p>
<p>This flag is incompatible with <a class="reference internal" href="#c.NPY_ITER_C_INDEX" title="NPY_ITER_C_INDEX"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_C_INDEX</span></code></a>,
<a class="reference internal" href="#c.NPY_ITER_F_INDEX" title="NPY_ITER_F_INDEX"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_F_INDEX</span></code></a>, and <a class="reference internal" href="#c.NPY_ITER_MULTI_INDEX" title="NPY_ITER_MULTI_INDEX"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_MULTI_INDEX</span></code></a>.</p>
</dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_DONT_NEGATE_STRIDES">
<code class="sig-name descname">NPY_ITER_DONT_NEGATE_STRIDES</code><a class="headerlink" href="#c.NPY_ITER_DONT_NEGATE_STRIDES" title="Permalink to this definition">¶</a></dt>
<dd><p>This only affects the iterator when <a class="reference internal" href="array.html#c.NPY_KEEPORDER" title="NPY_KEEPORDER"><code class="xref c c-type docutils literal notranslate"><span class="pre">NPY_KEEPORDER</span></code></a> is
specified for the order parameter.  By default with
<a class="reference internal" href="array.html#c.NPY_KEEPORDER" title="NPY_KEEPORDER"><code class="xref c c-type docutils literal notranslate"><span class="pre">NPY_KEEPORDER</span></code></a>, the iterator reverses axes which have
negative strides, so that memory is traversed in a forward
direction.  This disables this step.  Use this flag if you
want to use the underlying memory-ordering of the axes,
but don’t want an axis reversed. This is the behavior of
<code class="docutils literal notranslate"><span class="pre">numpy.ravel(a,</span> <span class="pre">order='K')</span></code>, for instance.</p>
</dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_COMMON_DTYPE">
<code class="sig-name descname">NPY_ITER_COMMON_DTYPE</code><a class="headerlink" href="#c.NPY_ITER_COMMON_DTYPE" title="Permalink to this definition">¶</a></dt>
<dd><p>Causes the iterator to convert all the operands to a common
data type, calculated based on the ufunc type promotion rules.
Copying or buffering must be enabled.</p>
<p>If the common data type is known ahead of time, don’t use this
flag.  Instead, set the requested dtype for all the operands.</p>
</dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_REFS_OK">
<code class="sig-name descname">NPY_ITER_REFS_OK</code><a class="headerlink" href="#c.NPY_ITER_REFS_OK" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates that arrays with reference types (object
arrays or structured arrays containing an object type)
may be accepted and used in the iterator.  If this flag
is enabled, the caller must be sure to check whether
<code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_IterationNeedsAPI(iter)</span></code> is true, in which case
it may not release the GIL during iteration.</p>
</dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_ZEROSIZE_OK">
<code class="sig-name descname">NPY_ITER_ZEROSIZE_OK</code><a class="headerlink" href="#c.NPY_ITER_ZEROSIZE_OK" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates that arrays with a size of zero should be permitted.
Since the typical iteration loop does not naturally work with
zero-sized arrays, you must check that the IterSize is larger
than zero before entering the iteration loop.
Currently only the operands are checked, not a forced shape.</p>
</dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_REDUCE_OK">
<code class="sig-name descname">NPY_ITER_REDUCE_OK</code><a class="headerlink" href="#c.NPY_ITER_REDUCE_OK" title="Permalink to this definition">¶</a></dt>
<dd><p>Permits writeable operands with a dimension with zero
stride and size greater than one.  Note that such operands
must be read/write.</p>
<p>When buffering is enabled, this also switches to a special
buffering mode which reduces the loop length as necessary to
not trample on values being reduced.</p>
<p>Note that if you want to do a reduction on an automatically
allocated output, you must use <a class="reference internal" href="#c.NpyIter_GetOperandArray" title="NpyIter_GetOperandArray"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_GetOperandArray</span></code></a>
to get its reference, then set every value to the reduction
unit before doing the iteration loop.  In the case of a
buffered reduction, this means you must also specify the
flag <a class="reference internal" href="#c.NPY_ITER_DELAY_BUFALLOC" title="NPY_ITER_DELAY_BUFALLOC"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_DELAY_BUFALLOC</span></code></a>, then reset the iterator
after initializing the allocated operand to prepare the
buffers.</p>
</dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_RANGED">
<code class="sig-name descname">NPY_ITER_RANGED</code><a class="headerlink" href="#c.NPY_ITER_RANGED" title="Permalink to this definition">¶</a></dt>
<dd><p>Enables support for iteration of sub-ranges of the full
<code class="docutils literal notranslate"><span class="pre">iterindex</span></code> range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">NpyIter_IterSize(iter))</span></code>.  Use
the function <a class="reference internal" href="#c.NpyIter_ResetToIterIndexRange" title="NpyIter_ResetToIterIndexRange"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_ResetToIterIndexRange</span></code></a> to specify
a range for iteration.</p>
<p>This flag can only be used with <a class="reference internal" href="#c.NPY_ITER_EXTERNAL_LOOP" title="NPY_ITER_EXTERNAL_LOOP"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_EXTERNAL_LOOP</span></code></a>
when <a class="reference internal" href="#c.NPY_ITER_BUFFERED" title="NPY_ITER_BUFFERED"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_BUFFERED</span></code></a> is enabled.  This is because
without buffering, the inner loop is always the size of the
innermost iteration dimension, and allowing it to get cut up
would require special handling, effectively making it more
like the buffered version.</p>
</dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_BUFFERED">
<code class="sig-name descname">NPY_ITER_BUFFERED</code><a class="headerlink" href="#c.NPY_ITER_BUFFERED" title="Permalink to this definition">¶</a></dt>
<dd><p>Causes the iterator to store buffering data, and use buffering
to satisfy data type, alignment, and byte-order requirements.
To buffer an operand, do not specify the <a class="reference internal" href="#c.NPY_ITER_COPY" title="NPY_ITER_COPY"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_COPY</span></code></a>
or <a class="reference internal" href="#c.NPY_ITER_UPDATEIFCOPY" title="NPY_ITER_UPDATEIFCOPY"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_UPDATEIFCOPY</span></code></a> flags, because they will
override buffering.  Buffering is especially useful for Python
code using the iterator, allowing for larger chunks
of data at once to amortize the Python interpreter overhead.</p>
<p>If used with <a class="reference internal" href="#c.NPY_ITER_EXTERNAL_LOOP" title="NPY_ITER_EXTERNAL_LOOP"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_EXTERNAL_LOOP</span></code></a>, the inner loop
for the caller may get larger chunks than would be possible
without buffering, because of how the strides are laid out.</p>
<p>Note that if an operand is given the flag <a class="reference internal" href="#c.NPY_ITER_COPY" title="NPY_ITER_COPY"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_COPY</span></code></a>
or <a class="reference internal" href="#c.NPY_ITER_UPDATEIFCOPY" title="NPY_ITER_UPDATEIFCOPY"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_UPDATEIFCOPY</span></code></a>, a copy will be made in preference
to buffering.  Buffering will still occur when the array was
broadcast so elements need to be duplicated to get a constant
stride.</p>
<p>In normal buffering, the size of each inner loop is equal
to the buffer size, or possibly larger if
<a class="reference internal" href="#c.NPY_ITER_GROWINNER" title="NPY_ITER_GROWINNER"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_GROWINNER</span></code></a> is specified.  If
<a class="reference internal" href="#c.NPY_ITER_REDUCE_OK" title="NPY_ITER_REDUCE_OK"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_REDUCE_OK</span></code></a> is enabled and a reduction occurs,
the inner loops may become smaller depending
on the structure of the reduction.</p>
</dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_GROWINNER">
<code class="sig-name descname">NPY_ITER_GROWINNER</code><a class="headerlink" href="#c.NPY_ITER_GROWINNER" title="Permalink to this definition">¶</a></dt>
<dd><p>When buffering is enabled, this allows the size of the inner
loop to grow when buffering isn’t necessary.  This option
is best used if you’re doing a straight pass through all the
data, rather than anything with small cache-friendly arrays
of temporary values for each inner loop.</p>
</dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_DELAY_BUFALLOC">
<code class="sig-name descname">NPY_ITER_DELAY_BUFALLOC</code><a class="headerlink" href="#c.NPY_ITER_DELAY_BUFALLOC" title="Permalink to this definition">¶</a></dt>
<dd><p>When buffering is enabled, this delays allocation of the
buffers until <a class="reference internal" href="#c.NpyIter_Reset" title="NpyIter_Reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_Reset</span></code></a> or another reset function is
called.  This flag exists to avoid wasteful copying of
buffer data when making multiple copies of a buffered
iterator for multi-threaded iteration.</p>
<p>Another use of this flag is for setting up reduction operations.
After the iterator is created, and a reduction output
is allocated automatically by the iterator (be sure to use
READWRITE access), its value may be initialized to the reduction
unit.  Use <a class="reference internal" href="#c.NpyIter_GetOperandArray" title="NpyIter_GetOperandArray"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_GetOperandArray</span></code></a> to get the object.
Then, call <a class="reference internal" href="#c.NpyIter_Reset" title="NpyIter_Reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_Reset</span></code></a> to allocate and fill the buffers
with their initial values.</p>
</dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_COPY_IF_OVERLAP">
<code class="sig-name descname">NPY_ITER_COPY_IF_OVERLAP</code><a class="headerlink" href="#c.NPY_ITER_COPY_IF_OVERLAP" title="Permalink to this definition">¶</a></dt>
<dd><p>If any write operand has overlap with any read operand, eliminate all
overlap by making temporary copies (enabling UPDATEIFCOPY for write
operands, if necessary). A pair of operands has overlap if there is
a memory address that contains data common to both arrays.</p>
<p>Because exact overlap detection has exponential runtime
in the number of dimensions, the decision is made based
on heuristics, which has false positives (needless copies in unusual
cases) but has no false negatives.</p>
<p>If any read/write overlap exists, this flag ensures the result of the
operation is the same as if all operands were copied.
In cases where copies would need to be made, <strong>the result of the
computation may be undefined without this flag!</strong></p>
</dd></dl>

</div></blockquote>
<p>Flags that may be passed in <code class="docutils literal notranslate"><span class="pre">op_flags[i]</span></code>, where <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">nop</span></code>:</p>
<blockquote>
<div><dl class="var">
<dt id="c.NPY_ITER_READWRITE">
<code class="sig-name descname">NPY_ITER_READWRITE</code><a class="headerlink" href="#c.NPY_ITER_READWRITE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_READONLY">
<code class="sig-name descname">NPY_ITER_READONLY</code><a class="headerlink" href="#c.NPY_ITER_READONLY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_WRITEONLY">
<code class="sig-name descname">NPY_ITER_WRITEONLY</code><a class="headerlink" href="#c.NPY_ITER_WRITEONLY" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate how the user of the iterator will read or write
to <code class="docutils literal notranslate"><span class="pre">op[i]</span></code>.  Exactly one of these flags must be specified
per operand. Using <code class="docutils literal notranslate"><span class="pre">NPY_ITER_READWRITE</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_ITER_WRITEONLY</span></code>
for a user-provided operand may trigger <em class="xref py py-obj">WRITEBACKIFCOPY`</em>
semantics. The data will be written back to the original array
when <code class="docutils literal notranslate"><span class="pre">NpyIter_Deallocate</span></code> is called.</p>
</dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_COPY">
<code class="sig-name descname">NPY_ITER_COPY</code><a class="headerlink" href="#c.NPY_ITER_COPY" title="Permalink to this definition">¶</a></dt>
<dd><p>Allow a copy of <code class="docutils literal notranslate"><span class="pre">op[i]</span></code> to be made if it does not
meet the data type or alignment requirements as specified
by the constructor flags and parameters.</p>
</dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_UPDATEIFCOPY">
<code class="sig-name descname">NPY_ITER_UPDATEIFCOPY</code><a class="headerlink" href="#c.NPY_ITER_UPDATEIFCOPY" title="Permalink to this definition">¶</a></dt>
<dd><p>Triggers <a class="reference internal" href="#c.NPY_ITER_COPY" title="NPY_ITER_COPY"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_COPY</span></code></a>, and when an array operand
is flagged for writing and is copied, causes the data
in a copy to be copied back to <code class="docutils literal notranslate"><span class="pre">op[i]</span></code> when
<code class="docutils literal notranslate"><span class="pre">NpyIter_Deallocate</span></code> is called.</p>
<p>If the operand is flagged as write-only and a copy is needed,
an uninitialized temporary array will be created and then copied
to back to <code class="docutils literal notranslate"><span class="pre">op[i]</span></code> on calling <code class="docutils literal notranslate"><span class="pre">NpyIter_Deallocate</span></code>, instead of
doing the unnecessary copy operation.</p>
</dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_NBO">
<code class="sig-name descname">NPY_ITER_NBO</code><a class="headerlink" href="#c.NPY_ITER_NBO" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_ALIGNED">
<code class="sig-name descname">NPY_ITER_ALIGNED</code><a class="headerlink" href="#c.NPY_ITER_ALIGNED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_CONTIG">
<code class="sig-name descname">NPY_ITER_CONTIG</code><a class="headerlink" href="#c.NPY_ITER_CONTIG" title="Permalink to this definition">¶</a></dt>
<dd><p>Causes the iterator to provide data for <code class="docutils literal notranslate"><span class="pre">op[i]</span></code>
that is in native byte order, aligned according to
the dtype requirements, contiguous, or any combination.</p>
<p>By default, the iterator produces pointers into the
arrays provided, which may be aligned or unaligned, and
with any byte order.  If copying or buffering is not
enabled and the operand data doesn’t satisfy the constraints,
an error will be raised.</p>
<p>The contiguous constraint applies only to the inner loop,
successive inner loops may have arbitrary pointer changes.</p>
<p>If the requested data type is in non-native byte order,
the NBO flag overrides it and the requested data type is
converted to be in native byte order.</p>
</dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_ALLOCATE">
<code class="sig-name descname">NPY_ITER_ALLOCATE</code><a class="headerlink" href="#c.NPY_ITER_ALLOCATE" title="Permalink to this definition">¶</a></dt>
<dd><p>This is for output arrays, and requires that the flag
<a class="reference internal" href="#c.NPY_ITER_WRITEONLY" title="NPY_ITER_WRITEONLY"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_WRITEONLY</span></code></a> or <a class="reference internal" href="#c.NPY_ITER_READWRITE" title="NPY_ITER_READWRITE"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_READWRITE</span></code></a>
be set.  If <code class="docutils literal notranslate"><span class="pre">op[i]</span></code> is NULL, creates a new array with
the final broadcast dimensions, and a layout matching
the iteration order of the iterator.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">op[i]</span></code> is NULL, the requested data type
<code class="docutils literal notranslate"><span class="pre">op_dtypes[i]</span></code> may be NULL as well, in which case it is
automatically generated from the dtypes of the arrays which
are flagged as readable.  The rules for generating the dtype
are the same is for UFuncs.  Of special note is handling
of byte order in the selected dtype.  If there is exactly
one input, the input’s dtype is used as is.  Otherwise,
if more than one input dtypes are combined together, the
output will be in native byte order.</p>
<p>After being allocated with this flag, the caller may retrieve
the new array by calling <a class="reference internal" href="#c.NpyIter_GetOperandArray" title="NpyIter_GetOperandArray"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_GetOperandArray</span></code></a> and
getting the i-th object in the returned C array.  The caller
must call Py_INCREF on it to claim a reference to the array.</p>
</dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_NO_SUBTYPE">
<code class="sig-name descname">NPY_ITER_NO_SUBTYPE</code><a class="headerlink" href="#c.NPY_ITER_NO_SUBTYPE" title="Permalink to this definition">¶</a></dt>
<dd><p>For use with <a class="reference internal" href="#c.NPY_ITER_ALLOCATE" title="NPY_ITER_ALLOCATE"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_ALLOCATE</span></code></a>, this flag disables
allocating an array subtype for the output, forcing
it to be a straight ndarray.</p>
<p>TODO: Maybe it would be better to introduce a function
<code class="docutils literal notranslate"><span class="pre">NpyIter_GetWrappedOutput</span></code> and remove this flag?</p>
</dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_NO_BROADCAST">
<code class="sig-name descname">NPY_ITER_NO_BROADCAST</code><a class="headerlink" href="#c.NPY_ITER_NO_BROADCAST" title="Permalink to this definition">¶</a></dt>
<dd><p>Ensures that the input or output matches the iteration
dimensions exactly.</p>
</dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_ARRAYMASK">
<code class="sig-name descname">NPY_ITER_ARRAYMASK</code><a class="headerlink" href="#c.NPY_ITER_ARRAYMASK" title="Permalink to this definition">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.</span></p>
</div>
<p>Indicates that this operand is the mask to use for
selecting elements when writing to operands which have
the <a class="reference internal" href="#c.NPY_ITER_WRITEMASKED" title="NPY_ITER_WRITEMASKED"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_WRITEMASKED</span></code></a> flag applied to them.
Only one operand may have <a class="reference internal" href="#c.NPY_ITER_ARRAYMASK" title="NPY_ITER_ARRAYMASK"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_ARRAYMASK</span></code></a> flag
applied to it.</p>
<p>The data type of an operand with this flag should be either
<a class="reference internal" href="dtype.html#c.NPY_BOOL" title="NPY_BOOL"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_BOOL</span></code></a>, <a class="reference internal" href="dtype.html#c.NPY_MASK" title="NPY_MASK"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_MASK</span></code></a>, or a struct dtype
whose fields are all valid mask dtypes. In the latter case,
it must match up with a struct operand being WRITEMASKED,
as it is specifying a mask for each field of that array.</p>
<p>This flag only affects writing from the buffer back to
the array. This means that if the operand is also
<a class="reference internal" href="#c.NPY_ITER_READWRITE" title="NPY_ITER_READWRITE"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_READWRITE</span></code></a> or <a class="reference internal" href="#c.NPY_ITER_WRITEONLY" title="NPY_ITER_WRITEONLY"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_WRITEONLY</span></code></a>,
code doing iteration can write to this operand to
control which elements will be untouched and which ones will be
modified. This is useful when the mask should be a combination
of input masks.</p>
</dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_WRITEMASKED">
<code class="sig-name descname">NPY_ITER_WRITEMASKED</code><a class="headerlink" href="#c.NPY_ITER_WRITEMASKED" title="Permalink to this definition">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.</span></p>
</div>
<p>This array is the mask for all <a class="reference internal" href="../generated/numpy.nditer.html#numpy.nditer" title="numpy.nditer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">writemasked</span></code></a>
operands. Code uses the <code class="docutils literal notranslate"><span class="pre">writemasked</span></code> flag which indicates
that only elements where the chosen ARRAYMASK operand is True
will be written to. In general, the iterator does not enforce
this, it is up to the code doing the iteration to follow that
promise.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">writemasked</span></code> flag is used, and this operand is buffered,
this changes how data is copied from the buffer into the array.
A masked copying routine is used, which only copies the
elements in the buffer for which <code class="docutils literal notranslate"><span class="pre">writemasked</span></code>
returns true from the corresponding element in the ARRAYMASK
operand.</p>
</dd></dl>

<dl class="var">
<dt id="c.NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE">
<code class="sig-name descname">NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE</code><a class="headerlink" href="#c.NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE" title="Permalink to this definition">¶</a></dt>
<dd><p>In memory overlap checks, assume that operands with
<code class="docutils literal notranslate"><span class="pre">NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE</span></code> enabled are accessed only
in the iterator order.</p>
<p>This enables the iterator to reason about data dependency,
possibly avoiding unnecessary copies.</p>
<p>This flag has effect only if <code class="docutils literal notranslate"><span class="pre">NPY_ITER_COPY_IF_OVERLAP</span></code> is enabled
on the iterator.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_AdvancedNew">
<a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>* <code class="sig-name descname">NpyIter_AdvancedNew</code><span class="sig-paren">(</span><a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a><em> nop</em>, <a class="reference internal" href="types-and-structures.html#c.PyArrayObject" title="PyArrayObject">PyArrayObject</a>**<em> op</em>, <a class="reference internal" href="dtype.html#c.npy_uint32" title="npy_uint32">npy_uint32</a><em> flags</em>, <a class="reference internal" href="array.html#c.NPY_ORDER" title="NPY_ORDER">NPY_ORDER</a><em> order</em>, <a class="reference internal" href="array.html#c.NPY_CASTING" title="NPY_CASTING">NPY_CASTING</a><em> casting</em>, <a class="reference internal" href="dtype.html#c.npy_uint32" title="npy_uint32">npy_uint32</a>*<em> op_flags</em>, <a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>**<em> op_dtypes</em>, int<em> oa_ndim</em>, int**<em> op_axes</em>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a> const*<em> itershape</em>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a><em> buffersize</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_AdvancedNew" title="Permalink to this definition">¶</a></dt>
<dd><p>Extends <a class="reference internal" href="#c.NpyIter_MultiNew" title="NpyIter_MultiNew"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_MultiNew</span></code></a> with several advanced options providing
more control over broadcasting and buffering.</p>
<p>If -1/NULL values are passed to <code class="docutils literal notranslate"><span class="pre">oa_ndim</span></code>, <code class="docutils literal notranslate"><span class="pre">op_axes</span></code>, <code class="docutils literal notranslate"><span class="pre">itershape</span></code>,
and <code class="docutils literal notranslate"><span class="pre">buffersize</span></code>, it is equivalent to <a class="reference internal" href="#c.NpyIter_MultiNew" title="NpyIter_MultiNew"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_MultiNew</span></code></a>.</p>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">oa_ndim</span></code>, when not zero or -1, specifies the number of
dimensions that will be iterated with customized broadcasting.
If it is provided, <code class="docutils literal notranslate"><span class="pre">op_axes</span></code> must and <code class="docutils literal notranslate"><span class="pre">itershape</span></code> can also be provided.
The <code class="docutils literal notranslate"><span class="pre">op_axes</span></code> parameter let you control in detail how the
axes of the operand arrays get matched together and iterated.
In <code class="docutils literal notranslate"><span class="pre">op_axes</span></code>, you must provide an array of <code class="docutils literal notranslate"><span class="pre">nop</span></code> pointers
to <code class="docutils literal notranslate"><span class="pre">oa_ndim</span></code>-sized arrays of type <code class="docutils literal notranslate"><span class="pre">npy_intp</span></code>.  If an entry
in <code class="docutils literal notranslate"><span class="pre">op_axes</span></code> is NULL, normal broadcasting rules will apply.
In <code class="docutils literal notranslate"><span class="pre">op_axes[j][i]</span></code> is stored either a valid axis of <code class="docutils literal notranslate"><span class="pre">op[j]</span></code>, or
-1 which means <code class="docutils literal notranslate"><span class="pre">newaxis</span></code>.  Within each <code class="docutils literal notranslate"><span class="pre">op_axes[j]</span></code> array, axes
may not be repeated.  The following example is how normal broadcasting
applies to a 3-D array, a 2-D array, a 1-D array and a scalar.</p>
<p><strong>Note</strong>: Before NumPy 1.8 <code class="docutils literal notranslate"><span class="pre">oa_ndim</span> <span class="pre">==</span> <span class="pre">0`</span> <span class="pre">was</span> <span class="pre">used</span> <span class="pre">for</span> <span class="pre">signalling</span> <span class="pre">that</span>
<span class="pre">that</span> <span class="pre">``op_axes</span></code> and <code class="docutils literal notranslate"><span class="pre">itershape</span></code> are unused. This is deprecated and
should be replaced with -1. Better backward compatibility may be
achieved by using <a class="reference internal" href="#c.NpyIter_MultiNew" title="NpyIter_MultiNew"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_MultiNew</span></code></a> for this case.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">oa_ndim</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>               <span class="cm">/* # iteration axes */</span>
<span class="kt">int</span> <span class="n">op0_axes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>    <span class="cm">/* 3-D operand */</span>
<span class="kt">int</span> <span class="n">op1_axes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>   <span class="cm">/* 2-D operand */</span>
<span class="kt">int</span> <span class="n">op2_axes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>  <span class="cm">/* 1-D operand */</span>
<span class="kt">int</span> <span class="n">op3_axes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>  <span class="cm">/* 0-D (scalar) operand */</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">op_axes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">op0_axes</span><span class="p">,</span> <span class="n">op1_axes</span><span class="p">,</span> <span class="n">op2_axes</span><span class="p">,</span> <span class="n">op3_axes</span><span class="p">};</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">itershape</span></code> parameter allows you to force the iterator
to have a specific iteration shape. It is an array of length
<code class="docutils literal notranslate"><span class="pre">oa_ndim</span></code>. When an entry is negative, its value is determined
from the operands. This parameter allows automatically allocated
outputs to get additional dimensions which don’t match up with
any dimension of an input.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">buffersize</span></code> is zero, a default buffer size is used,
otherwise it specifies how big of a buffer to use.  Buffers
which are powers of 2 such as 4096 or 8192 are recommended.</p>
<p>Returns NULL if there is an error, otherwise returns the allocated
iterator.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_Copy">
<a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>* <code class="sig-name descname">NpyIter_Copy</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_Copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes a copy of the given iterator.  This function is provided
primarily to enable multi-threaded iteration of the data.</p>
<p><em>TODO</em>: Move this to a section about multithreaded iteration.</p>
<p>The recommended approach to multithreaded iteration is to
first create an iterator with the flags
<a class="reference internal" href="#c.NPY_ITER_EXTERNAL_LOOP" title="NPY_ITER_EXTERNAL_LOOP"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_EXTERNAL_LOOP</span></code></a>, <a class="reference internal" href="#c.NPY_ITER_RANGED" title="NPY_ITER_RANGED"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_RANGED</span></code></a>,
<a class="reference internal" href="#c.NPY_ITER_BUFFERED" title="NPY_ITER_BUFFERED"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_BUFFERED</span></code></a>, <a class="reference internal" href="#c.NPY_ITER_DELAY_BUFALLOC" title="NPY_ITER_DELAY_BUFALLOC"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_DELAY_BUFALLOC</span></code></a>, and
possibly <a class="reference internal" href="#c.NPY_ITER_GROWINNER" title="NPY_ITER_GROWINNER"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_GROWINNER</span></code></a>.  Create a copy of this iterator
for each thread (minus one for the first iterator).  Then, take
the iteration index range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">NpyIter_GetIterSize(iter))</span></code> and
split it up into tasks, for example using a TBB parallel_for loop.
When a thread gets a task to execute, it then uses its copy of
the iterator by calling <a class="reference internal" href="#c.NpyIter_ResetToIterIndexRange" title="NpyIter_ResetToIterIndexRange"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_ResetToIterIndexRange</span></code></a> and
iterating over the full range.</p>
<p>When using the iterator in multi-threaded code or in code not
holding the Python GIL, care must be taken to only call functions
which are safe in that context.  <a class="reference internal" href="#c.NpyIter_Copy" title="NpyIter_Copy"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_Copy</span></code></a> cannot be safely
called without the Python GIL, because it increments Python
references.  The <code class="docutils literal notranslate"><span class="pre">Reset*</span></code> and some other functions may be safely
called by passing in the <code class="docutils literal notranslate"><span class="pre">errmsg</span></code> parameter as non-NULL, so that
the functions will pass back errors through it instead of setting
a Python exception.</p>
<p><a class="reference internal" href="#c.NpyIter_Deallocate" title="NpyIter_Deallocate"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_Deallocate</span></code></a> must be called for each copy.</p>
</dd></dl>

<dl class="function">
<dt>
<code class="sig-name descname">int NpyIter_RemoveAxis(NpyIter* iter, int axis)``</code></dt>
<dd><p>Removes an axis from iteration.  This requires that
<a class="reference internal" href="#c.NPY_ITER_MULTI_INDEX" title="NPY_ITER_MULTI_INDEX"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_MULTI_INDEX</span></code></a> was set for iterator creation, and does
not work if buffering is enabled or an index is being tracked. This
function also resets the iterator to its initial state.</p>
<p>This is useful for setting up an accumulation loop, for example.
The iterator can first be created with all the dimensions, including
the accumulation axis, so that the output gets created correctly.
Then, the accumulation axis can be removed, and the calculation
done in a nested fashion.</p>
<p><strong>WARNING</strong>: This function may change the internal memory layout of
the iterator.  Any cached functions or pointers from the iterator
must be retrieved again! The iterator range will be reset as well.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_RemoveMultiIndex">
int <code class="sig-name descname">NpyIter_RemoveMultiIndex</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_RemoveMultiIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>If the iterator is tracking a multi-index, this strips support for them,
and does further iterator optimizations that are possible if multi-indices
are not needed.  This function also resets the iterator to its initial
state.</p>
<p><strong>WARNING</strong>: This function may change the internal memory layout of
the iterator.  Any cached functions or pointers from the iterator
must be retrieved again!</p>
<p>After calling this function, <code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_HasMultiIndex(iter)</span></code> will
return false.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_EnableExternalLoop">
int <code class="sig-name descname">NpyIter_EnableExternalLoop</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_EnableExternalLoop" title="Permalink to this definition">¶</a></dt>
<dd><p>If <a class="reference internal" href="#c.NpyIter_RemoveMultiIndex" title="NpyIter_RemoveMultiIndex"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_RemoveMultiIndex</span></code></a> was called, you may want to enable the
flag <a class="reference internal" href="#c.NPY_ITER_EXTERNAL_LOOP" title="NPY_ITER_EXTERNAL_LOOP"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_EXTERNAL_LOOP</span></code></a>.  This flag is not permitted
together with <a class="reference internal" href="#c.NPY_ITER_MULTI_INDEX" title="NPY_ITER_MULTI_INDEX"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_MULTI_INDEX</span></code></a>, so this function is provided
to enable the feature after <a class="reference internal" href="#c.NpyIter_RemoveMultiIndex" title="NpyIter_RemoveMultiIndex"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_RemoveMultiIndex</span></code></a> is called.
This function also resets the iterator to its initial state.</p>
<p><strong>WARNING</strong>: This function changes the internal logic of the iterator.
Any cached functions or pointers from the iterator must be retrieved
again!</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_Deallocate">
int <code class="sig-name descname">NpyIter_Deallocate</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_Deallocate" title="Permalink to this definition">¶</a></dt>
<dd><p>Deallocates the iterator object and resolves any needed writebacks.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_Reset">
int <code class="sig-name descname">NpyIter_Reset</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em>, char**<em> errmsg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_Reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the iterator back to its initial state, at the beginning
of the iteration range.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.  If errmsg is non-NULL,
no Python exception is set when <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code> is returned.
Instead, *errmsg is set to an error message.  When errmsg is
non-NULL, the function may be safely called without holding
the Python GIL.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_ResetToIterIndexRange">
int <code class="sig-name descname">NpyIter_ResetToIterIndexRange</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a><em> istart</em>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a><em> iend</em>, char**<em> errmsg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_ResetToIterIndexRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the iterator and restricts it to the <code class="docutils literal notranslate"><span class="pre">iterindex</span></code> range
<code class="docutils literal notranslate"><span class="pre">[istart,</span> <span class="pre">iend)</span></code>.  See <a class="reference internal" href="#c.NpyIter_Copy" title="NpyIter_Copy"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_Copy</span></code></a> for an explanation of
how to use this for multi-threaded iteration.  This requires that
the flag <a class="reference internal" href="#c.NPY_ITER_RANGED" title="NPY_ITER_RANGED"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_RANGED</span></code></a> was passed to the iterator constructor.</p>
<p>If you want to reset both the <code class="docutils literal notranslate"><span class="pre">iterindex</span></code> range and the base
pointers at the same time, you can do the following to avoid
extra buffer copying (be sure to add the return code error checks
when you copy this code).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Set to a trivial empty range */</span>
<span class="n">NpyIter_ResetToIterIndexRange</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cm">/* Set the base pointers */</span>
<span class="n">NpyIter_ResetBasePointers</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">baseptrs</span><span class="p">);</span>
<span class="cm">/* Set to the desired range */</span>
<span class="n">NpyIter_ResetToIterIndexRange</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="n">istart</span><span class="p">,</span> <span class="n">iend</span><span class="p">);</span>
</pre></div>
</div>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.  If errmsg is non-NULL,
no Python exception is set when <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code> is returned.
Instead, *errmsg is set to an error message.  When errmsg is
non-NULL, the function may be safely called without holding
the Python GIL.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_ResetBasePointers">
int <code class="sig-name descname">NpyIter_ResetBasePointers</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a><em> *iter</em>, char**<em> baseptrs</em>, char**<em> errmsg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_ResetBasePointers" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the iterator back to its initial state, but using the values
in <code class="docutils literal notranslate"><span class="pre">baseptrs</span></code> for the data instead of the pointers from the arrays
being iterated.  This functions is intended to be used, together with
the <code class="docutils literal notranslate"><span class="pre">op_axes</span></code> parameter, by nested iteration code with two or more
iterators.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.  If errmsg is non-NULL,
no Python exception is set when <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code> is returned.
Instead, *errmsg is set to an error message.  When errmsg is
non-NULL, the function may be safely called without holding
the Python GIL.</p>
<p><em>TODO</em>: Move the following into a special section on nested iterators.</p>
<p>Creating iterators for nested iteration requires some care.  All
the iterator operands must match exactly, or the calls to
<a class="reference internal" href="#c.NpyIter_ResetBasePointers" title="NpyIter_ResetBasePointers"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_ResetBasePointers</span></code></a> will be invalid.  This means that
automatic copies and output allocation should not be used haphazardly.
It is possible to still use the automatic data conversion and casting
features of the iterator by creating one of the iterators with
all the conversion parameters enabled, then grabbing the allocated
operands with the <a class="reference internal" href="#c.NpyIter_GetOperandArray" title="NpyIter_GetOperandArray"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_GetOperandArray</span></code></a> function and passing
them into the constructors for the rest of the iterators.</p>
<p><strong>WARNING</strong>: When creating iterators for nested iteration,
the code must not use a dimension more than once in the different
iterators.  If this is done, nested iteration will produce
out-of-bounds pointers during iteration.</p>
<p><strong>WARNING</strong>: When creating iterators for nested iteration, buffering
can only be applied to the innermost iterator.  If a buffered iterator
is used as the source for <code class="docutils literal notranslate"><span class="pre">baseptrs</span></code>, it will point into a small buffer
instead of the array and the inner iteration will be invalid.</p>
<p>The pattern for using nested iterators is as follows.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">NpyIter</span> <span class="o">*</span><span class="n">iter1</span><span class="p">,</span> <span class="o">*</span><span class="n">iter1</span><span class="p">;</span>
<span class="n">NpyIter_IterNextFunc</span> <span class="o">*</span><span class="n">iternext1</span><span class="p">,</span> <span class="o">*</span><span class="n">iternext2</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">**</span><span class="n">dataptrs1</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * With the exact same operands, no copies allowed, and</span>
<span class="cm"> * no axis in op_axes used both in iter1 and iter2.</span>
<span class="cm"> * Buffering may be enabled for iter2, but not for iter1.</span>
<span class="cm"> */</span>
<span class="n">iter1</span> <span class="o">=</span> <span class="p">...;</span> <span class="n">iter2</span> <span class="o">=</span> <span class="p">...;</span>

<span class="n">iternext1</span> <span class="o">=</span> <span class="n">NpyIter_GetIterNext</span><span class="p">(</span><span class="n">iter1</span><span class="p">);</span>
<span class="n">iternext2</span> <span class="o">=</span> <span class="n">NpyIter_GetIterNext</span><span class="p">(</span><span class="n">iter2</span><span class="p">);</span>
<span class="n">dataptrs1</span> <span class="o">=</span> <span class="n">NpyIter_GetDataPtrArray</span><span class="p">(</span><span class="n">iter1</span><span class="p">);</span>

<span class="k">do</span> <span class="p">{</span>
    <span class="n">NpyIter_ResetBasePointers</span><span class="p">(</span><span class="n">iter2</span><span class="p">,</span> <span class="n">dataptrs1</span><span class="p">);</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="cm">/* Use the iter2 values */</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">iternext2</span><span class="p">(</span><span class="n">iter2</span><span class="p">));</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">iternext1</span><span class="p">(</span><span class="n">iter1</span><span class="p">));</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_GotoMultiIndex">
int <code class="sig-name descname">NpyIter_GotoMultiIndex</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a> const*<em> multi_index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GotoMultiIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjusts the iterator to point to the <code class="docutils literal notranslate"><span class="pre">ndim</span></code> indices
pointed to by <code class="docutils literal notranslate"><span class="pre">multi_index</span></code>.  Returns an error if a multi-index
is not being tracked, the indices are out of bounds,
or inner loop iteration is disabled.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_GotoIndex">
int <code class="sig-name descname">NpyIter_GotoIndex</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a><em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GotoIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjusts the iterator to point to the <code class="docutils literal notranslate"><span class="pre">index</span></code> specified.
If the iterator was constructed with the flag
<a class="reference internal" href="#c.NPY_ITER_C_INDEX" title="NPY_ITER_C_INDEX"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_C_INDEX</span></code></a>, <code class="docutils literal notranslate"><span class="pre">index</span></code> is the C-order index,
and if the iterator was constructed with the flag
<a class="reference internal" href="#c.NPY_ITER_F_INDEX" title="NPY_ITER_F_INDEX"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_F_INDEX</span></code></a>, <code class="docutils literal notranslate"><span class="pre">index</span></code> is the Fortran-order
index.  Returns an error if there is no index being tracked,
the index is out of bounds, or inner loop iteration is disabled.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_GetIterSize">
<a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a> <code class="sig-name descname">NpyIter_GetIterSize</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GetIterSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of elements being iterated.  This is the product
of all the dimensions in the shape.  When a multi index is being tracked
(and <em class="xref py py-obj">NpyIter_RemoveAxis</em> may be called) the size may be <code class="docutils literal notranslate"><span class="pre">-1</span></code> to
indicate an iterator is too large.  Such an iterator is invalid, but
may become valid after <em class="xref py py-obj">NpyIter_RemoveAxis</em> is called. It is not
necessary to check for this case.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_GetIterIndex">
<a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a> <code class="sig-name descname">NpyIter_GetIterIndex</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GetIterIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the <code class="docutils literal notranslate"><span class="pre">iterindex</span></code> of the iterator, which is an index matching
the iteration order of the iterator.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_GetIterIndexRange">
void <code class="sig-name descname">NpyIter_GetIterIndexRange</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a>*<em> istart</em>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a>*<em> iend</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GetIterIndexRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the <code class="docutils literal notranslate"><span class="pre">iterindex</span></code> sub-range that is being iterated.  If
<a class="reference internal" href="#c.NPY_ITER_RANGED" title="NPY_ITER_RANGED"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_RANGED</span></code></a> was not specified, this always returns the
range <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">NpyIter_IterSize(iter))</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_GotoIterIndex">
int <code class="sig-name descname">NpyIter_GotoIterIndex</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a><em> iterindex</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GotoIterIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjusts the iterator to point to the <code class="docutils literal notranslate"><span class="pre">iterindex</span></code> specified.
The IterIndex is an index matching the iteration order of the iterator.
Returns an error if the <code class="docutils literal notranslate"><span class="pre">iterindex</span></code> is out of bounds,
buffering is enabled, or inner loop iteration is disabled.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_HasDelayedBufAlloc">
<a class="reference internal" href="dtype.html#c.npy_bool" title="npy_bool">npy_bool</a> <code class="sig-name descname">NpyIter_HasDelayedBufAlloc</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_HasDelayedBufAlloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 1 if the flag <a class="reference internal" href="#c.NPY_ITER_DELAY_BUFALLOC" title="NPY_ITER_DELAY_BUFALLOC"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_DELAY_BUFALLOC</span></code></a> was passed
to the iterator constructor, and no call to one of the Reset
functions has been done yet, 0 otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_HasExternalLoop">
<a class="reference internal" href="dtype.html#c.npy_bool" title="npy_bool">npy_bool</a> <code class="sig-name descname">NpyIter_HasExternalLoop</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_HasExternalLoop" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 1 if the caller needs to handle the inner-most 1-dimensional
loop, or 0 if the iterator handles all looping. This is controlled
by the constructor flag <a class="reference internal" href="#c.NPY_ITER_EXTERNAL_LOOP" title="NPY_ITER_EXTERNAL_LOOP"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_EXTERNAL_LOOP</span></code></a> or
<a class="reference internal" href="#c.NpyIter_EnableExternalLoop" title="NpyIter_EnableExternalLoop"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_EnableExternalLoop</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_HasMultiIndex">
<a class="reference internal" href="dtype.html#c.npy_bool" title="npy_bool">npy_bool</a> <code class="sig-name descname">NpyIter_HasMultiIndex</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_HasMultiIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 1 if the iterator was created with the
<a class="reference internal" href="#c.NPY_ITER_MULTI_INDEX" title="NPY_ITER_MULTI_INDEX"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_MULTI_INDEX</span></code></a> flag, 0 otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_HasIndex">
<a class="reference internal" href="dtype.html#c.npy_bool" title="npy_bool">npy_bool</a> <code class="sig-name descname">NpyIter_HasIndex</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_HasIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 1 if the iterator was created with the
<a class="reference internal" href="#c.NPY_ITER_C_INDEX" title="NPY_ITER_C_INDEX"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_C_INDEX</span></code></a> or <a class="reference internal" href="#c.NPY_ITER_F_INDEX" title="NPY_ITER_F_INDEX"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_F_INDEX</span></code></a>
flag, 0 otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_RequiresBuffering">
<a class="reference internal" href="dtype.html#c.npy_bool" title="npy_bool">npy_bool</a> <code class="sig-name descname">NpyIter_RequiresBuffering</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_RequiresBuffering" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 1 if the iterator requires buffering, which occurs
when an operand needs conversion or alignment and so cannot
be used directly.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_IsBuffered">
<a class="reference internal" href="dtype.html#c.npy_bool" title="npy_bool">npy_bool</a> <code class="sig-name descname">NpyIter_IsBuffered</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_IsBuffered" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 1 if the iterator was created with the
<a class="reference internal" href="#c.NPY_ITER_BUFFERED" title="NPY_ITER_BUFFERED"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_BUFFERED</span></code></a> flag, 0 otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_IsGrowInner">
<a class="reference internal" href="dtype.html#c.npy_bool" title="npy_bool">npy_bool</a> <code class="sig-name descname">NpyIter_IsGrowInner</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_IsGrowInner" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 1 if the iterator was created with the
<a class="reference internal" href="#c.NPY_ITER_GROWINNER" title="NPY_ITER_GROWINNER"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_GROWINNER</span></code></a> flag, 0 otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_GetBufferSize">
<a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a> <code class="sig-name descname">NpyIter_GetBufferSize</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GetBufferSize" title="Permalink to this definition">¶</a></dt>
<dd><p>If the iterator is buffered, returns the size of the buffer
being used, otherwise returns 0.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_GetNDim">
int <code class="sig-name descname">NpyIter_GetNDim</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GetNDim" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of dimensions being iterated.  If a multi-index
was not requested in the iterator constructor, this value
may be smaller than the number of dimensions in the original
objects.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_GetNOp">
int <code class="sig-name descname">NpyIter_GetNOp</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GetNOp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of operands in the iterator.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_GetAxisStrideArray">
<a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a>* <code class="sig-name descname">NpyIter_GetAxisStrideArray</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em>, int<em> axis</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GetAxisStrideArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the array of strides for the specified axis. Requires that
the iterator be tracking a multi-index, and that buffering not
be enabled.</p>
<p>This may be used when you want to match up operand axes in
some fashion, then remove them with <code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_RemoveAxis</span></code> to
handle their processing manually.  By calling this function
before removing the axes, you can get the strides for the
manual processing.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> on error.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_GetShape">
int <code class="sig-name descname">NpyIter_GetShape</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a>*<em> outshape</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GetShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the broadcast shape of the iterator in <code class="docutils literal notranslate"><span class="pre">outshape</span></code>.
This can only be called on an iterator which is tracking a multi-index.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_GetDescrArray">
<a class="reference internal" href="types-and-structures.html#c.PyArray_Descr" title="PyArray_Descr">PyArray_Descr</a>** <code class="sig-name descname">NpyIter_GetDescrArray</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GetDescrArray" title="Permalink to this definition">¶</a></dt>
<dd><p>This gives back a pointer to the <code class="docutils literal notranslate"><span class="pre">nop</span></code> data type Descrs for
the objects being iterated.  The result points into <code class="docutils literal notranslate"><span class="pre">iter</span></code>,
so the caller does not gain any references to the Descrs.</p>
<p>This pointer may be cached before the iteration loop, calling
<code class="docutils literal notranslate"><span class="pre">iternext</span></code> will not change it.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_GetOperandArray">
<a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.9)">PyObject</a>** <code class="sig-name descname">NpyIter_GetOperandArray</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GetOperandArray" title="Permalink to this definition">¶</a></dt>
<dd><p>This gives back a pointer to the <code class="docutils literal notranslate"><span class="pre">nop</span></code> operand PyObjects
that are being iterated.  The result points into <code class="docutils literal notranslate"><span class="pre">iter</span></code>,
so the caller does not gain any references to the PyObjects.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_GetIterView">
<a class="reference external" href="https://docs.python.org/dev/c-api/structures.html#c.PyObject" title="(in Python v3.9)">PyObject</a>* <code class="sig-name descname">NpyIter_GetIterView</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a><em> i</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GetIterView" title="Permalink to this definition">¶</a></dt>
<dd><p>This gives back a reference to a new ndarray view, which is a view
into the i-th object in the array <a class="reference internal" href="#c.NpyIter_GetOperandArray" title="NpyIter_GetOperandArray"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_GetOperandArray</span></code></a>,
whose dimensions and strides match the internal optimized
iteration pattern.  A C-order iteration of this view is equivalent
to the iterator’s iteration order.</p>
<p>For example, if an iterator was created with a single array as its
input, and it was possible to rearrange all its axes and then
collapse it into a single strided iteration, this would return
a view that is a one-dimensional array.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_GetReadFlags">
void <code class="sig-name descname">NpyIter_GetReadFlags</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em>, char*<em> outreadflags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GetReadFlags" title="Permalink to this definition">¶</a></dt>
<dd><p>Fills <code class="docutils literal notranslate"><span class="pre">nop</span></code> flags. Sets <code class="docutils literal notranslate"><span class="pre">outreadflags[i]</span></code> to 1 if
<code class="docutils literal notranslate"><span class="pre">op[i]</span></code> can be read from, and to 0 if not.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_GetWriteFlags">
void <code class="sig-name descname">NpyIter_GetWriteFlags</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em>, char*<em> outwriteflags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GetWriteFlags" title="Permalink to this definition">¶</a></dt>
<dd><p>Fills <code class="docutils literal notranslate"><span class="pre">nop</span></code> flags. Sets <code class="docutils literal notranslate"><span class="pre">outwriteflags[i]</span></code> to 1 if
<code class="docutils literal notranslate"><span class="pre">op[i]</span></code> can be written to, and to 0 if not.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_CreateCompatibleStrides">
int <code class="sig-name descname">NpyIter_CreateCompatibleStrides</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a><em> itemsize</em>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a>*<em> outstrides</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_CreateCompatibleStrides" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a set of strides which are the same as the strides of an
output array created using the <a class="reference internal" href="#c.NPY_ITER_ALLOCATE" title="NPY_ITER_ALLOCATE"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_ALLOCATE</span></code></a> flag, where NULL
was passed for op_axes.  This is for data packed contiguously,
but not necessarily in C or Fortran order. This should be used
together with <a class="reference internal" href="#c.NpyIter_GetShape" title="NpyIter_GetShape"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_GetShape</span></code></a> and <a class="reference internal" href="#c.NpyIter_GetNDim" title="NpyIter_GetNDim"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_GetNDim</span></code></a>
with the flag <a class="reference internal" href="#c.NPY_ITER_MULTI_INDEX" title="NPY_ITER_MULTI_INDEX"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_MULTI_INDEX</span></code></a> passed into the constructor.</p>
<p>A use case for this function is to match the shape and layout of
the iterator and tack on one or more dimensions.  For example,
in order to generate a vector per input value for a numerical gradient,
you pass in ndim*itemsize for itemsize, then add another dimension to
the end with size ndim and stride itemsize.  To do the Hessian matrix,
you do the same thing but add two dimensions, or take advantage of
the symmetry and pack it into 1 dimension with a particular encoding.</p>
<p>This function may only be called if the iterator is tracking a multi-index
and if <a class="reference internal" href="#c.NPY_ITER_DONT_NEGATE_STRIDES" title="NPY_ITER_DONT_NEGATE_STRIDES"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_DONT_NEGATE_STRIDES</span></code></a> was used to prevent an axis
from being iterated in reverse order.</p>
<p>If an array is created with this method, simply adding ‘itemsize’
for each iteration will traverse the new array matching the
iterator.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NPY_SUCCEED</span></code> or <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_IsFirstVisit">
<a class="reference internal" href="dtype.html#c.npy_bool" title="npy_bool">npy_bool</a> <code class="sig-name descname">NpyIter_IsFirstVisit</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em>, int<em> iop</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_IsFirstVisit" title="Permalink to this definition">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.</span></p>
</div>
<p>Checks to see whether this is the first time the elements of the
specified reduction operand which the iterator points at are being
seen for the first time. The function returns a reasonable answer
for reduction operands and when buffering is disabled. The answer
may be incorrect for buffered non-reduction operands.</p>
<p>This function is intended to be used in EXTERNAL_LOOP mode only,
and will produce some wrong answers when that mode is not enabled.</p>
<p>If this function returns true, the caller should also check the inner
loop stride of the operand, because if that stride is 0, then only
the first element of the innermost external loop is being visited
for the first time.</p>
<p><em>WARNING</em>: For performance reasons, ‘iop’ is not bounds-checked,
it is not confirmed that ‘iop’ is actually a reduction operand,
and it is not confirmed that EXTERNAL_LOOP mode is enabled. These
checks are the responsibility of the caller, and should be done
outside of any inner loops.</p>
</dd></dl>

</div>
<div class="section" id="functions-for-iteration">
<h2>Functions For Iteration<a class="headerlink" href="#functions-for-iteration" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="c.NpyIter_GetIterNext">
<a class="reference internal" href="#c.NpyIter_IterNextFunc" title="NpyIter_IterNextFunc">NpyIter_IterNextFunc</a>* <code class="sig-name descname">NpyIter_GetIterNext</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em>, char**<em> errmsg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GetIterNext" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a function pointer for iteration.  A specialized version
of the function pointer may be calculated by this function
instead of being stored in the iterator structure. Thus, to
get good performance, it is required that the function pointer
be saved in a variable rather than retrieved for each loop iteration.</p>
<p>Returns NULL if there is an error.  If errmsg is non-NULL,
no Python exception is set when <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code> is returned.
Instead, *errmsg is set to an error message.  When errmsg is
non-NULL, the function may be safely called without holding
the Python GIL.</p>
<p>The typical looping construct is as follows.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">NpyIter_IterNextFunc</span> <span class="o">*</span><span class="n">iternext</span> <span class="o">=</span> <span class="n">NpyIter_GetIterNext</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="kt">char</span><span class="o">**</span> <span class="n">dataptr</span> <span class="o">=</span> <span class="n">NpyIter_GetDataPtrArray</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

<span class="k">do</span> <span class="p">{</span>
    <span class="cm">/* use the addresses dataptr[0], ... dataptr[nop-1] */</span>
<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">iternext</span><span class="p">(</span><span class="n">iter</span><span class="p">));</span>
</pre></div>
</div>
<p>When <a class="reference internal" href="#c.NPY_ITER_EXTERNAL_LOOP" title="NPY_ITER_EXTERNAL_LOOP"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_EXTERNAL_LOOP</span></code></a> is specified, the typical
inner loop construct is as follows.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">NpyIter_IterNextFunc</span> <span class="o">*</span><span class="n">iternext</span> <span class="o">=</span> <span class="n">NpyIter_GetIterNext</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="kt">char</span><span class="o">**</span> <span class="n">dataptr</span> <span class="o">=</span> <span class="n">NpyIter_GetDataPtrArray</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="n">npy_intp</span><span class="o">*</span> <span class="n">stride</span> <span class="o">=</span> <span class="n">NpyIter_GetInnerStrideArray</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="n">npy_intp</span><span class="o">*</span> <span class="n">size_ptr</span> <span class="o">=</span> <span class="n">NpyIter_GetInnerLoopSizePtr</span><span class="p">(</span><span class="n">iter</span><span class="p">),</span> <span class="n">size</span><span class="p">;</span>
<span class="n">npy_intp</span> <span class="n">iop</span><span class="p">,</span> <span class="n">nop</span> <span class="o">=</span> <span class="n">NpyIter_GetNOp</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

<span class="k">do</span> <span class="p">{</span>
    <span class="n">size</span> <span class="o">=</span> <span class="o">*</span><span class="n">size_ptr</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">size</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* use the addresses dataptr[0], ... dataptr[nop-1] */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">iop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iop</span> <span class="o">&lt;</span> <span class="n">nop</span><span class="p">;</span> <span class="o">++</span><span class="n">iop</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dataptr</span><span class="p">[</span><span class="n">iop</span><span class="p">]</span> <span class="o">+=</span> <span class="n">stride</span><span class="p">[</span><span class="n">iop</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">iternext</span><span class="p">());</span>
</pre></div>
</div>
<p>Observe that we are using the dataptr array inside the iterator, not
copying the values to a local temporary.  This is possible because
when <code class="docutils literal notranslate"><span class="pre">iternext()</span></code> is called, these pointers will be overwritten
with fresh values, not incrementally updated.</p>
<p>If a compile-time fixed buffer is being used (both flags
<a class="reference internal" href="#c.NPY_ITER_BUFFERED" title="NPY_ITER_BUFFERED"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_BUFFERED</span></code></a> and <a class="reference internal" href="#c.NPY_ITER_EXTERNAL_LOOP" title="NPY_ITER_EXTERNAL_LOOP"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_EXTERNAL_LOOP</span></code></a>), the
inner size may be used as a signal as well.  The size is guaranteed
to become zero when <code class="docutils literal notranslate"><span class="pre">iternext()</span></code> returns false, enabling the
following loop construct.  Note that if you use this construct,
you should not pass <a class="reference internal" href="#c.NPY_ITER_GROWINNER" title="NPY_ITER_GROWINNER"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_GROWINNER</span></code></a> as a flag, because it
will cause larger sizes under some circumstances.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* The constructor should have buffersize passed as this value */</span>
<span class="cp">#define FIXED_BUFFER_SIZE 1024</span>

<span class="n">NpyIter_IterNextFunc</span> <span class="o">*</span><span class="n">iternext</span> <span class="o">=</span> <span class="n">NpyIter_GetIterNext</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">**</span><span class="n">dataptr</span> <span class="o">=</span> <span class="n">NpyIter_GetDataPtrArray</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="n">npy_intp</span> <span class="o">*</span><span class="n">stride</span> <span class="o">=</span> <span class="n">NpyIter_GetInnerStrideArray</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="n">npy_intp</span> <span class="o">*</span><span class="n">size_ptr</span> <span class="o">=</span> <span class="n">NpyIter_GetInnerLoopSizePtr</span><span class="p">(</span><span class="n">iter</span><span class="p">),</span> <span class="n">size</span><span class="p">;</span>
<span class="n">npy_intp</span> <span class="n">i</span><span class="p">,</span> <span class="n">iop</span><span class="p">,</span> <span class="n">nop</span> <span class="o">=</span> <span class="n">NpyIter_GetNOp</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>

<span class="cm">/* One loop with a fixed inner size */</span>
<span class="n">size</span> <span class="o">=</span> <span class="o">*</span><span class="n">size_ptr</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="n">FIXED_BUFFER_SIZE</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/*</span>
<span class="cm">     * This loop could be manually unrolled by a factor</span>
<span class="cm">     * which divides into FIXED_BUFFER_SIZE</span>
<span class="cm">     */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FIXED_BUFFER_SIZE</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* use the addresses dataptr[0], ... dataptr[nop-1] */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">iop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iop</span> <span class="o">&lt;</span> <span class="n">nop</span><span class="p">;</span> <span class="o">++</span><span class="n">iop</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dataptr</span><span class="p">[</span><span class="n">iop</span><span class="p">]</span> <span class="o">+=</span> <span class="n">stride</span><span class="p">[</span><span class="n">iop</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">iternext</span><span class="p">();</span>
    <span class="n">size</span> <span class="o">=</span> <span class="o">*</span><span class="n">size_ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Finish-up loop with variable inner size */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">do</span> <span class="p">{</span>
    <span class="n">size</span> <span class="o">=</span> <span class="o">*</span><span class="n">size_ptr</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">size</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* use the addresses dataptr[0], ... dataptr[nop-1] */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">iop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iop</span> <span class="o">&lt;</span> <span class="n">nop</span><span class="p">;</span> <span class="o">++</span><span class="n">iop</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dataptr</span><span class="p">[</span><span class="n">iop</span><span class="p">]</span> <span class="o">+=</span> <span class="n">stride</span><span class="p">[</span><span class="n">iop</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">iternext</span><span class="p">());</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_GetGetMultiIndex">
<a class="reference internal" href="#c.NpyIter_GetMultiIndexFunc" title="NpyIter_GetMultiIndexFunc">NpyIter_GetMultiIndexFunc</a> *<code class="sig-name descname">NpyIter_GetGetMultiIndex</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em>, char**<em> errmsg</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GetGetMultiIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a function pointer for getting the current multi-index
of the iterator.  Returns NULL if the iterator is not tracking
a multi-index.  It is recommended that this function
pointer be cached in a local variable before the iteration
loop.</p>
<p>Returns NULL if there is an error.  If errmsg is non-NULL,
no Python exception is set when <code class="docutils literal notranslate"><span class="pre">NPY_FAIL</span></code> is returned.
Instead, *errmsg is set to an error message.  When errmsg is
non-NULL, the function may be safely called without holding
the Python GIL.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_GetDataPtrArray">
char** <code class="sig-name descname">NpyIter_GetDataPtrArray</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GetDataPtrArray" title="Permalink to this definition">¶</a></dt>
<dd><p>This gives back a pointer to the <code class="docutils literal notranslate"><span class="pre">nop</span></code> data pointers.  If
<a class="reference internal" href="#c.NPY_ITER_EXTERNAL_LOOP" title="NPY_ITER_EXTERNAL_LOOP"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_EXTERNAL_LOOP</span></code></a> was not specified, each data
pointer points to the current data item of the iterator.  If
no inner iteration was specified, it points to the first data
item of the inner loop.</p>
<p>This pointer may be cached before the iteration loop, calling
<code class="docutils literal notranslate"><span class="pre">iternext</span></code> will not change it.  This function may be safely
called without holding the Python GIL.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_GetInitialDataPtrArray">
char** <code class="sig-name descname">NpyIter_GetInitialDataPtrArray</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GetInitialDataPtrArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the array of data pointers directly into the arrays (never
into the buffers), corresponding to iteration index 0.</p>
<p>These pointers are different from the pointers accepted by
<code class="docutils literal notranslate"><span class="pre">NpyIter_ResetBasePointers</span></code>, because the direction along
some axes may have been reversed.</p>
<p>This function may be safely called without holding the Python GIL.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_GetIndexPtr">
<a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a>* <code class="sig-name descname">NpyIter_GetIndexPtr</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GetIndexPtr" title="Permalink to this definition">¶</a></dt>
<dd><p>This gives back a pointer to the index being tracked, or NULL
if no index is being tracked.  It is only useable if one of
the flags <a class="reference internal" href="#c.NPY_ITER_C_INDEX" title="NPY_ITER_C_INDEX"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_C_INDEX</span></code></a> or <a class="reference internal" href="#c.NPY_ITER_F_INDEX" title="NPY_ITER_F_INDEX"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_F_INDEX</span></code></a>
were specified during construction.</p>
</dd></dl>

<p>When the flag <a class="reference internal" href="#c.NPY_ITER_EXTERNAL_LOOP" title="NPY_ITER_EXTERNAL_LOOP"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_EXTERNAL_LOOP</span></code></a> is used, the code
needs to know the parameters for doing the inner loop.  These
functions provide that information.</p>
<dl class="function">
<dt id="c.NpyIter_GetInnerStrideArray">
<a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a>* <code class="sig-name descname">NpyIter_GetInnerStrideArray</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GetInnerStrideArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pointer to an array of the <code class="docutils literal notranslate"><span class="pre">nop</span></code> strides,
one for each iterated object, to be used by the inner loop.</p>
<p>This pointer may be cached before the iteration loop, calling
<code class="docutils literal notranslate"><span class="pre">iternext</span></code> will not change it. This function may be safely
called without holding the Python GIL.</p>
<p><strong>WARNING</strong>: While the pointer may be cached, its values may
change if the iterator is buffered.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_GetInnerLoopSizePtr">
<a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a>* <code class="sig-name descname">NpyIter_GetInnerLoopSizePtr</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GetInnerLoopSizePtr" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a pointer to the number of iterations the
inner loop should execute.</p>
<p>This address may be cached before the iteration loop, calling
<code class="docutils literal notranslate"><span class="pre">iternext</span></code> will not change it.  The value itself may change during
iteration, in particular if buffering is enabled.  This function
may be safely called without holding the Python GIL.</p>
</dd></dl>

<dl class="function">
<dt id="c.NpyIter_GetInnerFixedStrideArray">
void <code class="sig-name descname">NpyIter_GetInnerFixedStrideArray</code><span class="sig-paren">(</span><a class="reference internal" href="#c.NpyIter" title="NpyIter">NpyIter</a>*<em> iter</em>, <a class="reference internal" href="dtype.html#c.npy_intp" title="npy_intp">npy_intp</a>*<em> out_strides</em><span class="sig-paren">)</span><a class="headerlink" href="#c.NpyIter_GetInnerFixedStrideArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets an array of strides which are fixed, or will not change during
the entire iteration.  For strides that may change, the value
NPY_MAX_INTP is placed in the stride.</p>
<p>Once the iterator is prepared for iteration (after a reset if
<code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_DELAY_BUFALLOC</span></code> was used), call this to get the strides
which may be used to select a fast inner loop function.  For example,
if the stride is 0, that means the inner loop can always load its
value into a variable once, then use the variable throughout the loop,
or if the stride equals the itemsize, a contiguous version for that
operand may be used.</p>
<p>This function may be safely called without holding the Python GIL.</p>
</dd></dl>

</div>
<div class="section" id="converting-from-previous-numpy-iterators">
<span id="index-1"></span><h2>Converting from Previous NumPy Iterators<a class="headerlink" href="#converting-from-previous-numpy-iterators" title="Permalink to this headline">¶</a></h2>
<p>The old iterator API includes functions like PyArrayIter_Check,
PyArray_Iter* and PyArray_ITER_*.  The multi-iterator array includes
PyArray_MultiIter*, PyArray_Broadcast, and PyArray_RemoveSmallest.  The
new iterator design replaces all of this functionality with a single object
and associated API.  One goal of the new API is that all uses of the
existing iterator should be replaceable with the new iterator without
significant effort. In 1.6, the major exception to this is the neighborhood
iterator, which does not have corresponding features in this iterator.</p>
<p>Here is a conversion table for which functions to use with the new iterator:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 42%" />
<col style="width: 58%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><em>Iterator Functions</em></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="array.html#c.PyArray_IterNew" title="PyArray_IterNew"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_IterNew</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.NpyIter_New" title="NpyIter_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_New</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="array.html#c.PyArray_IterAllButAxis" title="PyArray_IterAllButAxis"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_IterAllButAxis</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.NpyIter_New" title="NpyIter_New"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_New</span></code></a> + <code class="docutils literal notranslate"><span class="pre">axes</span></code> parameter <strong>or</strong>
Iterator flag <a class="reference internal" href="#c.NPY_ITER_EXTERNAL_LOOP" title="NPY_ITER_EXTERNAL_LOOP"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_EXTERNAL_LOOP</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="array.html#c.PyArray_BroadcastToShape" title="PyArray_BroadcastToShape"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_BroadcastToShape</span></code></a></p></td>
<td><p><strong>NOT SUPPORTED</strong> (Use the support for
multiple operands instead.)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="array.html#c.PyArrayIter_Check" title="PyArrayIter_Check"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArrayIter_Check</span></code></a></p></td>
<td><p>Will need to add this in Python exposure</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="array.html#c.PyArray_ITER_RESET" title="PyArray_ITER_RESET"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_ITER_RESET</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.NpyIter_Reset" title="NpyIter_Reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_Reset</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="array.html#c.PyArray_ITER_NEXT" title="PyArray_ITER_NEXT"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_ITER_NEXT</span></code></a></p></td>
<td><p>Function pointer from <a class="reference internal" href="#c.NpyIter_GetIterNext" title="NpyIter_GetIterNext"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_GetIterNext</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="array.html#c.PyArray_ITER_DATA" title="PyArray_ITER_DATA"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_ITER_DATA</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.NpyIter_GetDataPtrArray" title="NpyIter_GetDataPtrArray"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_GetDataPtrArray</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="array.html#c.PyArray_ITER_GOTO" title="PyArray_ITER_GOTO"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_ITER_GOTO</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.NpyIter_GotoMultiIndex" title="NpyIter_GotoMultiIndex"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_GotoMultiIndex</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="array.html#c.PyArray_ITER_GOTO1D" title="PyArray_ITER_GOTO1D"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_ITER_GOTO1D</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.NpyIter_GotoIndex" title="NpyIter_GotoIndex"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_GotoIndex</span></code></a> or
<a class="reference internal" href="#c.NpyIter_GotoIterIndex" title="NpyIter_GotoIterIndex"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_GotoIterIndex</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="array.html#c.PyArray_ITER_NOTDONE" title="PyArray_ITER_NOTDONE"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_ITER_NOTDONE</span></code></a></p></td>
<td><p>Return value of <code class="docutils literal notranslate"><span class="pre">iternext</span></code> function pointer</p></td>
</tr>
<tr class="row-even"><td><p><em>Multi-iterator Functions</em></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="array.html#c.PyArray_MultiIterNew" title="PyArray_MultiIterNew"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_MultiIterNew</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.NpyIter_MultiNew" title="NpyIter_MultiNew"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_MultiNew</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="array.html#c.PyArray_MultiIter_RESET" title="PyArray_MultiIter_RESET"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_MultiIter_RESET</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.NpyIter_Reset" title="NpyIter_Reset"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_Reset</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="array.html#c.PyArray_MultiIter_NEXT" title="PyArray_MultiIter_NEXT"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_MultiIter_NEXT</span></code></a></p></td>
<td><p>Function pointer from <a class="reference internal" href="#c.NpyIter_GetIterNext" title="NpyIter_GetIterNext"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_GetIterNext</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="array.html#c.PyArray_MultiIter_DATA" title="PyArray_MultiIter_DATA"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_MultiIter_DATA</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.NpyIter_GetDataPtrArray" title="NpyIter_GetDataPtrArray"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_GetDataPtrArray</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="array.html#c.PyArray_MultiIter_NEXTi" title="PyArray_MultiIter_NEXTi"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_MultiIter_NEXTi</span></code></a></p></td>
<td><p><strong>NOT SUPPORTED</strong> (always lock-step iteration)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="array.html#c.PyArray_MultiIter_GOTO" title="PyArray_MultiIter_GOTO"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_MultiIter_GOTO</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.NpyIter_GotoMultiIndex" title="NpyIter_GotoMultiIndex"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_GotoMultiIndex</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="array.html#c.PyArray_MultiIter_GOTO1D" title="PyArray_MultiIter_GOTO1D"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_MultiIter_GOTO1D</span></code></a></p></td>
<td><p><a class="reference internal" href="#c.NpyIter_GotoIndex" title="NpyIter_GotoIndex"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_GotoIndex</span></code></a> or
<a class="reference internal" href="#c.NpyIter_GotoIterIndex" title="NpyIter_GotoIterIndex"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_GotoIterIndex</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="array.html#c.PyArray_MultiIter_NOTDONE" title="PyArray_MultiIter_NOTDONE"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_MultiIter_NOTDONE</span></code></a></p></td>
<td><p>Return value of <code class="docutils literal notranslate"><span class="pre">iternext</span></code> function pointer</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="array.html#c.PyArray_Broadcast" title="PyArray_Broadcast"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_Broadcast</span></code></a></p></td>
<td><p>Handled by <a class="reference internal" href="#c.NpyIter_MultiNew" title="NpyIter_MultiNew"><code class="xref c c-func docutils literal notranslate"><span class="pre">NpyIter_MultiNew</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="array.html#c.PyArray_RemoveSmallest" title="PyArray_RemoveSmallest"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_RemoveSmallest</span></code></a></p></td>
<td><p>Iterator flag <a class="reference internal" href="#c.NPY_ITER_EXTERNAL_LOOP" title="NPY_ITER_EXTERNAL_LOOP"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_EXTERNAL_LOOP</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><em>Other Functions</em></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="array.html#c.PyArray_ConvertToCommonType" title="PyArray_ConvertToCommonType"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyArray_ConvertToCommonType</span></code></a></p></td>
<td><p>Iterator flag <a class="reference internal" href="#c.NPY_ITER_COMMON_DTYPE" title="NPY_ITER_COMMON_DTYPE"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ITER_COMMON_DTYPE</span></code></a></p></td>
</tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2008-2019, The SciPy community.
      </li>
      <li>
      Last updated on Feb 20, 2020.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 2.4.2.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>