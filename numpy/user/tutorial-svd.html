<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>Tutorial: Linear algebra on n-dimensional arrays &mdash; NumPy v1.19 Manual</title>
    
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" >
    <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.19.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/js/copybutton.js"></script>
    <link rel="author" title="About these documents" href="../about.html" >
    <link rel="index" title="Index" href="../genindex.html" >
    <link rel="search" title="Search" href="../search.html" >
    <link rel="top" title="NumPy v1.19 Manual" href="../index.html" >
    <link rel="up" title="NumPy Tutorials" href="tutorials_index.html" >
    <link rel="next" title="Building from source" href="building.html" >
    <link rel="prev" title="NumPy for Matlab users" href="numpy-for-matlab-users.html" > 
  </head>
  <body>
<div class="container">
  <div class="top-scipy-org-logo-header" style="background-color: #a2bae8;">
    <a href="../index.html">
      <img border=0 alt="NumPy" src="../_static/numpy_logo.png"></a>
    </div>
  </div>
</div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        <li class="active"><a href="https://numpy.org/">NumPy.org</a></li>
        <li class="active"><a href="https://numpy.org/doc">Docs</a></li>
        
        <li class="active"><a href="../index.html">NumPy v1.19 Manual</a></li>
        

          <li class="active"><a href="tutorials_index.html" accesskey="U">NumPy Tutorials</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="building.html" title="Building from source"
           accesskey="N">next</a>
      </li>
      <li class="active">
        <a href="numpy-for-matlab-users.html" title="NumPy for Matlab users"
           accesskey="P">previous</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="numpy-for-matlab-users.html"
                        title="previous chapter">NumPy for Matlab users</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="building.html"
                        title="next chapter">Building from source</a></p>
<div id="searchbox" style="display: none" role="search">
  <h4>Quick search</h4>
    <div>
    <form class="search" action="../search.html" method="get">
      <input type="text" style="width: inherit;" name="q" />
      <input type="submit" value="search" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <div class="section" id="tutorial-linear-algebra-on-n-dimensional-arrays">
<h1>Tutorial: Linear algebra on n-dimensional arrays<a class="headerlink" href="#tutorial-linear-algebra-on-n-dimensional-arrays" title="Permalink to this headline">¶</a></h1>
<p><strong>Prerequisites</strong></p>
<p>Before reading this tutorial, you should know a bit of Python. If you
would like to refresh your memory, take a look at the
<a class="reference external" href="https://docs.python.org/dev/tutorial/index.html" title="(in Python v3.10)"><span class="xref std std-doc">Python tutorial</span></a>.</p>
<p>If you want to be able to run the examples in this tutorial, you should also
have <a class="reference external" href="https://matplotlib.org/">matplotlib</a> and <a class="reference external" href="https://scipy.org">SciPy</a>
installed on your computer.</p>
<p><strong>Learner profile</strong></p>
<p>This tutorial is for people who have a basic understanding of linear
algebra and arrays in NumPy and want to understand how n-dimensional
(<img class="math" src="../_images/math/564832a4a96fb2df2472a768cc8c8a65879ac89b.svg" alt="n&gt;=2"/>) arrays are represented and can be manipulated. In particular, if
you don’t know how to apply common functions to n-dimensional arrays (without
using for-loops), or if you want to understand axis and shape properties for
n-dimensional arrays, this tutorial might be of help.</p>
<p><strong>Learning Objectives</strong></p>
<p>After this tutorial, you should be able to:</p>
<ul class="simple">
<li><p>Understand the difference between one-, two- and n-dimensional arrays in
NumPy;</p></li>
<li><p>Understand how to apply some linear algebra operations to n-dimensional
arrays without using for-loops;</p></li>
<li><p>Understand axis and shape properties for n-dimensional arrays.</p></li>
</ul>
<p><strong>Content</strong></p>
<p>In this tutorial, we will use a <a class="reference external" href="https://en.wikipedia.org/wiki/Matrix_decomposition">matrix decomposition</a> from linear algebra, the
Singular Value Decomposition, to generate a compressed approximation of an
image. We’ll use the <code class="docutils literal notranslate"><span class="pre">face</span></code> image from the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/misc.html#module-scipy.misc" title="(in SciPy v1.5.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.misc</span></code></a> module:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">misc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">misc</span><span class="o">.</span><span class="n">face</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you prefer, you can use your own image as you work through this tutorial.
In order to transform your image into a NumPy array that can be manipulated,
you can use the <code class="docutils literal notranslate"><span class="pre">imread</span></code> function from the <a class="reference external" href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.html#module-matplotlib.pyplot" title="(in Matplotlib v3.2.2)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matplotlib.pyplot</span></code></a> submodule.
Alternatively, you can use the <a class="reference external" href="https://imageio.readthedocs.io/en/stable/userapi.html#imageio.imread" title="(in imageio v2.8)"><code class="xref py py-func docutils literal notranslate"><span class="pre">imageio.imread</span></code></a> function from the
<code class="docutils literal notranslate"><span class="pre">imageio</span></code> library. Be aware that if you use your own image, you’ll likely
need to adapt the steps below. For more information on how images are treated
when converted to NumPy arrays, see <a class="reference external" href="https://scikit-image.org/docs/stable/user_guide/numpy_images.html" title="(in skimage v0.17.2)"><span>A crash course on NumPy for images</span></a> from
the <code class="docutils literal notranslate"><span class="pre">scikit-image</span></code> documentation.</p>
</div>
<p>Now, <code class="docutils literal notranslate"><span class="pre">img</span></code> is a NumPy array, as we can see when using the <code class="docutils literal notranslate"><span class="pre">type</span></code> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="go">&lt;class &#39;numpy.ndarray&#39;&gt;</span>
</pre></div>
</div>
<p>We can see the image using the <a class="reference external" href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.imshow.html#matplotlib.pyplot.imshow" title="(in Matplotlib v3.2.2)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matplotlib.pyplot.imshow</span></code></a> function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure align-center">
<img alt="../_images/plot_face.png" src="../_images/plot_face.png" />
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you are executing the commands above in the IPython shell, it might be
necessary to use the command <code class="docutils literal notranslate"><span class="pre">plt.show()</span></code> to show the image window.</p>
</div>
<p><strong>Shape, axis and array properties</strong></p>
<p>Note that, in linear algebra, the dimension of a vector refers to the number of
entries in an array. In NumPy, it instead defines the number of axes. For
example, a 1D array is a vector such as <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code>, a 2D array is a matrix,
and so forth.</p>
<p>First, let’s check for the shape of the data in our array. Since this image is
two-dimensional (the pixels in the image form a rectangle), we might expect a
two-dimensional array to represent it (a matrix). However, using the <code class="docutils literal notranslate"><span class="pre">shape</span></code>
property of this NumPy array gives us a different result:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(768, 1024, 3)</span>
</pre></div>
</div>
<p>The output is a <a class="reference external" href="https://docs.python.org/dev/tutorial/datastructures.html#tut-tuples" title="(in Python v3.10)"><span class="xref std std-ref">tuple</span></a> with three elements, which means
that this is a three-dimensional array. In fact, since this is a color image, and
we have used the <code class="docutils literal notranslate"><span class="pre">imread</span></code> function to read it, the data is organized in three 2D
arrays, representing color channels (in this case, red, green and blue - RGB). You
can see this by looking at the shape above: it indicates that we have an array of
3 matrices, each having shape 768x1024.</p>
<p>Furthermore, using the <code class="docutils literal notranslate"><span class="pre">ndim</span></code> property of this array, we can see that</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span>
<span class="go">3</span>
</pre></div>
</div>
<p>NumPy refers to each dimension as an <em class="xref py py-obj">axis</em>. Because of how <code class="docutils literal notranslate"><span class="pre">imread</span></code>
works, the <em>first index in the 3rd axis</em> is the red pixel data for our image. We
can access this by using the syntax</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([[121, 138, 153, ..., 119, 131, 139],</span>
<span class="go">       [ 89, 110, 130, ..., 118, 134, 146],</span>
<span class="go">       [ 73,  94, 115, ..., 117, 133, 144],</span>
<span class="go">       ...,</span>
<span class="go">       [ 87,  94, 107, ..., 120, 119, 119],</span>
<span class="go">       [ 85,  95, 112, ..., 121, 120, 120],</span>
<span class="go">       [ 85,  97, 111, ..., 120, 119, 118]], dtype=uint8)</span>
</pre></div>
</div>
<p>From the output above, we can see that every value in <code class="docutils literal notranslate"><span class="pre">img[:,:,0]</span></code> is an
integer value between 0 and 255, representing the level of red in each
corresponding image pixel (keep in mind that this might be different if you
use your own image instead of <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.face.html#scipy.misc.face" title="(in SciPy v1.5.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.misc.face</span></code></a>).</p>
<p>As expected, this is a 768x1024 matrix:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(768, 1024)</span>
</pre></div>
</div>
<p>Since we are going to perform linear algebra operations on this data, it might
be more interesting to have real numbers between 0 and 1 in each entry of the
matrices to represent the RGB values. We can do that by setting</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img_array</span> <span class="o">=</span> <span class="n">img</span> <span class="o">/</span> <span class="mi">255</span>
</pre></div>
</div>
<p>This operation, dividing an array by a scalar, works because of NumPy’s
<a class="reference internal" href="theory.broadcasting.html#array-broadcasting-in-numpy"><span class="std std-ref">broadcasting rules</span></a>). (Note that in
real-world applications, it would be better to use, for example, the
<a class="reference external" href="https://scikit-image.org/docs/stable/api/skimage.html#skimage.img_as_float" title="(in skimage v0.17.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">img_as_float</span></code></a> utility function from
<code class="docutils literal notranslate"><span class="pre">scikit-image</span></code>).</p>
<p>You can check that the above works by doing some tests; for example, inquiring
about maximum and minimum values for this array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img_array</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">img_array</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="go">(1.0, 0.0)</span>
</pre></div>
</div>
<p>or checking the type of data in the array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img_array</span><span class="o">.</span><span class="n">dtype</span>
<span class="go">dtype(&#39;float64&#39;)</span>
</pre></div>
</div>
<p>Note that we can assign each color channel to a separate matrix using the slice
syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">red_array</span> <span class="o">=</span> <span class="n">img_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">green_array</span> <span class="o">=</span> <span class="n">img_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blue_array</span> <span class="o">=</span> <span class="n">img_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p><strong>Operations on an axis</strong></p>
<p>It is possible to use methods from linear algebra to approximate an existing set
of data. Here, we will use the <a class="reference external" href="https://en.wikipedia.org/wiki/Singular_value_decomposition">SVD (Singular Value Decomposition)</a> to try to rebuild
an image that uses less singular value information than the original one, while
still retaining some of its features.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We will use NumPy’s linear algebra module, <a class="reference internal" href="../reference/routines.linalg.html#module-numpy.linalg" title="numpy.linalg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.linalg</span></code></a>, to
perform the operations in this tutorial. Most of the linear algebra
functions in this module can also be found in <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg" title="(in SciPy v1.5.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg</span></code></a>, and
users are encouraged to use the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/index.html#module-scipy" title="(in SciPy v1.5.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy</span></code></a> module for real-world
applications. However, it is currently not possible to apply linear
algebra operations to n-dimensional arrays using the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg" title="(in SciPy v1.5.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg</span></code></a>
module. For more information on this, check the
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/tutorial/linalg.html" title="(in SciPy v1.5.0)"><span class="xref std std-doc">scipy.linalg Reference</span></a>.</p>
</div>
<p>To proceed, import the linear algebra submodule from NumPy:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linalg</span>
</pre></div>
</div>
<p>In order to extract information from a given matrix, we can use the SVD to obtain
3 arrays which can be multiplied to obtain the original matrix. From the theory
of linear algebra, given a matrix <img class="math" src="../_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.svg" alt="A"/>, the following product can be
computed:</p>
<div class="math">
<p><img src="../_images/math/105a43c599f4e87dae287fc7e52e9f7f864834c9.svg" alt="U \Sigma V^T = A"/></p>
</div><p>where <img class="math" src="../_images/math/9098c1c4618d7a0f321cee441aabee7f1b57a19b.svg" alt="U"/> and <img class="math" src="../_images/math/87bf9fc412cc4fdc23af6f48bda75f7a9ebcb38d.svg" alt="V^T"/> are square and <img class="math" src="../_images/math/6edc5c119344e25a06e6ac4cb56f2d5e2f09a2f1.svg" alt="\Sigma"/> is the same size
as <img class="math" src="../_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.svg" alt="A"/>. <img class="math" src="../_images/math/6edc5c119344e25a06e6ac4cb56f2d5e2f09a2f1.svg" alt="\Sigma"/> is a diagonal matrix and contains the
<a class="reference external" href="https://en.wikipedia.org/wiki/Singular_value">singular values</a> of <img class="math" src="../_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.svg" alt="A"/>,
organized from largest to smallest. These values are always non-negative and can
be used as an indicator of the “importance” of some features represented by the
matrix <img class="math" src="../_images/math/211284f68205c3e66773eaf026f32a0acdd3dfb3.svg" alt="A"/>.</p>
<p>Let’s see how this works in practice with just one matrix first. Note that
according to <a class="reference external" href="https://en.wikipedia.org/wiki/Grayscale#Colorimetric_(perceptual_luminance-preserving)_conversion_to_grayscale">colorimetry</a>,
it is possible to obtain a fairly reasonable grayscale version of our color
image if we apply the formula</p>
<div class="math">
<p><img src="../_images/math/f1d583c2e0667cb47bc97d11e133270413c87ef5.svg" alt="Y = 0.2126 R + 0.7152 G + 0.0722 B"/></p>
</div><p>where <img class="math" src="../_images/math/7daf0d4815e763eb90f0d5f1dc406f668c1e21db.svg" alt="Y"/> is the array representing the grayscale image, and <img class="math" src="../_images/math/6725b463413ea577107d931ef09aac9c97bfeaac.svg" alt="R, G"/>
and <img class="math" src="../_images/math/4bc3e94a67870b41b7c20179693e889251e2c136.svg" alt="B"/> are the red, green and blue channel arrays we had originally.
Notice we can use the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> operator (the matrix multiplication operator for
NumPy arrays, see <a class="reference internal" href="../reference/generated/numpy.matmul.html#numpy.matmul" title="numpy.matmul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.matmul</span></code></a>) for this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img_gray</span> <span class="o">=</span> <span class="n">img_array</span> <span class="o">@</span> <span class="p">[</span><span class="mf">0.2126</span><span class="p">,</span> <span class="mf">0.7152</span><span class="p">,</span> <span class="mf">0.0722</span><span class="p">]</span>
</pre></div>
</div>
<p>Now, <code class="docutils literal notranslate"><span class="pre">img_gray</span></code> has shape</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img_gray</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(768, 1024)</span>
</pre></div>
</div>
<p>To see if this makes sense in our image, we should use a colormap from
<code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> corresponding to the color we wish to see in out image
(otherwise, <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> will default to a colormap that does not
correspond to the real data).</p>
<p>In our case, we are approximating the grayscale portion of the image, so we
will use the colormap <code class="docutils literal notranslate"><span class="pre">gray</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img_gray</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure align-center">
<img alt="../_images/plot_gray.png" src="../_images/plot_gray.png" />
</div>
<p>Now, applying the <a class="reference internal" href="../reference/generated/numpy.linalg.svd.html#numpy.linalg.svd" title="numpy.linalg.svd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg.svd</span></code></a> function to this matrix, we obtain the
following decomposition:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">Vt</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">img_gray</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you are using your own image, this command might take a while to run,
depending on the size of your image and your hardware. Don’t worry, this
is normal! The SVD can be a pretty intensive computation.</p>
</div>
<p>Let’s check that this is what we expected:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">Vt</span><span class="o">.</span><span class="n">shape</span>
<span class="go">((768, 768), (768,), (1024, 1024))</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">s</span></code> has a particular shape: it has only one dimension. This
means that some linear algebra functions that expect 2d arrays might not work.
For example, from the theory, one might expect <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">Vt</span></code> to be
compatible for multiplication. However, this is not true as <code class="docutils literal notranslate"><span class="pre">s</span></code> does not
have a second axis. Executing</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">@</span> <span class="n">Vt</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">matmul: Input operand 1 has a mismatch in its core dimension 0,</span>
<span class="go">with gufunc signature (n?,k),(k,m?)-&gt;(n?,m?) (size 1024 is different from</span>
<span class="go">768)</span>
</pre></div>
</div>
<p>results in a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>. This happens because having a one-dimensional
array for <code class="docutils literal notranslate"><span class="pre">s</span></code>, in this case, is much more economic in practice than building a
diagonal matrix with the same data. To reconstruct the original matrix, we can
rebuild the diagonal matrix <img class="math" src="../_images/math/6edc5c119344e25a06e6ac4cb56f2d5e2f09a2f1.svg" alt="\Sigma"/> with the elements of <code class="docutils literal notranslate"><span class="pre">s</span></code> in its
diagonal and with the appropriate dimensions for multiplying: in our case,
<img class="math" src="../_images/math/6edc5c119344e25a06e6ac4cb56f2d5e2f09a2f1.svg" alt="\Sigma"/> should be 768x1024 since <code class="docutils literal notranslate"><span class="pre">U</span></code> is 768x768 and <code class="docutils literal notranslate"><span class="pre">Vt</span></code> is
1024x1024.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">768</span><span class="p">,</span> <span class="mi">1024</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">768</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">Sigma</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>Now, we want to check if the reconstructed <code class="docutils literal notranslate"><span class="pre">U</span> <span class="pre">&#64;</span> <span class="pre">Sigma</span> <span class="pre">&#64;</span> <span class="pre">Vt</span></code> is
close to the original <code class="docutils literal notranslate"><span class="pre">img_gray</span></code> matrix.</p>
<p><strong>Approximation</strong></p>
<p>The <a class="reference internal" href="../reference/routines.linalg.html#module-numpy.linalg" title="numpy.linalg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linalg</span></code></a> module includes a <code class="docutils literal notranslate"><span class="pre">norm</span></code> function, which
computes the norm of a vector or matrix represented in a NumPy array. For
example, from the SVD explanation above, we would expect the norm of the
difference between <code class="docutils literal notranslate"><span class="pre">img_gray</span></code> and the reconstructed SVD product to be small.
As expected, you should see something like</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">img_gray</span> <span class="o">-</span> <span class="n">U</span> <span class="o">@</span> <span class="n">Sigma</span> <span class="o">@</span> <span class="n">Vt</span><span class="p">)</span>
<span class="go">1.3926466851808837e-12</span>
</pre></div>
</div>
<p>(The actual result of this operation might be different depending on your
architecture and linear algebra setup. Regardless, you should see a small
number.)</p>
<p>We could also have used the <a class="reference internal" href="../reference/generated/numpy.allclose.html#numpy.allclose" title="numpy.allclose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.allclose</span></code></a> function to make sure the
reconstructed product is, in fact, <em>close</em> to our original matrix (the
difference between the two arrays is small):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">img_gray</span><span class="p">,</span> <span class="n">U</span> <span class="o">@</span> <span class="n">Sigma</span> <span class="o">@</span> <span class="n">Vt</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>To see if an approximation is reasonable, we can check the values in <code class="docutils literal notranslate"><span class="pre">s</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure align-center">
<img alt="../_images/plot_gray_svd.png" src="../_images/plot_gray_svd.png" />
</div>
<p>In the graph, we can see that although we have 768 singular values in
<code class="docutils literal notranslate"><span class="pre">s</span></code>, most of those (after the 150th entry or so) are pretty small. So it
might make sense to use only the information related to the first (say, 50)
<em>singular values</em> to build a more economical approximation to our image.</p>
<p>The idea is to consider all but the first <code class="docutils literal notranslate"><span class="pre">k</span></code> singular values in
<code class="docutils literal notranslate"><span class="pre">Sigma</span></code> (which are the same as in <code class="docutils literal notranslate"><span class="pre">s</span></code>) as zeros, keeping
<code class="docutils literal notranslate"><span class="pre">U</span></code> and <code class="docutils literal notranslate"><span class="pre">Vt</span></code> intact, and computing the product of these matrices
as the approximation.</p>
<p>For example, if we choose</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="mi">10</span>
</pre></div>
</div>
<p>we can build the approximation by doing</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">approx</span> <span class="o">=</span> <span class="n">U</span> <span class="o">@</span> <span class="n">Sigma</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span> <span class="o">@</span> <span class="n">Vt</span><span class="p">[:</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span>
</pre></div>
</div>
<p>Note that we had to use only the first <code class="docutils literal notranslate"><span class="pre">k</span></code> rows of <code class="docutils literal notranslate"><span class="pre">Vt</span></code>, since all
other rows would be multiplied by the zeros corresponding to the singular
values we eliminated from this approximation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">approx</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="figure align-center">
<img alt="../_images/plot_approx.png" src="../_images/plot_approx.png" />
</div>
<p>Now, you can go ahead and repeat this experiment with other values of <em class="xref py py-obj">k</em>, and
each of your experiments should give you a slightly better (or worse) image
depending on the value you choose.</p>
<p><strong>Applying to all colors</strong></p>
<p>Now we want to do the same kind of operation, but to all three colors. Our
first instinct might be to repeat the same operation we did above to each color
matrix individually. However, NumPy’s <em class="xref py py-obj">broadcasting</em> takes care of this
for us.</p>
<p>If our array has more than two dimensions, then the SVD can be applied to all
axes at once. However, the linear algebra functions in NumPy expect to see an
array of the form <code class="docutils literal notranslate"><span class="pre">(N,</span> <span class="pre">M,</span> <span class="pre">M)</span></code>, where the first axis represents the number
of matrices.</p>
<p>In our case,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img_array</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(768, 1024, 3)</span>
</pre></div>
</div>
<p>so we need to permutate the axis on this array to get a shape like
<code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">768,</span> <span class="pre">1024)</span></code>. Fortunately, the <a class="reference internal" href="../reference/generated/numpy.transpose.html#numpy.transpose" title="numpy.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.transpose</span></code></a> function can do that for
us:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
</pre></div>
</div>
<p>indicates that the axis will be reordered such that the final shape of the
transposed array will be reordered according to the indices <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j,</span> <span class="pre">k)</span></code>.</p>
<p>Let’s see how this goes for our array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img_array_transposed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">img_array</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_array_transposed</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 768, 1024)</span>
</pre></div>
</div>
<p>Now we are ready to apply the SVD:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">Vt</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">img_array_transposed</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, to obtain the full approximated image, we need to reassemble these
matrices into the approximation. Now, note that</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">U</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">Vt</span><span class="o">.</span><span class="n">shape</span>
<span class="go">((3, 768, 768), (3, 768), (3, 1024, 1024))</span>
</pre></div>
</div>
<p>To build the final approximation matrix, we must understand how multiplication
across different axes works.</p>
<p><strong>Products with n-dimensional arrays</strong></p>
<p>If you have worked before with only one- or two-dimensional arrays in NumPy,
you might use <a class="reference internal" href="../reference/generated/numpy.dot.html#numpy.dot" title="numpy.dot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.dot</span></code></a> and <a class="reference internal" href="../reference/generated/numpy.matmul.html#numpy.matmul" title="numpy.matmul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.matmul</span></code></a> (or the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> operator)
interchangeably. However, for n-dimensional arrays, they work in very different
ways. For more details, check the documentation <a class="reference internal" href="../reference/generated/numpy.matmul.html#numpy.matmul" title="numpy.matmul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.matmul</span></code></a>.</p>
<p>Now, to build our approximation, we first need to make sure that our singular
values are ready for multiplication, so we build our <code class="docutils literal notranslate"><span class="pre">Sigma</span></code> matrix similarly
to what we did before. The <code class="docutils literal notranslate"><span class="pre">Sigma</span></code> array must have dimensions
<code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">768,</span> <span class="pre">1024)</span></code>. In order to add the singular values to the diagonal of
<code class="docutils literal notranslate"><span class="pre">Sigma</span></code>, we will use the <code class="docutils literal notranslate"><span class="pre">fill_diagonal</span></code> function from NumPy, using each of
the 3 rows in <code class="docutils literal notranslate"><span class="pre">s</span></code> as the diagonal for each of the 3 matrices in <code class="docutils literal notranslate"><span class="pre">Sigma</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">768</span><span class="p">,</span> <span class="mi">1024</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">Sigma</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:])</span>
</pre></div>
</div>
<p>Now, if we wish to rebuild the full SVD (with no approximation), we can do</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reconstructed</span> <span class="o">=</span> <span class="n">U</span> <span class="o">@</span> <span class="n">Sigma</span> <span class="o">@</span> <span class="n">Vt</span>
</pre></div>
</div>
<p>Note that</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reconstructed</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 768, 1024)</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">reconstructed</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
</pre></div>
</div>
<div class="figure align-center">
<img alt="../_images/plot_reconstructed.png" src="../_images/plot_reconstructed.png" />
</div>
<p>should give you an image indistinguishable from the original one (although we
may introduce floating point errors for this reconstruction). In fact,
you might see a warning message saying <em class="xref py py-obj">“Clipping input data to the
valid range for imshow with RGB data ([0..1] for floats or [0..255] for
integers).”</em> This is expected from the manipulation we just did on the original
image.</p>
<p>Now, to do the approximation, we must choose only the first <code class="docutils literal notranslate"><span class="pre">k</span></code> singular
values for each color channel. This can be done using the following syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">approx_img</span> <span class="o">=</span> <span class="n">U</span> <span class="o">@</span> <span class="n">Sigma</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span> <span class="o">@</span> <span class="n">Vt</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span>
</pre></div>
</div>
<p>You can see that we have selected only the first <code class="docutils literal notranslate"><span class="pre">k</span></code> components of the last
axis for <code class="docutils literal notranslate"><span class="pre">Sigma</span></code> (this means that we have used only the first <code class="docutils literal notranslate"><span class="pre">k</span></code> columns
of each of the three matrices in the stack), and that we have selected only the
first <code class="docutils literal notranslate"><span class="pre">k</span></code> components in the second-to-last axis of <code class="docutils literal notranslate"><span class="pre">Vt</span></code> (this means we have
selected only the first <code class="docutils literal notranslate"><span class="pre">k</span></code> rows from every matrix in the stack <code class="docutils literal notranslate"><span class="pre">Vt</span></code> and
all columns). If you are unfamiliar with the ellipsis syntax, it is a
placeholder for other axes. For more details, see the documentation on
<a class="reference internal" href="basics.indexing.html#basics-indexing"><span class="std std-ref">Indexing</span></a>.</p>
<p>Now,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">approx_img</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 768, 1024)</span>
</pre></div>
</div>
<p>which is not the right shape for showing the image. Finally, reordering the axes
back to our original shape of <code class="docutils literal notranslate"><span class="pre">(768,</span> <span class="pre">1024,</span> <span class="pre">3)</span></code>, we can see our approximation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">approx_img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
</pre></div>
</div>
<div class="figure align-center">
<img alt="../_images/plot_final.png" src="../_images/plot_final.png" />
</div>
<p>Even though the image is not as sharp, using a small number of <code class="docutils literal notranslate"><span class="pre">k</span></code> singular
values (compared to the original set of 768 values), we can recover many of the
distinguishing features from this image.</p>
<p><strong>Final words</strong></p>
<p>Of course, this is not the best method to <em>approximate</em> an image.
However, there is, in fact, a result in linear algebra that says that the
approximation we built above is the best we can get to the original matrix in
terms of the norm of the difference. For more information, see <em>G. H. Golub and
C. F. Van Loan, Matrix Computations, Baltimore, MD, Johns Hopkins University
Press, 1985</em>.</p>
<p><strong>Further reading</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/dev/tutorial/index.html" title="(in Python v3.10)"><span class="xref std std-doc">Python tutorial</span></a></p></li>
<li><p><a class="reference internal" href="../reference/index.html#reference"><span class="std std-ref">NumPy Reference</span></a></p></li>
<li><p><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/tutorial/index.html" title="(in SciPy v1.5.0)"><span class="xref std std-doc">SciPy Tutorial</span></a></p></li>
<li><p><a class="reference external" href="https://scipy-lectures.org">SciPy Lecture Notes</a></p></li>
<li><p><a class="reference external" href="http://mathesaurus.sf.net/">A matlab, R, IDL, NumPy/SciPy dictionary</a></p></li>
</ul>
</div>


          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2008-2020, The SciPy community.
      </li>
      <li>
      Last updated on Jun 29, 2020.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 2.4.4.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>