
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>matplotlib.tri &#8212; Matplotlib 3.3.1 documentation</title>
    <link rel="stylesheet" href="../_static/mpl.css?v3.3.1-dirty" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery-dataframe.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Matplotlib 3.3.1 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>

    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="matplotlib.type1font" href="type1font.html" />
    <link rel="prev" title="matplotlib.transforms" href="transformations.html" />
<link rel="top" title="Matplotlib 3.3.1 documentation" href="#" />
    <link rel="canonical" href="https://matplotlib.org/3.3.1/api/tri_api.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>


<!--
<div id="annc-banner">

</div>
-->

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px; position: relative;">
    <a href="../index.html">
        <div style="float: left; position: absolute; width: 496px; bottom: 0; padding-bottom: 24px"><span style="float: right; color: #789; background: white">Version 3.3.1</span></div>
        <img src="../_static/logo2_compressed.svg" height="125px" border="0" alt="matplotlib"/></a>

    <!-- The "Fork me on github" ribbon -->
    <div id="forkongithub"><a href="https://github.com/matplotlib/matplotlib">Fork me on GitHub</a></div>
    </div>

    <nav class="main-nav">
        <ul>
            <li><a href="../users/installing.html">Installation</a></li>
            <li><a href="../contents.html">Documentation</a></li>
            <li><a href="../gallery/index.html">Examples</a></li>
            <li><a href="../tutorials/index.html">Tutorials</a></li>
            <li><a href="../devel/index.html">Contributing</a></li>
            <li class="nav-right">
                <form class="search" action="../search.html" method="get">
                <input type="text" name="q" aria-labelledby="searchlabel" placeholder="Search"/>
                </form>
            </li>
        </ul>
     </nav>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="type1font.html" title="matplotlib.type1font"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="transformations.html" title="matplotlib.transforms"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">home</a>|&nbsp;</li>
        <li><a href="../contents.html">contents</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">API Overview</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="docutils literal notranslate"><span class="pre">matplotlib.tri</span></code></a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../contents.html">Documentation overview</a><ul>
  <li><a href="index.html">API Overview</a><ul>
      <li>Previous: <a href="transformations.html" title="previous chapter"><code class="docutils literal notranslate"><span class="pre">matplotlib.transforms</span></code></a></li>
      <li>Next: <a href="type1font.html" title="next chapter"><code class="docutils literal notranslate"><span class="pre">matplotlib.type1font</span></code></a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div id="sidebar-pagesource" role="note" aria-label="source link"
    style="margin-top: 1.5em; padding-top: 0.1em; border-top: 1px solid #86989b">
  <a href="../_sources/api/tri_api.rst.txt"
     style="color: #c0c0c0" rel="nofollow">Show Page Source</a>
  </div>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="module-matplotlib.tri">
<span id="matplotlib-tri"></span><h1><code class="docutils literal notranslate"><span class="pre">matplotlib.tri</span></code><a class="headerlink" href="#module-matplotlib.tri" title="Permalink to this headline">¶</a></h1>
<p>Unstructured triangular grid functions.</p>
<dl class="py class">
<dt id="matplotlib.tri.Triangulation">
<em class="property">class </em><code class="descclassname">matplotlib.tri.</code><code class="descname">Triangulation</code><span class="sig-paren">(</span><em><span class="n">x</span></em>, <em><span class="n">y</span></em>, <em><span class="n">triangles</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">mask</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/tri/triangulation.html#Triangulation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.tri.Triangulation" title="Permalink to this definition">¶</a></dt>
<dd><p>An unstructured triangular grid consisting of npoints points and
ntri triangles.  The triangles can either be specified by the user
or automatically generated using a Delaunay triangulation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x, y</strong><span class="classifier">array-like of shape (npoints)</span></dt><dd><p>Coordinates of grid points.</p>
</dd>
<dt><strong>triangles</strong><span class="classifier">int array-like of shape (ntri, 3), optional</span></dt><dd><p>For each triangle, the indices of the three points that make
up the triangle, ordered in an anticlockwise manner.  If not
specified, the Delaunay triangulation is calculated.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">bool array-like of shape (ntri), optional</span></dt><dd><p>Which triangles are masked out.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For a Triangulation to be valid it must not have duplicate points,
triangles formed from colinear points, or overlapping triangles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><a class="reference internal" href="#matplotlib.tri.Triangulation.edges" title="matplotlib.tri.Triangulation.edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></a><span class="classifier">int array of shape (nedges, 2)</span></dt><dd><p>Return integer array of shape (nedges, 2) containing all edges of non-masked triangles.</p>
</dd>
<dt><a class="reference internal" href="#matplotlib.tri.Triangulation.neighbors" title="matplotlib.tri.Triangulation.neighbors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">neighbors</span></code></a><span class="classifier">int array of shape (ntri, 3)</span></dt><dd><p>Return integer array of shape (ntri, 3) containing neighbor triangles.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">bool array of shape (ntri, 3)</span></dt><dd><p>Masked out triangles.</p>
</dd>
<dt><strong>is_delaunay</strong><span class="classifier">bool</span></dt><dd><p>Whether the Triangulation is a calculated Delaunay
triangulation (where <em>triangles</em> was not specified) or not.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="matplotlib.tri.Triangulation.calculate_plane_coefficients">
<code class="descname">calculate_plane_coefficients</code><span class="sig-paren">(</span><em><span class="n">z</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/tri/triangulation.html#Triangulation.calculate_plane_coefficients"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.tri.Triangulation.calculate_plane_coefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate plane equation coefficients for all unmasked triangles from
the point (x, y) coordinates and specified z-array of shape (npoints).
The returned array has shape (npoints, 3) and allows z-value at (x, y)
position in triangle tri to be calculated using
<code class="docutils literal notranslate"><span class="pre">z</span> <span class="pre">=</span> <span class="pre">array[tri,</span> <span class="pre">0]</span> <span class="pre">*</span> <span class="pre">x</span>&#160; <span class="pre">+</span> <span class="pre">array[tri,</span> <span class="pre">1]</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">array[tri,</span> <span class="pre">2]</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="matplotlib.tri.Triangulation.edges">
<em class="property">property </em><code class="descname">edges</code><a class="headerlink" href="#matplotlib.tri.Triangulation.edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return integer array of shape (nedges, 2) containing all edges of
non-masked triangles.</p>
<p>Each row defines an edge by it's start point index and end point
index.  Each edge appears only once, i.e. for an edge between points
<em>i</em>  and <em>j</em>, there will only be either <em>(i, j)</em> or <em>(j, i)</em>.</p>
</dd></dl>

<dl class="py method">
<dt id="matplotlib.tri.Triangulation.get_cpp_triangulation">
<code class="descname">get_cpp_triangulation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/tri/triangulation.html#Triangulation.get_cpp_triangulation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.tri.Triangulation.get_cpp_triangulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the underlying C++ Triangulation object, creating it
if necessary.</p>
</dd></dl>

<dl class="py method">
<dt id="matplotlib.tri.Triangulation.get_from_args_and_kwargs">
<em class="property">static </em><code class="descname">get_from_args_and_kwargs</code><span class="sig-paren">(</span><em><span class="o">*</span><span class="n">args</span></em>, <em><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/tri/triangulation.html#Triangulation.get_from_args_and_kwargs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.tri.Triangulation.get_from_args_and_kwargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Triangulation object from the args and kwargs, and
the remaining args and kwargs with the consumed values removed.</p>
<p>There are two alternatives: either the first argument is a
Triangulation object, in which case it is returned, or the args
and kwargs are sufficient to create a new Triangulation to
return.  In the latter case, see Triangulation.__init__ for
the possible args and kwargs.</p>
</dd></dl>

<dl class="py method">
<dt id="matplotlib.tri.Triangulation.get_masked_triangles">
<code class="descname">get_masked_triangles</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/tri/triangulation.html#Triangulation.get_masked_triangles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.tri.Triangulation.get_masked_triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of triangles that are not masked.</p>
</dd></dl>

<dl class="py method">
<dt id="matplotlib.tri.Triangulation.get_trifinder">
<code class="descname">get_trifinder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/tri/triangulation.html#Triangulation.get_trifinder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.tri.Triangulation.get_trifinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the default <a class="reference internal" href="#matplotlib.tri.TriFinder" title="matplotlib.tri.TriFinder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">matplotlib.tri.TriFinder</span></code></a> of this
triangulation, creating it if necessary.  This allows the same
TriFinder object to be easily shared.</p>
</dd></dl>

<dl class="py method">
<dt id="matplotlib.tri.Triangulation.neighbors">
<em class="property">property </em><code class="descname">neighbors</code><a class="headerlink" href="#matplotlib.tri.Triangulation.neighbors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return integer array of shape (ntri, 3) containing neighbor triangles.</p>
<p>For each triangle, the indices of the three triangles that
share the same edges, or -1 if there is no such neighboring
triangle.  <code class="docutils literal notranslate"><span class="pre">neighbors[i,</span> <span class="pre">j]</span></code> is the triangle that is the neighbor
to the edge from point index <code class="docutils literal notranslate"><span class="pre">triangles[i,</span> <span class="pre">j]</span></code> to point index
<code class="docutils literal notranslate"><span class="pre">triangles[i,</span> <span class="pre">(j+1)%3]</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="matplotlib.tri.Triangulation.set_mask">
<code class="descname">set_mask</code><span class="sig-paren">(</span><em><span class="n">mask</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/tri/triangulation.html#Triangulation.set_mask"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.tri.Triangulation.set_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Set or clear the mask array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mask</strong><span class="classifier">None or bool array of length ntri</span></dt><dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="matplotlib.tri.TriContourSet">
<em class="property">class </em><code class="descclassname">matplotlib.tri.</code><code class="descname">TriContourSet</code><span class="sig-paren">(</span><em><span class="n">ax</span></em>, <em><span class="o">*</span><span class="n">args</span></em>, <em><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/tri/tricontour.html#TriContourSet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.tri.TriContourSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="contour_api.html#matplotlib.contour.ContourSet" title="matplotlib.contour.ContourSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.contour.ContourSet</span></code></a></p>
<p>Create and store a set of contour lines or filled regions for
a triangular grid.</p>
<p>User-callable method: clabel</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ax</strong></dt><dd><p>The axes object in which the contours are drawn.</p>
</dd>
<dt><strong>collections</strong></dt><dd><p>A silent_list of LineCollections or PolyCollections.</p>
</dd>
<dt><strong>levels</strong></dt><dd><p>Contour levels.</p>
</dd>
<dt><strong>layers</strong></dt><dd><p>Same as levels for line contours; half-way between
levels for filled contours.  See <code class="xref py py-meth docutils literal notranslate"><span class="pre">_process_colors()</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Draw triangular grid contour lines or filled regions,
depending on whether keyword arg 'filled' is False
(default) or True.</p>
<p>The first argument of the initializer must be an axes
object.  The remaining arguments and keyword arguments
are described in the docstring of <a class="reference internal" href="_as_gen/matplotlib.axes.Axes.tricontour.html#matplotlib.axes.Axes.tricontour" title="matplotlib.axes.Axes.tricontour"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tricontour</span></code></a>.</p>
</dd></dl>

<dl class="py class">
<dt id="matplotlib.tri.TriFinder">
<em class="property">class </em><code class="descclassname">matplotlib.tri.</code><code class="descname">TriFinder</code><span class="sig-paren">(</span><em><span class="n">triangulation</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/tri/trifinder.html#TriFinder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.tri.TriFinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for classes used to find the triangles of a
Triangulation in which (x, y) points lie.</p>
<p>Rather than instantiate an object of a class derived from TriFinder, it is
usually better to use the function <a class="reference internal" href="#matplotlib.tri.Triangulation.get_trifinder" title="matplotlib.tri.Triangulation.get_trifinder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Triangulation.get_trifinder</span></code></a>.</p>
<p>Derived classes implement __call__(x, y) where x and y are array-like point
coordinates of the same shape.</p>
</dd></dl>

<dl class="py class">
<dt id="matplotlib.tri.TrapezoidMapTriFinder">
<em class="property">class </em><code class="descclassname">matplotlib.tri.</code><code class="descname">TrapezoidMapTriFinder</code><span class="sig-paren">(</span><em><span class="n">triangulation</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/tri/trifinder.html#TrapezoidMapTriFinder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.tri.TrapezoidMapTriFinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.tri.trifinder.TriFinder</span></code></p>
<p><a class="reference internal" href="#matplotlib.tri.TriFinder" title="matplotlib.tri.TriFinder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TriFinder</span></code></a> class implemented using the trapezoid
map algorithm from the book &quot;Computational Geometry, Algorithms and
Applications&quot;, second edition, by M. de Berg, M. van Kreveld, M. Overmars
and O. Schwarzkopf.</p>
<p>The triangulation must be valid, i.e. it must not have duplicate points,
triangles formed from colinear points, or overlapping triangles.  The
algorithm has some tolerance to triangles formed from colinear points, but
this should not be relied upon.</p>
</dd></dl>

<dl class="py class">
<dt id="matplotlib.tri.TriInterpolator">
<em class="property">class </em><code class="descclassname">matplotlib.tri.</code><code class="descname">TriInterpolator</code><span class="sig-paren">(</span><em><span class="n">triangulation</span></em>, <em><span class="n">z</span></em>, <em><span class="n">trifinder</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/tri/triinterpolate.html#TriInterpolator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.tri.TriInterpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for classes used to interpolate on a triangular grid.</p>
<p>Derived classes implement the following methods:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">__call__(x,</span> <span class="pre">y)</span></code>,
where x, y are array-like point coordinates of the same shape, and
that returns a masked array of the same shape containing the
interpolated z-values.</li>
<li><code class="docutils literal notranslate"><span class="pre">gradient(x,</span> <span class="pre">y)</span></code>,
where x, y are array-like point coordinates of the same
shape, and that returns a list of 2 masked arrays of the same shape
containing the 2 derivatives of the interpolator (derivatives of
interpolated z values with respect to x and y).</li>
</ul>
</dd></dl>

<dl class="py class">
<dt id="matplotlib.tri.LinearTriInterpolator">
<em class="property">class </em><code class="descclassname">matplotlib.tri.</code><code class="descname">LinearTriInterpolator</code><span class="sig-paren">(</span><em><span class="n">triangulation</span></em>, <em><span class="n">z</span></em>, <em><span class="n">trifinder</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/tri/triinterpolate.html#LinearTriInterpolator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.tri.LinearTriInterpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.tri.triinterpolate.TriInterpolator</span></code></p>
<p>Linear interpolator on a triangular grid.</p>
<p>Each triangle is represented by a plane so that an interpolated value at
point (x, y) lies on the plane of the triangle containing (x, y).
Interpolated values are therefore continuous across the triangulation, but
their first derivatives are discontinuous at edges between triangles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>triangulation</strong><span class="classifier"><a class="reference internal" href="#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Triangulation</span></code></a></span></dt><dd><p>The triangulation to interpolate over.</p>
</dd>
<dt><strong>z</strong><span class="classifier">array-like of shape (npoints,)</span></dt><dd><p>Array of values, defined at grid points, to interpolate between.</p>
</dd>
<dt><strong>trifinder</strong><span class="classifier"><a class="reference internal" href="#matplotlib.tri.TriFinder" title="matplotlib.tri.TriFinder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TriFinder</span></code></a>, optional</span></dt><dd><p>If this is not specified, the Triangulation's default TriFinder will
be used by calling <a class="reference internal" href="#matplotlib.tri.Triangulation.get_trifinder" title="matplotlib.tri.Triangulation.get_trifinder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Triangulation.get_trifinder</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="docutils align-default">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>`__call__` (x, y)</strong></td>
<td>(Returns interpolated values at (x, y) points.)</td>
</tr>
<tr class="row-even"><td><strong>`gradient` (x, y)</strong></td>
<td>(Returns interpolated derivatives at (x, y) points.)</td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="matplotlib.tri.LinearTriInterpolator.gradient">
<code class="descname">gradient</code><span class="sig-paren">(</span><em><span class="n">x</span></em>, <em><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/tri/triinterpolate.html#LinearTriInterpolator.gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.tri.LinearTriInterpolator.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of 2 masked arrays containing interpolated derivatives
at the specified (x, y) points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x, y</strong><span class="classifier">array-like</span></dt><dd><p>x and y coordinates of the same shape and any number of
dimensions.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dzdx, dzdy</strong><span class="classifier">np.ma.array</span></dt><dd><p>2 masked arrays of the same shape as <em>x</em> and <em>y</em>; values
corresponding to (x, y) points outside of the triangulation
are masked out.
The first returned array contains the values of
<span class="math notranslate nohighlight">\(\frac{\partial z}{\partial x}\)</span> and the second those of
<span class="math notranslate nohighlight">\(\frac{\partial z}{\partial y}\)</span>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="matplotlib.tri.CubicTriInterpolator">
<em class="property">class </em><code class="descclassname">matplotlib.tri.</code><code class="descname">CubicTriInterpolator</code><span class="sig-paren">(</span><em><span class="n">triangulation</span></em>, <em><span class="n">z</span></em>, <em><span class="n">kind</span><span class="o">=</span><span class="default_value">'min_E'</span></em>, <em><span class="n">trifinder</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">dz</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/tri/triinterpolate.html#CubicTriInterpolator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.tri.CubicTriInterpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.tri.triinterpolate.TriInterpolator</span></code></p>
<p>Cubic interpolator on a triangular grid.</p>
<p>In one-dimension - on a segment - a cubic interpolating function is
defined by the values of the function and its derivative at both ends.
This is almost the same in 2-d inside a triangle, except that the values
of the function and its 2 derivatives have to be defined at each triangle
node.</p>
<p>The CubicTriInterpolator takes the value of the function at each node -
provided by the user - and internally computes the value of the
derivatives, resulting in a smooth interpolation.
(As a special feature, the user can also impose the value of the
derivatives at each node, but this is not supposed to be the common
usage.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>triangulation</strong><span class="classifier"><a class="reference internal" href="#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Triangulation</span></code></a></span></dt><dd><p>The triangulation to interpolate over.</p>
</dd>
<dt><strong>z</strong><span class="classifier">array-like of shape (npoints,)</span></dt><dd><p>Array of values, defined at grid points, to interpolate between.</p>
</dd>
<dt><strong>kind</strong><span class="classifier">{'min_E', 'geom', 'user'}, optional</span></dt><dd><p>Choice of the smoothing algorithm, in order to compute
the interpolant derivatives (defaults to 'min_E'):</p>
<ul class="simple">
<li>if 'min_E': (default) The derivatives at each node is computed
to minimize a bending energy.</li>
<li>if 'geom': The derivatives at each node is computed as a
weighted average of relevant triangle normals. To be used for
speed optimization (large grids).</li>
<li>if 'user': The user provides the argument <em>dz</em>, no computation
is hence needed.</li>
</ul>
</dd>
<dt><strong>trifinder</strong><span class="classifier"><a class="reference internal" href="#matplotlib.tri.TriFinder" title="matplotlib.tri.TriFinder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TriFinder</span></code></a>, optional</span></dt><dd><p>If not specified, the Triangulation's default TriFinder will
be used by calling <a class="reference internal" href="#matplotlib.tri.Triangulation.get_trifinder" title="matplotlib.tri.Triangulation.get_trifinder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Triangulation.get_trifinder</span></code></a>.</p>
</dd>
<dt><strong>dz</strong><span class="classifier">tuple of array-likes (dzdx, dzdy), optional</span></dt><dd><p>Used only if  <em>kind</em> ='user'. In this case <em>dz</em> must be provided as
(dzdx, dzdy) where dzdx, dzdy are arrays of the same shape as <em>z</em> and
are the interpolant first derivatives at the <em>triangulation</em> points.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This note is a bit technical and details how the cubic interpolation is
computed.</p>
<p>The interpolation is based on a Clough-Tocher subdivision scheme of
the <em>triangulation</em> mesh (to make it clearer, each triangle of the
grid will be divided in 3 child-triangles, and on each child triangle
the interpolated function is a cubic polynomial of the 2 coordinates).
This technique originates from FEM (Finite Element Method) analysis;
the element used is a reduced Hsieh-Clough-Tocher (HCT)
element. Its shape functions are described in <a class="reference internal" href="#r0be0c58fd53f-1" id="id1">[1]</a>.
The assembled function is guaranteed to be C1-smooth, i.e. it is
continuous and its first derivatives are also continuous (this
is easy to show inside the triangles but is also true when crossing the
edges).</p>
<p>In the default case (<em>kind</em> ='min_E'), the interpolant minimizes a
curvature energy on the functional space generated by the HCT element
shape functions - with imposed values but arbitrary derivatives at each
node. The minimized functional is the integral of the so-called total
curvature (implementation based on an algorithm from <a class="reference internal" href="#r0be0c58fd53f-2" id="id2">[2]</a> - PCG sparse
solver):</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[E(z) = \frac{1}{2} \int_{\Omega} \left(
    \left( \frac{\partial^2{z}}{\partial{x}^2} \right)^2 +
    \left( \frac{\partial^2{z}}{\partial{y}^2} \right)^2 +
    2\left( \frac{\partial^2{z}}{\partial{y}\partial{x}} \right)^2
\right) dx\,dy\]</div>
</div></blockquote>
<p>If the case <em>kind</em> ='geom' is chosen by the user, a simple geometric
approximation is used (weighted average of the triangle normal
vectors), which could improve speed on very large grids.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r0be0c58fd53f-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Michel Bernadou, Kamal Hassan, &quot;Basis functions for general
Hsieh-Clough-Tocher triangles, complete or reduced.&quot;,
International Journal for Numerical Methods in Engineering,
17(5):784 - 789. 2.01.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r0be0c58fd53f-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>C.T. Kelley, &quot;Iterative Methods for Optimization&quot;.</td></tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="docutils align-default">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>`__call__` (x, y)</strong></td>
<td>(Returns interpolated values at (x, y) points.)</td>
</tr>
<tr class="row-even"><td><strong>`gradient` (x, y)</strong></td>
<td>(Returns interpolated derivatives at (x, y) points.)</td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="matplotlib.tri.CubicTriInterpolator.gradient">
<code class="descname">gradient</code><span class="sig-paren">(</span><em><span class="n">x</span></em>, <em><span class="n">y</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/tri/triinterpolate.html#CubicTriInterpolator.gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.tri.CubicTriInterpolator.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of 2 masked arrays containing interpolated derivatives
at the specified (x, y) points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x, y</strong><span class="classifier">array-like</span></dt><dd><p>x and y coordinates of the same shape and any number of
dimensions.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dzdx, dzdy</strong><span class="classifier">np.ma.array</span></dt><dd><p>2 masked arrays of the same shape as <em>x</em> and <em>y</em>; values
corresponding to (x, y) points outside of the triangulation
are masked out.
The first returned array contains the values of
<span class="math notranslate nohighlight">\(\frac{\partial z}{\partial x}\)</span> and the second those of
<span class="math notranslate nohighlight">\(\frac{\partial z}{\partial y}\)</span>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="matplotlib.tri.TriRefiner">
<em class="property">class </em><code class="descclassname">matplotlib.tri.</code><code class="descname">TriRefiner</code><span class="sig-paren">(</span><em><span class="n">triangulation</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/tri/trirefine.html#TriRefiner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.tri.TriRefiner" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract base class for classes implementing mesh refinement.</p>
<p>A TriRefiner encapsulates a Triangulation object and provides tools for
mesh refinement and interpolation.</p>
<p>Derived classes must implement:</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">refine_triangulation(return_tri_index=False,</span> <span class="pre">**kwargs)</span></code> , where
the optional keyword arguments <em>kwargs</em> are defined in each
TriRefiner concrete implementation, and which returns:</p>
<ul class="simple">
<li>a refined triangulation,</li>
<li>optionally (depending on <em>return_tri_index</em>), for each
point of the refined triangulation: the index of
the initial triangulation triangle to which it belongs.</li>
</ul>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">refine_field(z,</span> <span class="pre">triinterpolator=None,</span> <span class="pre">**kwargs)</span></code>, where:</p>
<ul class="simple">
<li><em>z</em> array of field values (to refine) defined at the base
triangulation nodes,</li>
<li><em>triinterpolator</em> is an optional <a class="reference internal" href="#matplotlib.tri.TriInterpolator" title="matplotlib.tri.TriInterpolator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TriInterpolator</span></code></a>,</li>
<li>the other optional keyword arguments <em>kwargs</em> are defined in
each TriRefiner concrete implementation;</li>
</ul>
<p>and which returns (as a tuple) a refined triangular mesh and the
interpolated values of the field at the refined triangulation nodes.</p>
</li>
</ul>
</dd></dl>

<dl class="py class">
<dt id="matplotlib.tri.UniformTriRefiner">
<em class="property">class </em><code class="descclassname">matplotlib.tri.</code><code class="descname">UniformTriRefiner</code><span class="sig-paren">(</span><em><span class="n">triangulation</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/tri/trirefine.html#UniformTriRefiner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.tri.UniformTriRefiner" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.tri.trirefine.TriRefiner</span></code></p>
<p>Uniform mesh refinement by recursive subdivisions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>triangulation</strong><span class="classifier"><a class="reference internal" href="#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Triangulation</span></code></a></span></dt><dd><p>The encapsulated triangulation (to be refined)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="matplotlib.tri.UniformTriRefiner.refine_field">
<code class="descname">refine_field</code><span class="sig-paren">(</span><em><span class="n">z</span></em>, <em><span class="n">triinterpolator</span><span class="o">=</span><span class="default_value">None</span></em>, <em><span class="n">subdiv</span><span class="o">=</span><span class="default_value">3</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/tri/trirefine.html#UniformTriRefiner.refine_field"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.tri.UniformTriRefiner.refine_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Refine a field defined on the encapsulated triangulation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>z</strong><span class="classifier">1d-array-like of length <code class="docutils literal notranslate"><span class="pre">n_points</span></code></span></dt><dd><p>Values of the field to refine, defined at the nodes of the
encapsulated triangulation. (<code class="docutils literal notranslate"><span class="pre">n_points</span></code> is the number of points
in the initial triangulation)</p>
</dd>
<dt><strong>triinterpolator</strong><span class="classifier"><a class="reference internal" href="#matplotlib.tri.TriInterpolator" title="matplotlib.tri.TriInterpolator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TriInterpolator</span></code></a>, optional</span></dt><dd><p>Interpolator used for field interpolation. If not specified,
a <a class="reference internal" href="#matplotlib.tri.CubicTriInterpolator" title="matplotlib.tri.CubicTriInterpolator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CubicTriInterpolator</span></code></a> will be used.</p>
</dd>
<dt><strong>subdiv</strong><span class="classifier">int, default: 3</span></dt><dd><p>Recursion level for the subdivision.
Each triangle is divided into <code class="docutils literal notranslate"><span class="pre">4**subdiv</span></code> child triangles.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>refi_tri</strong><span class="classifier"><a class="reference internal" href="#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Triangulation</span></code></a></span></dt><dd><p>The returned refined triangulation.</p>
</dd>
<dt><strong>refi_z</strong><span class="classifier">1d array of length: <em>refi_tri</em> node count.</span></dt><dd><p>The returned interpolated field (at <em>refi_tri</em> nodes).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py method">
<dt id="matplotlib.tri.UniformTriRefiner.refine_triangulation">
<code class="descname">refine_triangulation</code><span class="sig-paren">(</span><em><span class="n">return_tri_index</span><span class="o">=</span><span class="default_value">False</span></em>, <em><span class="n">subdiv</span><span class="o">=</span><span class="default_value">3</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/tri/trirefine.html#UniformTriRefiner.refine_triangulation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.tri.UniformTriRefiner.refine_triangulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an uniformly refined triangulation <em>refi_triangulation</em> of
the encapsulated <code class="xref py py-attr docutils literal notranslate"><span class="pre">triangulation</span></code>.</p>
<p>This function refines the encapsulated triangulation by splitting each
father triangle into 4 child sub-triangles built on the edges midside
nodes, recursing <em>subdiv</em> times.  In the end, each triangle is hence
divided into <code class="docutils literal notranslate"><span class="pre">4**subdiv</span></code> child triangles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>return_tri_index</strong><span class="classifier">bool, default: False</span></dt><dd><p>Whether an index table indicating the father triangle index of each
point is returned.</p>
</dd>
<dt><strong>subdiv</strong><span class="classifier">int, default: 3</span></dt><dd><p>Recursion level for the subdivision.
Each triangle is divided into <code class="docutils literal notranslate"><span class="pre">4**subdiv</span></code> child triangles;
hence, the default results in 64 refined subtriangles for each
triangle of the initial triangulation.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>refi_triangulation</strong><span class="classifier"><a class="reference internal" href="#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Triangulation</span></code></a></span></dt><dd><p>The refined triangulation.</p>
</dd>
<dt><strong>found_index</strong><span class="classifier">int array</span></dt><dd><p>Index of the initial triangulation containing triangle, for each
point of <em>refi_triangulation</em>.
Returned only if <em>return_tri_index</em> is set to True.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="matplotlib.tri.TriAnalyzer">
<em class="property">class </em><code class="descclassname">matplotlib.tri.</code><code class="descname">TriAnalyzer</code><span class="sig-paren">(</span><em><span class="n">triangulation</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/tri/tritools.html#TriAnalyzer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.tri.TriAnalyzer" title="Permalink to this definition">¶</a></dt>
<dd><p>Define basic tools for triangular mesh analysis and improvement.</p>
<p>A TriAnalyzer encapsulates a <a class="reference internal" href="#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Triangulation</span></code></a> object and provides basic
tools for mesh analysis and mesh improvement.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>triangulation</strong><span class="classifier"><a class="reference internal" href="#matplotlib.tri.Triangulation" title="matplotlib.tri.Triangulation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Triangulation</span></code></a></span></dt><dd><p>The encapsulated triangulation to analyze.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><a class="reference internal" href="#matplotlib.tri.TriAnalyzer.scale_factors" title="matplotlib.tri.TriAnalyzer.scale_factors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale_factors</span></code></a></dt><dd><p>Factors to rescale the triangulation into a unit square.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="matplotlib.tri.TriAnalyzer.circle_ratios">
<code class="descname">circle_ratios</code><span class="sig-paren">(</span><em><span class="n">rescale</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/tri/tritools.html#TriAnalyzer.circle_ratios"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.tri.TriAnalyzer.circle_ratios" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a measure of the triangulation triangles flatness.</p>
<p>The ratio of the incircle radius over the circumcircle radius is a
widely used indicator of a triangle flatness.
It is always <code class="docutils literal notranslate"><span class="pre">&lt;=</span> <span class="pre">0.5</span></code> and <code class="docutils literal notranslate"><span class="pre">==</span> <span class="pre">0.5</span></code> only for equilateral
triangles. Circle ratios below 0.01 denote very flat triangles.</p>
<p>To avoid unduly low values due to a difference of scale between the 2
axis, the triangular mesh can first be rescaled to fit inside a unit
square with <a class="reference internal" href="#matplotlib.tri.TriAnalyzer.scale_factors" title="matplotlib.tri.TriAnalyzer.scale_factors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale_factors</span></code></a> (Only if <em>rescale</em> is True, which is
its default value).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>rescale</strong><span class="classifier">bool, default: True</span></dt><dd><p>If True, internally rescale (based on <a class="reference internal" href="#matplotlib.tri.TriAnalyzer.scale_factors" title="matplotlib.tri.TriAnalyzer.scale_factors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale_factors</span></code></a>), so that the
(unmasked) triangles fit exactly inside a unit square mesh.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>masked array</dt><dd><p>Ratio of the incircle radius over the circumcircle radius, for
each 'rescaled' triangle of the encapsulated triangulation.
Values corresponding to masked triangles are masked out.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py method">
<dt id="matplotlib.tri.TriAnalyzer.get_flat_tri_mask">
<code class="descname">get_flat_tri_mask</code><span class="sig-paren">(</span><em><span class="n">min_circle_ratio</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em><span class="n">rescale</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/tri/tritools.html#TriAnalyzer.get_flat_tri_mask"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.tri.TriAnalyzer.get_flat_tri_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Eliminate excessively flat border triangles from the triangulation.</p>
<p>Returns a mask <em>new_mask</em> which allows to clean the encapsulated
triangulation from its border-located flat triangles
(according to their <a class="reference internal" href="#matplotlib.tri.TriAnalyzer.circle_ratios" title="matplotlib.tri.TriAnalyzer.circle_ratios"><code class="xref py py-meth docutils literal notranslate"><span class="pre">circle_ratios()</span></code></a>).
This mask is meant to be subsequently applied to the triangulation
using <a class="reference internal" href="#matplotlib.tri.Triangulation.set_mask" title="matplotlib.tri.Triangulation.set_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Triangulation.set_mask</span></code></a>.
<em>new_mask</em> is an extension of the initial triangulation mask
in the sense that an initially masked triangle will remain masked.</p>
<p>The <em>new_mask</em> array is computed recursively; at each step flat
triangles are removed only if they share a side with the current mesh
border. Thus no new holes in the triangulated domain will be created.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>min_circle_ratio</strong><span class="classifier">float, default: 0.01</span></dt><dd><p>Border triangles with incircle/circumcircle radii ratio r/R will
be removed if r/R &lt; <em>min_circle_ratio</em>.</p>
</dd>
<dt><strong>rescale</strong><span class="classifier">bool, default: True</span></dt><dd><p>If True, first, internally rescale (based on <a class="reference internal" href="#matplotlib.tri.TriAnalyzer.scale_factors" title="matplotlib.tri.TriAnalyzer.scale_factors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale_factors</span></code></a>) so
that the (unmasked) triangles fit exactly inside a unit square
mesh.  This rescaling accounts for the difference of scale which
might exist between the 2 axis.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>bool array-like</dt><dd><p>Mask to apply to encapsulated triangulation.
All the initially masked triangles remain masked in the
<em>new_mask</em>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The rationale behind this function is that a Delaunay
triangulation - of an unstructured set of points - sometimes contains
almost flat triangles at its border, leading to artifacts in plots
(especially for high-resolution contouring).
Masked with computed <em>new_mask</em>, the encapsulated
triangulation would contain no more unmasked border triangles
with a circle ratio below <em>min_circle_ratio</em>, thus improving the
mesh quality for subsequent plots or interpolation.</p>
</dd></dl>

<dl class="py method">
<dt id="matplotlib.tri.TriAnalyzer.scale_factors">
<em class="property">property </em><code class="descname">scale_factors</code><a class="headerlink" href="#matplotlib.tri.TriAnalyzer.scale_factors" title="Permalink to this definition">¶</a></dt>
<dd><p>Factors to rescale the triangulation into a unit square.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>(float, float)</dt><dd><p>Scaling factors (kx, ky) so that the triangulation
<code class="docutils literal notranslate"><span class="pre">[triangulation.x</span> <span class="pre">*</span> <span class="pre">kx,</span> <span class="pre">triangulation.y</span> <span class="pre">*</span> <span class="pre">ky]</span></code>
fits exactly inside a unit square.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


          </div>
          
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer>
    <div class="footer">
    &copy; Copyright 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the Matplotlib development team; 2012 - 2020 The Matplotlib development team.
<br />
    Last updated on Aug 24, 2020.
Created using
<a href="http://sphinx-doc.org/">Sphinx</a> 3.2.1.
Doc version v3.3.1-dirty.
    </div>
</footer>
<script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-55954603-1', 'auto');
        ga('send', 'pageview');

</script>
  </body>
</html>