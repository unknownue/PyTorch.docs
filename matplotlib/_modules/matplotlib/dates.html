
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>matplotlib.dates &#8212; Matplotlib 3.3.1 documentation</title>
    <link rel="stylesheet" href="../../_static/mpl.css?v3.3.1-dirty" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery-dataframe.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Matplotlib 3.3.1 documentation"
          href="../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>

    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<link rel="top" title="Matplotlib 3.3.1 documentation" href="#" />
    <link rel="canonical" href="https://matplotlib.org/3.3.1/_modules/matplotlib/dates.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>


<!--
<div id="annc-banner">

</div>
-->

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px; position: relative;">
    <a href="../../index.html">
        <div style="float: left; position: absolute; width: 496px; bottom: 0; padding-bottom: 24px"><span style="float: right; color: #789; background: white">Version 3.3.1</span></div>
        <img src="../../_static/logo2_compressed.svg" height="125px" border="0" alt="matplotlib"/></a>

    <!-- The "Fork me on github" ribbon -->
    <div id="forkongithub"><a href="https://github.com/matplotlib/matplotlib">Fork me on GitHub</a></div>
    </div>

    <nav class="main-nav">
        <ul>
            <li><a href="../../users/installing.html">Installation</a></li>
            <li><a href="../../contents.html">Documentation</a></li>
            <li><a href="../../gallery/index.html">Examples</a></li>
            <li><a href="../../tutorials/index.html">Tutorials</a></li>
            <li><a href="../../devel/index.html">Contributing</a></li>
            <li class="nav-right">
                <form class="search" action="../../search.html" method="get">
                <input type="text" name="q" aria-labelledby="searchlabel" placeholder="Search"/>
                </form>
            </li>
        </ul>
     </nav>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../contents.html">contents</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../matplotlib.html" accesskey="U">matplotlib</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">matplotlib.dates</a></li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../contents.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  <li><a href="../matplotlib.html">matplotlib</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for matplotlib.dates</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Matplotlib provides sophisticated date plotting capabilities, standing on the</span>
<span class="sd">shoulders of python :mod:`datetime` and the add-on module :mod:`dateutil`.</span>

<span class="sd">.. _date-format:</span>

<span class="sd">Matplotlib date format</span>
<span class="sd">----------------------</span>

<span class="sd">Matplotlib represents dates using floating point numbers specifying the number</span>
<span class="sd">of days since a default epoch of 1970-01-01 UTC; for example,</span>
<span class="sd">1970-01-01, 06:00 is the floating point number 0.25. The formatters and</span>
<span class="sd">locators require the use of `datetime.datetime` objects, so only dates between</span>
<span class="sd">year 0001 and 9999 can be represented.  Microsecond precision</span>
<span class="sd">is achievable for (approximately) 70 years on either side of the epoch, and</span>
<span class="sd">20 microseconds for the rest of the allowable range of dates (year 0001 to</span>
<span class="sd">9999). The epoch can be changed at import time via `.dates.set_epoch` or</span>
<span class="sd">:rc:`dates.epoch` to other dates if necessary; see</span>
<span class="sd">:doc:`/gallery/ticks_and_spines/date_precision_and_epochs` for a discussion.</span>

<span class="sd">.. note::</span>

<span class="sd">   Before Matplotlib 3.3, the epoch was 0000-12-31 which lost modern</span>
<span class="sd">   microsecond precision and also made the default axis limit of 0 an invalid</span>
<span class="sd">   datetime.  In 3.3 the epoch was changed as above.  To convert old</span>
<span class="sd">   ordinal floats to the new epoch, users can do::</span>

<span class="sd">     new_ordinal = old_ordinal + mdates.date2num(np.datetime64(&#39;0000-12-31&#39;))</span>


<span class="sd">There are a number of helper functions to convert between :mod:`datetime`</span>
<span class="sd">objects and Matplotlib dates:</span>

<span class="sd">.. currentmodule:: matplotlib.dates</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :nosignatures:</span>

<span class="sd">   datestr2num</span>
<span class="sd">   date2num</span>
<span class="sd">   num2date</span>
<span class="sd">   num2timedelta</span>
<span class="sd">   drange</span>
<span class="sd">   set_epoch</span>
<span class="sd">   get_epoch</span>

<span class="sd">.. note::</span>

<span class="sd">   Like Python&#39;s `datetime.datetime`, Matplotlib uses the Gregorian calendar</span>
<span class="sd">   for all conversions between dates and floating point numbers. This practice</span>
<span class="sd">   is not universal, and calendar differences can cause confusing</span>
<span class="sd">   differences between what Python and Matplotlib give as the number of days</span>
<span class="sd">   since 0001-01-01 and what other software and databases yield.  For</span>
<span class="sd">   example, the US Naval Observatory uses a calendar that switches</span>
<span class="sd">   from Julian to Gregorian in October, 1582.  Hence, using their</span>
<span class="sd">   calculator, the number of days between 0001-01-01 and 2006-04-01 is</span>
<span class="sd">   732403, whereas using the Gregorian calendar via the datetime</span>
<span class="sd">   module we find::</span>

<span class="sd">     In [1]: date(2006, 4, 1).toordinal() - date(1, 1, 1).toordinal()</span>
<span class="sd">     Out[1]: 732401</span>

<span class="sd">All the Matplotlib date converters, tickers and formatters are timezone aware.</span>
<span class="sd">If no explicit timezone is provided, :rc:`timezone` is assumed.  If you want to</span>
<span class="sd">use a custom time zone, pass a `datetime.tzinfo` instance with the tz keyword</span>
<span class="sd">argument to `num2date`, `~.Axes.plot_date`, and any custom date tickers or</span>
<span class="sd">locators you create.</span>

<span class="sd">A wide range of specific and general purpose date tick locators and</span>
<span class="sd">formatters are provided in this module.  See</span>
<span class="sd">:mod:`matplotlib.ticker` for general information on tick locators</span>
<span class="sd">and formatters.  These are described below.</span>

<span class="sd">The dateutil_ module provides additional code to handle date ticking, making it</span>
<span class="sd">easy to place ticks on any kinds of dates.  See examples below.</span>

<span class="sd">.. _dateutil: https://dateutil.readthedocs.io</span>

<span class="sd">Date tickers</span>
<span class="sd">------------</span>

<span class="sd">Most of the date tickers can locate single or multiple values.  For example::</span>

<span class="sd">    # import constants for the days of the week</span>
<span class="sd">    from matplotlib.dates import MO, TU, WE, TH, FR, SA, SU</span>

<span class="sd">    # tick on mondays every week</span>
<span class="sd">    loc = WeekdayLocator(byweekday=MO, tz=tz)</span>

<span class="sd">    # tick on mondays and saturdays</span>
<span class="sd">    loc = WeekdayLocator(byweekday=(MO, SA))</span>

<span class="sd">In addition, most of the constructors take an interval argument::</span>

<span class="sd">    # tick on mondays every second week</span>
<span class="sd">    loc = WeekdayLocator(byweekday=MO, interval=2)</span>

<span class="sd">The rrule locator allows completely general date ticking::</span>

<span class="sd">    # tick every 5th easter</span>
<span class="sd">    rule = rrulewrapper(YEARLY, byeaster=1, interval=5)</span>
<span class="sd">    loc = RRuleLocator(rule)</span>

<span class="sd">The available date tickers are:</span>

<span class="sd">* `MicrosecondLocator`: Locate microseconds.</span>

<span class="sd">* `SecondLocator`: Locate seconds.</span>

<span class="sd">* `MinuteLocator`: Locate minutes.</span>

<span class="sd">* `HourLocator`: Locate hours.</span>

<span class="sd">* `DayLocator`: Locate specified days of the month.</span>

<span class="sd">* `WeekdayLocator`: Locate days of the week, e.g., MO, TU.</span>

<span class="sd">* `MonthLocator`: Locate months, e.g., 7 for July.</span>

<span class="sd">* `YearLocator`: Locate years that are multiples of base.</span>

<span class="sd">* `RRuleLocator`: Locate using a `matplotlib.dates.rrulewrapper`.</span>
<span class="sd">  `.rrulewrapper` is a simple wrapper around dateutil_&#39;s `dateutil.rrule` which</span>
<span class="sd">  allow almost arbitrary date tick specifications.  See :doc:`rrule example</span>
<span class="sd">  &lt;/gallery/ticks_and_spines/date_demo_rrule&gt;`.</span>

<span class="sd">* `AutoDateLocator`: On autoscale, this class picks the best `DateLocator`</span>
<span class="sd">  (e.g., `RRuleLocator`) to set the view limits and the tick locations.  If</span>
<span class="sd">  called with ``interval_multiples=True`` it will make ticks line up with</span>
<span class="sd">  sensible multiples of the tick intervals.  E.g. if the interval is 4 hours,</span>
<span class="sd">  it will pick hours 0, 4, 8, etc as ticks.  This behaviour is not guaranteed</span>
<span class="sd">  by default.</span>

<span class="sd">Date formatters</span>
<span class="sd">---------------</span>

<span class="sd">The available date formatters are:</span>

<span class="sd">* `AutoDateFormatter`: attempts to figure out the best format to use.  This is</span>
<span class="sd">  most useful when used with the `AutoDateLocator`.</span>

<span class="sd">* `ConciseDateFormatter`: also attempts to figure out the best format to use,</span>
<span class="sd">  and to make the format as compact as possible while still having complete</span>
<span class="sd">  date information.  This is most useful when used with the `AutoDateLocator`.</span>

<span class="sd">* `DateFormatter`: use `~datetime.datetime.strftime` format strings.</span>

<span class="sd">* `IndexDateFormatter`: date plots with implicit *x* indexing.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">from</span> <span class="nn">dateutil.rrule</span> <span class="kn">import</span> <span class="p">(</span><span class="n">rrule</span><span class="p">,</span> <span class="n">MO</span><span class="p">,</span> <span class="n">TU</span><span class="p">,</span> <span class="n">WE</span><span class="p">,</span> <span class="n">TH</span><span class="p">,</span> <span class="n">FR</span><span class="p">,</span> <span class="n">SA</span><span class="p">,</span> <span class="n">SU</span><span class="p">,</span> <span class="n">YEARLY</span><span class="p">,</span>
                            <span class="n">MONTHLY</span><span class="p">,</span> <span class="n">WEEKLY</span><span class="p">,</span> <span class="n">DAILY</span><span class="p">,</span> <span class="n">HOURLY</span><span class="p">,</span> <span class="n">MINUTELY</span><span class="p">,</span>
                            <span class="n">SECONDLY</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">dateutil.relativedelta</span> <span class="kn">import</span> <span class="n">relativedelta</span>
<span class="kn">import</span> <span class="nn">dateutil.parser</span>
<span class="kn">import</span> <span class="nn">dateutil.tz</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">import</span> <span class="nn">matplotlib.units</span> <span class="k">as</span> <span class="nn">units</span>
<span class="kn">import</span> <span class="nn">matplotlib.cbook</span> <span class="k">as</span> <span class="nn">cbook</span>
<span class="kn">import</span> <span class="nn">matplotlib.ticker</span> <span class="k">as</span> <span class="nn">ticker</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;datestr2num&#39;</span><span class="p">,</span> <span class="s1">&#39;date2num&#39;</span><span class="p">,</span> <span class="s1">&#39;num2date&#39;</span><span class="p">,</span> <span class="s1">&#39;num2timedelta&#39;</span><span class="p">,</span> <span class="s1">&#39;drange&#39;</span><span class="p">,</span>
           <span class="s1">&#39;epoch2num&#39;</span><span class="p">,</span> <span class="s1">&#39;num2epoch&#39;</span><span class="p">,</span> <span class="s1">&#39;mx2num&#39;</span><span class="p">,</span> <span class="s1">&#39;set_epoch&#39;</span><span class="p">,</span>
           <span class="s1">&#39;get_epoch&#39;</span><span class="p">,</span> <span class="s1">&#39;DateFormatter&#39;</span><span class="p">,</span>
           <span class="s1">&#39;ConciseDateFormatter&#39;</span><span class="p">,</span> <span class="s1">&#39;IndexDateFormatter&#39;</span><span class="p">,</span> <span class="s1">&#39;AutoDateFormatter&#39;</span><span class="p">,</span>
           <span class="s1">&#39;DateLocator&#39;</span><span class="p">,</span> <span class="s1">&#39;RRuleLocator&#39;</span><span class="p">,</span> <span class="s1">&#39;AutoDateLocator&#39;</span><span class="p">,</span> <span class="s1">&#39;YearLocator&#39;</span><span class="p">,</span>
           <span class="s1">&#39;MonthLocator&#39;</span><span class="p">,</span> <span class="s1">&#39;WeekdayLocator&#39;</span><span class="p">,</span>
           <span class="s1">&#39;DayLocator&#39;</span><span class="p">,</span> <span class="s1">&#39;HourLocator&#39;</span><span class="p">,</span> <span class="s1">&#39;MinuteLocator&#39;</span><span class="p">,</span>
           <span class="s1">&#39;SecondLocator&#39;</span><span class="p">,</span> <span class="s1">&#39;MicrosecondLocator&#39;</span><span class="p">,</span>
           <span class="s1">&#39;rrule&#39;</span><span class="p">,</span> <span class="s1">&#39;MO&#39;</span><span class="p">,</span> <span class="s1">&#39;TU&#39;</span><span class="p">,</span> <span class="s1">&#39;WE&#39;</span><span class="p">,</span> <span class="s1">&#39;TH&#39;</span><span class="p">,</span> <span class="s1">&#39;FR&#39;</span><span class="p">,</span> <span class="s1">&#39;SA&#39;</span><span class="p">,</span> <span class="s1">&#39;SU&#39;</span><span class="p">,</span>
           <span class="s1">&#39;YEARLY&#39;</span><span class="p">,</span> <span class="s1">&#39;MONTHLY&#39;</span><span class="p">,</span> <span class="s1">&#39;WEEKLY&#39;</span><span class="p">,</span> <span class="s1">&#39;DAILY&#39;</span><span class="p">,</span>
           <span class="s1">&#39;HOURLY&#39;</span><span class="p">,</span> <span class="s1">&#39;MINUTELY&#39;</span><span class="p">,</span> <span class="s1">&#39;SECONDLY&#39;</span><span class="p">,</span> <span class="s1">&#39;MICROSECONDLY&#39;</span><span class="p">,</span> <span class="s1">&#39;relativedelta&#39;</span><span class="p">,</span>
           <span class="s1">&#39;DateConverter&#39;</span><span class="p">,</span> <span class="s1">&#39;ConciseDateConverter&#39;</span><span class="p">)</span>


<span class="n">_log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">UTC</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span>


<span class="k">def</span> <span class="nf">_get_rc_timezone</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Retrieve the preferred timezone from the rcParams dictionary.&quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;timezone&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;UTC&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">UTC</span>
    <span class="k">return</span> <span class="n">dateutil</span><span class="o">.</span><span class="n">tz</span><span class="o">.</span><span class="n">gettz</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Time-related constants.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">EPOCH_OFFSET</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">1970</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">toordinal</span><span class="p">())</span>
<span class="c1"># EPOCH_OFFSET is not used by matplotlib</span>
<span class="n">JULIAN_OFFSET</span> <span class="o">=</span> <span class="mf">1721424.5</span>  <span class="c1"># Julian date at 0000-12-31</span>
<span class="c1"># note that the Julian day epoch is achievable w/</span>
<span class="c1"># np.datetime64(&#39;-4713-11-24T12:00:00&#39;); datetime64 is proleptic</span>
<span class="c1"># Gregorian and BC has a one-year offset.  So</span>
<span class="c1"># np.datetime64(&#39;0000-12-31&#39;) - np.datetime64(&#39;-4713-11-24T12:00&#39;) = 1721424.5</span>
<span class="c1"># Ref: https://en.wikipedia.org/wiki/Julian_day</span>
<span class="n">MICROSECONDLY</span> <span class="o">=</span> <span class="n">SECONDLY</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">HOURS_PER_DAY</span> <span class="o">=</span> <span class="mf">24.</span>
<span class="n">MIN_PER_HOUR</span> <span class="o">=</span> <span class="mf">60.</span>
<span class="n">SEC_PER_MIN</span> <span class="o">=</span> <span class="mf">60.</span>
<span class="n">MONTHS_PER_YEAR</span> <span class="o">=</span> <span class="mf">12.</span>

<span class="n">DAYS_PER_WEEK</span> <span class="o">=</span> <span class="mf">7.</span>
<span class="n">DAYS_PER_MONTH</span> <span class="o">=</span> <span class="mf">30.</span>
<span class="n">DAYS_PER_YEAR</span> <span class="o">=</span> <span class="mf">365.0</span>

<span class="n">MINUTES_PER_DAY</span> <span class="o">=</span> <span class="n">MIN_PER_HOUR</span> <span class="o">*</span> <span class="n">HOURS_PER_DAY</span>

<span class="n">SEC_PER_HOUR</span> <span class="o">=</span> <span class="n">SEC_PER_MIN</span> <span class="o">*</span> <span class="n">MIN_PER_HOUR</span>
<span class="n">SEC_PER_DAY</span> <span class="o">=</span> <span class="n">SEC_PER_HOUR</span> <span class="o">*</span> <span class="n">HOURS_PER_DAY</span>
<span class="n">SEC_PER_WEEK</span> <span class="o">=</span> <span class="n">SEC_PER_DAY</span> <span class="o">*</span> <span class="n">DAYS_PER_WEEK</span>

<span class="n">MUSECONDS_PER_DAY</span> <span class="o">=</span> <span class="mf">1e6</span> <span class="o">*</span> <span class="n">SEC_PER_DAY</span>

<span class="n">MONDAY</span><span class="p">,</span> <span class="n">TUESDAY</span><span class="p">,</span> <span class="n">WEDNESDAY</span><span class="p">,</span> <span class="n">THURSDAY</span><span class="p">,</span> <span class="n">FRIDAY</span><span class="p">,</span> <span class="n">SATURDAY</span><span class="p">,</span> <span class="n">SUNDAY</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">MO</span><span class="p">,</span> <span class="n">TU</span><span class="p">,</span> <span class="n">WE</span><span class="p">,</span> <span class="n">TH</span><span class="p">,</span> <span class="n">FR</span><span class="p">,</span> <span class="n">SA</span><span class="p">,</span> <span class="n">SU</span><span class="p">)</span>
<span class="n">WEEKDAYS</span> <span class="o">=</span> <span class="p">(</span><span class="n">MONDAY</span><span class="p">,</span> <span class="n">TUESDAY</span><span class="p">,</span> <span class="n">WEDNESDAY</span><span class="p">,</span> <span class="n">THURSDAY</span><span class="p">,</span> <span class="n">FRIDAY</span><span class="p">,</span> <span class="n">SATURDAY</span><span class="p">,</span> <span class="n">SUNDAY</span><span class="p">)</span>

<span class="c1"># default epoch: passed to np.datetime64...</span>
<span class="n">_epoch</span> <span class="o">=</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">_reset_epoch_test_example</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reset the Matplotlib date epoch so it can be set again.</span>

<span class="sd">    Only for use in tests and examples.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_epoch</span>
    <span class="n">_epoch</span> <span class="o">=</span> <span class="kc">None</span>


<div class="viewcode-block" id="set_epoch"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.set_epoch">[docs]</a><span class="k">def</span> <span class="nf">set_epoch</span><span class="p">(</span><span class="n">epoch</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set the epoch (origin for dates) for datetime calculations.</span>

<span class="sd">    The default epoch is :rc:`dates.epoch` (by default 1970-01-01T00:00).</span>

<span class="sd">    If microsecond accuracy is desired, the date being plotted needs to be</span>
<span class="sd">    within approximately 70 years of the epoch. Matplotlib internally</span>
<span class="sd">    represents dates as days since the epoch, so floating point dynamic</span>
<span class="sd">    range needs to be within a factor fo 2^52.</span>

<span class="sd">    `~.dates.set_epoch` must be called before any dates are converted</span>
<span class="sd">    (i.e. near the import section) or a RuntimeError will be raised.</span>

<span class="sd">    See also :doc:`/gallery/ticks_and_spines/date_precision_and_epochs`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    epoch : str</span>
<span class="sd">        valid UTC date parsable by `numpy.datetime64` (do not include</span>
<span class="sd">        timezone).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_epoch</span>
    <span class="k">if</span> <span class="n">_epoch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;set_epoch must be called before dates plotted.&#39;</span><span class="p">)</span>
    <span class="n">_epoch</span> <span class="o">=</span> <span class="n">epoch</span></div>


<div class="viewcode-block" id="get_epoch"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.get_epoch">[docs]</a><span class="k">def</span> <span class="nf">get_epoch</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the epoch used by `.dates`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    epoch: str</span>
<span class="sd">        String for the epoch (parsable by `numpy.datetime64`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_epoch</span>

    <span class="k">if</span> <span class="n">_epoch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_epoch</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.epoch&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">_epoch</span></div>


<span class="k">def</span> <span class="nf">_to_ordinalf</span><span class="p">(</span><span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert :mod:`datetime` or :mod:`date` to the Gregorian date as UTC float</span>
<span class="sd">    days, preserving hours, minutes, seconds and microseconds.  Return value</span>
<span class="sd">    is a `float`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert to UTC</span>
    <span class="n">tzi</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="s1">&#39;tzinfo&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tzi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="n">UTC</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">dt64</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_dt64_to_ordinalf</span><span class="p">(</span><span class="n">dt64</span><span class="p">)</span>


<span class="c1"># a version of _to_ordinalf that can operate on numpy arrays</span>
<span class="n">_to_ordinalf_np_vectorized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">_to_ordinalf</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_dt64_to_ordinalf</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert `numpy.datetime64` or an ndarray of those types to Gregorian</span>
<span class="sd">    date as UTC float relative to the epoch (see `.get_epoch`).  Roundoff</span>
<span class="sd">    is float64 precision.  Practically: microseconds for dates between</span>
<span class="sd">    290301 BC, 294241 AD, milliseconds for larger dates</span>
<span class="sd">    (see `numpy.datetime64`).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># the &quot;extra&quot; ensures that we at least allow the dynamic range out to</span>
    <span class="c1"># seconds.  That should get out to +/-2e11 years.</span>
    <span class="n">dseconds</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[s]&#39;</span><span class="p">)</span>
    <span class="n">extra</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="n">dseconds</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;timedelta64[ns]&#39;</span><span class="p">)</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">get_epoch</span><span class="p">(),</span> <span class="s1">&#39;s&#39;</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">dseconds</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">+=</span> <span class="n">extra</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.0e9</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">/</span> <span class="n">SEC_PER_DAY</span>

    <span class="n">NaT_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;NaT&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">d_int</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">dt</span><span class="p">[</span><span class="n">d_int</span> <span class="o">==</span> <span class="n">NaT_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">d_int</span> <span class="o">==</span> <span class="n">NaT_int</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">dt</span>


<span class="k">def</span> <span class="nf">_from_ordinalf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Gregorian float of the date, preserving hours, minutes,</span>
<span class="sd">    seconds and microseconds.  Return value is a `.datetime`.</span>

<span class="sd">    The input date *x* is a float in ordinal days at UTC, and the output will</span>
<span class="sd">    be the specified `.datetime` object corresponding to that time in</span>
<span class="sd">    timezone *tz*, or if *tz* is ``None``, in the timezone specified in</span>
<span class="sd">    :rc:`timezone`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">_get_rc_timezone</span><span class="p">()</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">get_epoch</span><span class="p">())</span> <span class="o">+</span>
          <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">MUSECONDS_PER_DAY</span><span class="p">)),</span> <span class="s1">&#39;us&#39;</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">dt</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;0001-01-01&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">dt</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;10000-01-01&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Date ordinal </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1"> converts to </span><span class="si">{</span><span class="n">dt</span><span class="si">}</span><span class="s1"> (using &#39;</span>
                         <span class="sa">f</span><span class="s1">&#39;epoch </span><span class="si">{</span><span class="n">get_epoch</span><span class="p">()</span><span class="si">}</span><span class="s1">), but Matplotlib dates must be &#39;</span>
                          <span class="s1">&#39;between year 0001 and 9999.&#39;</span><span class="p">)</span>
    <span class="c1"># convert from datetime64 to datetime:</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="c1"># datetime64 is always UTC:</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="n">dateutil</span><span class="o">.</span><span class="n">tz</span><span class="o">.</span><span class="n">gettz</span><span class="p">(</span><span class="s1">&#39;UTC&#39;</span><span class="p">))</span>
    <span class="c1"># but maybe we are working in a different timezone so move.</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>
    <span class="c1"># fix round off errors</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">70</span> <span class="o">*</span> <span class="mi">365</span><span class="p">:</span>
        <span class="c1"># if x is big, round off to nearest twenty microseconds.</span>
        <span class="c1"># This avoids floating point roundoff error</span>
        <span class="n">ms</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)</span> <span class="o">*</span> <span class="mi">20</span>
        <span class="k">if</span> <span class="n">ms</span> <span class="o">==</span> <span class="mi">1000000</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">microsecond</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">microsecond</span><span class="o">=</span><span class="n">ms</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dt</span>


<span class="c1"># a version of _from_ordinalf that can operate on numpy arrays</span>
<span class="n">_from_ordinalf_np_vectorized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">_from_ordinalf</span><span class="p">,</span> <span class="n">otypes</span><span class="o">=</span><span class="s2">&quot;O&quot;</span><span class="p">)</span>


<span class="c1"># a version of dateutil.parser.parse that can operate on numpy arrays</span>
<span class="n">_dateutil_parser_parse_np_vectorized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">dateutil</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">)</span>


<div class="viewcode-block" id="datestr2num"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.datestr2num">[docs]</a><span class="k">def</span> <span class="nf">datestr2num</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a date string to a datenum using `dateutil.parser.parse`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d : str or sequence of str</span>
<span class="sd">        The dates to convert.</span>

<span class="sd">    default : datetime.datetime, optional</span>
<span class="sd">        The default date to use when fields are missing in *d*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">dateutil</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">date2num</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="n">dateutil</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">d</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span>
        <span class="k">return</span> <span class="n">date2num</span><span class="p">(</span><span class="n">_dateutil_parser_parse_np_vectorized</span><span class="p">(</span><span class="n">d</span><span class="p">))</span></div>


<div class="viewcode-block" id="date2num"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.date2num">[docs]</a><span class="k">def</span> <span class="nf">date2num</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert datetime objects to Matplotlib dates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d : `datetime.datetime` or `numpy.datetime64` or sequences of these</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or sequence of floats</span>
<span class="sd">        Number of days since the epoch.  See `.get_epoch` for the</span>
<span class="sd">        epoch, which can be changed by :rc:`date.epoch` or `.set_epoch`.  If</span>
<span class="sd">        the epoch is &quot;1970-01-01T00:00:00&quot; (default) then noon Jan 1 1970</span>
<span class="sd">        (&quot;1970-01-01T12:00:00&quot;) returns 0.5.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Gregorian calendar is assumed; this is not universal practice.</span>
<span class="sd">    For details see the module docstring.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s2">&quot;values&quot;</span><span class="p">):</span>
        <span class="c1"># this unpacks pandas series or dataframes...</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">values</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">)</span> <span class="ow">or</span>
                <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">))):</span>
            <span class="k">return</span> <span class="n">_dt64_to_ordinalf</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_to_ordinalf</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_dt64_to_ordinalf</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span>
        <span class="k">return</span> <span class="n">_to_ordinalf_np_vectorized</span><span class="p">(</span><span class="n">d</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">julian2num</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a Julian date (or sequence) to a Matplotlib date (or sequence).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    j : float or sequence of floats</span>
<span class="sd">        Julian dates (days relative to 4713 BC Jan 1, 12:00:00 Julian</span>
<span class="sd">        calendar or 4714 BC Nov 24, 12:00:00, proleptic Gregorian calendar).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or sequence of floats</span>
<span class="sd">        Matplotlib dates (days relative to `.get_epoch`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">get_epoch</span><span class="p">(),</span> <span class="s1">&#39;h&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="mf">24.</span>
    <span class="n">ep0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;0000-12-31T00:00:00&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="mf">24.</span>
    <span class="c1"># Julian offset defined above is relative to 0000-12-31, but we need</span>
    <span class="c1"># relative to our current epoch:</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">JULIAN_OFFSET</span> <span class="o">-</span> <span class="n">ep0</span> <span class="o">+</span> <span class="n">ep</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>  <span class="c1"># Handles both scalar &amp; nonscalar j.</span>


<span class="k">def</span> <span class="nf">num2julian</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a Matplotlib date (or sequence) to a Julian date (or sequence).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : float or sequence of floats</span>
<span class="sd">        Matplotlib dates (days relative to `.get_epoch`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or sequence of floats</span>
<span class="sd">        Julian dates (days relative to 4713 BC Jan 1, 12:00:00).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">get_epoch</span><span class="p">(),</span> <span class="s1">&#39;h&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="mf">24.</span>
    <span class="n">ep0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;0000-12-31T00:00:00&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="mf">24.</span>
    <span class="c1"># Julian offset defined above is relative to 0000-12-31, but we need</span>
    <span class="c1"># relative to our current epoch:</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">JULIAN_OFFSET</span> <span class="o">-</span> <span class="n">ep0</span> <span class="o">+</span> <span class="n">ep</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>  <span class="c1"># Handles both scalar &amp; nonscalar j.</span>


<div class="viewcode-block" id="num2date"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.num2date">[docs]</a><span class="k">def</span> <span class="nf">num2date</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Matplotlib dates to `~datetime.datetime` objects.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : float or sequence of floats</span>
<span class="sd">        Number of days (fraction part represents hours, minutes, seconds)</span>
<span class="sd">        since the epoch.  See `.get_epoch` for the</span>
<span class="sd">        epoch, which can be changed by :rc:`date.epoch` or `.set_epoch`.</span>
<span class="sd">    tz : str, optional</span>
<span class="sd">        Timezone of *x* (defaults to :rc:`timezone`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `~datetime.datetime` or sequence of `~datetime.datetime`</span>
<span class="sd">        Dates are returned in timezone *tz*.</span>

<span class="sd">        If *x* is a sequence, a sequence of `~datetime.datetime` objects will</span>
<span class="sd">        be returned.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The addition of one here is a historical artifact. Also, note that the</span>
<span class="sd">    Gregorian calendar is assumed; this is not universal practice.</span>
<span class="sd">    For details, see the module docstring.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">_get_rc_timezone</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">_from_ordinalf_np_vectorized</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></div>


<span class="n">_ordinalf_to_timedelta_np_vectorized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">x</span><span class="p">),</span> <span class="n">otypes</span><span class="o">=</span><span class="s2">&quot;O&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="num2timedelta"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.num2timedelta">[docs]</a><span class="k">def</span> <span class="nf">num2timedelta</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert number of days to a `~datetime.timedelta` object.</span>

<span class="sd">    If *x* is a sequence, a sequence of `~datetime.timedelta` objects will</span>
<span class="sd">    be returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : float, sequence of floats</span>
<span class="sd">        Number of days. The fraction part represents hours, minutes, seconds.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `datetime.timedelta` or list[`datetime.timedelta`]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_ordinalf_to_timedelta_np_vectorized</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></div>


<div class="viewcode-block" id="drange"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.drange">[docs]</a><span class="k">def</span> <span class="nf">drange</span><span class="p">(</span><span class="n">dstart</span><span class="p">,</span> <span class="n">dend</span><span class="p">,</span> <span class="n">delta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a sequence of equally spaced Matplotlib dates.</span>

<span class="sd">    The dates start at *dstart* and reach up to, but not including *dend*.</span>
<span class="sd">    They are spaced by *delta*.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dstart, dend : `~datetime.datetime`</span>
<span class="sd">        The date limits.</span>
<span class="sd">    delta : `datetime.timedelta`</span>
<span class="sd">        Spacing of the dates.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `numpy.array`</span>
<span class="sd">        A list floats representing Matplotlib dates.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">(</span><span class="n">dstart</span><span class="p">)</span>
    <span class="n">f2</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">(</span><span class="n">dend</span><span class="p">)</span>
    <span class="n">step</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">/</span> <span class="n">SEC_PER_DAY</span>

    <span class="c1"># calculate the difference between dend and dstart in times of delta</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">f2</span> <span class="o">-</span> <span class="n">f1</span><span class="p">)</span> <span class="o">/</span> <span class="n">step</span><span class="p">))</span>

    <span class="c1"># calculate end of the interval which will be generated</span>
    <span class="n">dinterval_end</span> <span class="o">=</span> <span class="n">dstart</span> <span class="o">+</span> <span class="n">num</span> <span class="o">*</span> <span class="n">delta</span>

    <span class="c1"># ensure, that an half open interval will be generated [dstart, dend)</span>
    <span class="k">if</span> <span class="n">dinterval_end</span> <span class="o">&gt;=</span> <span class="n">dend</span><span class="p">:</span>
        <span class="c1"># if the endpoint is greater than dend, just subtract one delta</span>
        <span class="n">dinterval_end</span> <span class="o">-=</span> <span class="n">delta</span>
        <span class="n">num</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="n">f2</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">(</span><span class="n">dinterval_end</span><span class="p">)</span>  <span class="c1"># new float-endpoint</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>

<span class="c1">## date tickers and formatters ###</span>


<div class="viewcode-block" id="DateFormatter"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.DateFormatter">[docs]</a><span class="k">class</span> <span class="nc">DateFormatter</span><span class="p">(</span><span class="n">ticker</span><span class="o">.</span><span class="n">Formatter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Format a tick (in days since the epoch) with a</span>
<span class="sd">    `~datetime.datetime.strftime` format string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;3.3&quot;</span><span class="p">)</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">illegal_s</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;((^|[^%])(</span><span class="si">%%</span><span class="s2">)*</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fmt : str</span>
<span class="sd">            `~datetime.datetime.strftime` format string</span>
<span class="sd">        tz : `datetime.tzinfo`, default: :rc:`timezone`</span>
<span class="sd">            Ticks timezone.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tz</span> <span class="o">=</span> <span class="n">_get_rc_timezone</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="o">=</span> <span class="n">tz</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">num2date</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="p">)</span>

<div class="viewcode-block" id="DateFormatter.set_tzinfo"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.DateFormatter.set_tzinfo">[docs]</a>    <span class="k">def</span> <span class="nf">set_tzinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="o">=</span> <span class="n">tz</span></div></div>


<div class="viewcode-block" id="IndexDateFormatter"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.IndexDateFormatter">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;3.3&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">IndexDateFormatter</span><span class="p">(</span><span class="n">ticker</span><span class="o">.</span><span class="n">Formatter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Use with `.IndexLocator` to cycle format strings by index.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        t : list of float</span>
<span class="sd">            A sequence of dates (floating point days).</span>
<span class="sd">        fmt : str</span>
<span class="sd">            A `~datetime.datetime.strftime` format string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tz</span> <span class="o">=</span> <span class="n">_get_rc_timezone</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="o">=</span> <span class="n">tz</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the label for time *x* at position *pos*.&quot;&quot;&quot;</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">ind</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ind</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span>
        <span class="k">return</span> <span class="n">num2date</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConciseDateFormatter"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.ConciseDateFormatter">[docs]</a><span class="k">class</span> <span class="nc">ConciseDateFormatter</span><span class="p">(</span><span class="n">ticker</span><span class="o">.</span><span class="n">Formatter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A `.Formatter` which attempts to figure out the best format to use for the</span>
<span class="sd">    date, and to make it as compact as possible, but still be complete. This is</span>
<span class="sd">    most useful when used with the `AutoDateLocator`::</span>

<span class="sd">    &gt;&gt;&gt; locator = AutoDateLocator()</span>
<span class="sd">    &gt;&gt;&gt; formatter = ConciseDateFormatter(locator)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    locator : `.ticker.Locator`</span>
<span class="sd">        Locator that this axis is using.</span>

<span class="sd">    tz : str, optional</span>
<span class="sd">        Passed to `.dates.date2num`.</span>

<span class="sd">    formats : list of 6 strings, optional</span>
<span class="sd">        Format strings for 6 levels of tick labelling: mostly years,</span>
<span class="sd">        months, days, hours, minutes, and seconds.  Strings use</span>
<span class="sd">        the same format codes as `~datetime.datetime.strftime`.  Default is</span>
<span class="sd">        ``[&#39;%Y&#39;, &#39;%b&#39;, &#39;%d&#39;, &#39;%H:%M&#39;, &#39;%H:%M&#39;, &#39;%S.%f&#39;]``</span>

<span class="sd">    zero_formats : list of 6 strings, optional</span>
<span class="sd">        Format strings for tick labels that are &quot;zeros&quot; for a given tick</span>
<span class="sd">        level.  For instance, if most ticks are months, ticks around 1 Jan 2005</span>
<span class="sd">        will be labeled &quot;Dec&quot;, &quot;2005&quot;, &quot;Feb&quot;.  The default is</span>
<span class="sd">        ``[&#39;&#39;, &#39;%Y&#39;, &#39;%b&#39;, &#39;%b-%d&#39;, &#39;%H:%M&#39;, &#39;%H:%M&#39;]``</span>

<span class="sd">    offset_formats : list of 6 strings, optional</span>
<span class="sd">        Format strings for the 6 levels that is applied to the &quot;offset&quot;</span>
<span class="sd">        string found on the right side of an x-axis, or top of a y-axis.</span>
<span class="sd">        Combined with the tick labels this should completely specify the</span>
<span class="sd">        date.  The default is::</span>

<span class="sd">            [&#39;&#39;, &#39;%Y&#39;, &#39;%Y-%b&#39;, &#39;%Y-%b-%d&#39;, &#39;%Y-%b-%d&#39;, &#39;%Y-%b-%d %H:%M&#39;]</span>

<span class="sd">    show_offset : bool, default: True</span>
<span class="sd">        Whether to show the offset or not.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    See :doc:`/gallery/ticks_and_spines/date_concise_formatter`</span>

<span class="sd">    .. plot::</span>

<span class="sd">        import datetime</span>
<span class="sd">        import matplotlib.dates as mdates</span>

<span class="sd">        base = datetime.datetime(2005, 2, 1)</span>
<span class="sd">        dates = np.array([base + datetime.timedelta(hours=(2 * i))</span>
<span class="sd">                          for i in range(732)])</span>
<span class="sd">        N = len(dates)</span>
<span class="sd">        np.random.seed(19680801)</span>
<span class="sd">        y = np.cumsum(np.random.randn(N))</span>

<span class="sd">        fig, ax = plt.subplots(constrained_layout=True)</span>
<span class="sd">        locator = mdates.AutoDateLocator()</span>
<span class="sd">        formatter = mdates.ConciseDateFormatter(locator)</span>
<span class="sd">        ax.xaxis.set_major_locator(locator)</span>
<span class="sd">        ax.xaxis.set_major_formatter(formatter)</span>

<span class="sd">        ax.plot(dates, y)</span>
<span class="sd">        ax.set_title(&#39;Concise Date Formatter&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locator</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">formats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset_formats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">zero_formats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_offset</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Autoformat the date labels.  The default format is used to form an</span>
<span class="sd">        initial string, and then redundant elements are removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locator</span> <span class="o">=</span> <span class="n">locator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tz</span> <span class="o">=</span> <span class="n">tz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defaultfmt</span> <span class="o">=</span> <span class="s1">&#39;%Y&#39;</span>
        <span class="c1"># there are 6 levels with each level getting a specific format</span>
        <span class="c1"># 0: mostly years,  1: months,  2: days,</span>
        <span class="c1"># 3: hours, 4: minutes, 5: seconds</span>
        <span class="k">if</span> <span class="n">formats</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">formats</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;formats argument must be a list of &#39;</span>
                                 <span class="s1">&#39;6 format strings (or None)&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">formats</span> <span class="o">=</span> <span class="n">formats</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">formats</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;%Y&#39;</span><span class="p">,</span>  <span class="c1"># ticks are mostly years</span>
                            <span class="s1">&#39;%b&#39;</span><span class="p">,</span>          <span class="c1"># ticks are mostly months</span>
                            <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span>          <span class="c1"># ticks are mostly days</span>
                            <span class="s1">&#39;%H:%M&#39;</span><span class="p">,</span>       <span class="c1"># hrs</span>
                            <span class="s1">&#39;%H:%M&#39;</span><span class="p">,</span>       <span class="c1"># min</span>
                            <span class="s1">&#39;%S.</span><span class="si">%f</span><span class="s1">&#39;</span><span class="p">,</span>       <span class="c1"># secs</span>
                            <span class="p">]</span>
        <span class="c1"># fmt for zeros ticks at this level.  These are</span>
        <span class="c1"># ticks that should be labeled w/ info the level above.</span>
        <span class="c1"># like 1 Jan can just be labelled &quot;Jan&quot;.  02:02:00 can</span>
        <span class="c1"># just be labeled 02:02.</span>
        <span class="k">if</span> <span class="n">zero_formats</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zero_formats</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;zero_formats argument must be a list of &#39;</span>
                                 <span class="s1">&#39;6 format strings (or None)&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zero_formats</span> <span class="o">=</span> <span class="n">zero_formats</span>
        <span class="k">elif</span> <span class="n">formats</span><span class="p">:</span>
            <span class="c1"># use the users formats for the zero tick formats</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zero_formats</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">formats</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># make the defaults a bit nicer:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zero_formats</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">formats</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zero_formats</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;%b-</span><span class="si">%d</span><span class="s1">&#39;</span>

        <span class="k">if</span> <span class="n">offset_formats</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">offset_formats</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;offsetfmts argument must be a list of &#39;</span>
                                 <span class="s1">&#39;6 format strings (or None)&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offset_formats</span> <span class="o">=</span> <span class="n">offset_formats</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offset_formats</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;%Y&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;%Y-%b&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;%Y-%b-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;%Y-%b-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">,</span>
                                   <span class="s1">&#39;%Y-%b-</span><span class="si">%d</span><span class="s1"> %H:%M&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset_string</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">show_offset</span> <span class="o">=</span> <span class="n">show_offset</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">formatter</span> <span class="o">=</span> <span class="n">DateFormatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defaultfmt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tz</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">formatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">)</span>

<div class="viewcode-block" id="ConciseDateFormatter.format_ticks"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.ConciseDateFormatter.format_ticks">[docs]</a>    <span class="k">def</span> <span class="nf">format_ticks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">tickdatetime</span> <span class="o">=</span> <span class="p">[</span><span class="n">num2date</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_tz</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
        <span class="n">tickdate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tdt</span><span class="o">.</span><span class="n">timetuple</span><span class="p">()[:</span><span class="mi">6</span><span class="p">]</span> <span class="k">for</span> <span class="n">tdt</span> <span class="ow">in</span> <span class="n">tickdatetime</span><span class="p">])</span>

        <span class="c1"># basic algorithm:</span>
        <span class="c1"># 1) only display a part of the date if it changes over the ticks.</span>
        <span class="c1"># 2) don&#39;t display the smaller part of the date if:</span>
        <span class="c1">#    it is always the same or if it is the start of the</span>
        <span class="c1">#    year, month, day etc.</span>
        <span class="c1"># fmt for most ticks at this level</span>
        <span class="n">fmts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">formats</span>
        <span class="c1"># format beginnings of days, months, years, etc...</span>
        <span class="n">zerofmts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero_formats</span>
        <span class="c1"># offset fmt are for the offset in the upper left of the</span>
        <span class="c1"># or lower right of the axis.</span>
        <span class="n">offsetfmts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset_formats</span>

        <span class="c1"># determine the level we will label at:</span>
        <span class="c1"># mostly 0: years,  1: months,  2: days,</span>
        <span class="c1"># 3: hours, 4: minutes, 5: seconds, 6: microseconds</span>
        <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">tickdate</span><span class="p">[:,</span> <span class="n">level</span><span class="p">]))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># level is the basic level we will label at.</span>
        <span class="c1"># now loop through and decide the actual ticklabels</span>
        <span class="n">zerovals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">tickdate</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tickdate</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tickdate</span><span class="p">[</span><span class="n">nn</span><span class="p">][</span><span class="n">level</span><span class="p">]</span> <span class="o">==</span> <span class="n">zerovals</span><span class="p">[</span><span class="n">level</span><span class="p">]:</span>
                    <span class="n">fmt</span> <span class="o">=</span> <span class="n">zerofmts</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fmt</span> <span class="o">=</span> <span class="n">fmts</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># special handling for seconds + microseconds</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">tickdatetime</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span><span class="o">.</span><span class="n">second</span> <span class="o">==</span> <span class="n">tickdatetime</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span><span class="o">.</span><span class="n">microsecond</span>
                        <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">fmt</span> <span class="o">=</span> <span class="n">zerofmts</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fmt</span> <span class="o">=</span> <span class="n">fmts</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>
            <span class="n">labels</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span> <span class="o">=</span> <span class="n">tickdatetime</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span>

        <span class="c1"># special handling of seconds and microseconds:</span>
        <span class="c1"># strip extra zeros and decimal if possible.</span>
        <span class="c1"># this is complicated by two factors.  1) we have some level-4 strings</span>
        <span class="c1"># here (i.e. 03:00, &#39;0.50000&#39;, &#39;1.000&#39;) 2) we would like to have the</span>
        <span class="c1"># same number of decimals for each string (i.e. 0.5 and 1.0).</span>
        <span class="k">if</span> <span class="n">level</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">trailing_zeros</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">))</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">labels</span> <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">s</span><span class="p">),</span>
                <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">trailing_zeros</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">[</span><span class="n">nn</span><span class="p">]:</span>
                        <span class="n">labels</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">nn</span><span class="p">][:</span><span class="o">-</span><span class="n">trailing_zeros</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_offset</span><span class="p">:</span>
            <span class="c1"># set the offset string:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offset_string</span> <span class="o">=</span> <span class="n">tickdatetime</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">offsetfmts</span><span class="p">[</span><span class="n">level</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">labels</span></div>

<div class="viewcode-block" id="ConciseDateFormatter.get_offset"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.ConciseDateFormatter.get_offset">[docs]</a>    <span class="k">def</span> <span class="nf">get_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset_string</span></div>

<div class="viewcode-block" id="ConciseDateFormatter.format_data_short"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.ConciseDateFormatter.format_data_short">[docs]</a>    <span class="k">def</span> <span class="nf">format_data_short</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">num2date</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_tz</span><span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="AutoDateFormatter"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.AutoDateFormatter">[docs]</a><span class="k">class</span> <span class="nc">AutoDateFormatter</span><span class="p">(</span><span class="n">ticker</span><span class="o">.</span><span class="n">Formatter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A `.Formatter` which attempts to figure out the best format to use.  This</span>
<span class="sd">    is most useful when used with the `AutoDateLocator`.</span>

<span class="sd">    The AutoDateFormatter has a scale dictionary that maps the scale</span>
<span class="sd">    of the tick (the distance in days between one major tick) and a</span>
<span class="sd">    format string.  The default looks like this::</span>

<span class="sd">        self.scaled = {</span>
<span class="sd">            DAYS_PER_YEAR: rcParams[&#39;date.autoformat.year&#39;],</span>
<span class="sd">            DAYS_PER_MONTH: rcParams[&#39;date.autoformat.month&#39;],</span>
<span class="sd">            1.0: rcParams[&#39;date.autoformat.day&#39;],</span>
<span class="sd">            1. / HOURS_PER_DAY: rcParams[&#39;date.autoformat.hour&#39;],</span>
<span class="sd">            1. / (MINUTES_PER_DAY): rcParams[&#39;date.autoformat.minute&#39;],</span>
<span class="sd">            1. / (SEC_PER_DAY): rcParams[&#39;date.autoformat.second&#39;],</span>
<span class="sd">            1. / (MUSECONDS_PER_DAY): rcParams[&#39;date.autoformat.microsecond&#39;],</span>
<span class="sd">        }</span>

<span class="sd">    The algorithm picks the key in the dictionary that is &gt;= the</span>
<span class="sd">    current scale and uses that format string.  You can customize this</span>
<span class="sd">    dictionary by doing::</span>

<span class="sd">    &gt;&gt;&gt; locator = AutoDateLocator()</span>
<span class="sd">    &gt;&gt;&gt; formatter = AutoDateFormatter(locator)</span>
<span class="sd">    &gt;&gt;&gt; formatter.scaled[1/(24.*60.)] = &#39;%M:%S&#39; # only show min and sec</span>

<span class="sd">    A custom `.FuncFormatter` can also be used.  The following example shows</span>
<span class="sd">    how to use a custom format function to strip trailing zeros from decimal</span>
<span class="sd">    seconds and adds the date to the first ticklabel::</span>

<span class="sd">        &gt;&gt;&gt; def my_format_function(x, pos=None):</span>
<span class="sd">        ...     x = matplotlib.dates.num2date(x)</span>
<span class="sd">        ...     if pos == 0:</span>
<span class="sd">        ...         fmt = &#39;%D %H:%M:%S.%f&#39;</span>
<span class="sd">        ...     else:</span>
<span class="sd">        ...         fmt = &#39;%H:%M:%S.%f&#39;</span>
<span class="sd">        ...     label = x.strftime(fmt)</span>
<span class="sd">        ...     label = label.rstrip(&quot;0&quot;)</span>
<span class="sd">        ...     label = label.rstrip(&quot;.&quot;)</span>
<span class="sd">        ...     return label</span>
<span class="sd">        &gt;&gt;&gt; from matplotlib.ticker import FuncFormatter</span>
<span class="sd">        &gt;&gt;&gt; formatter.scaled[1/(24.*60.)] = FuncFormatter(my_format_function)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This can be improved by providing some user-level direction on</span>
    <span class="c1"># how to choose the best format (precedence, etc...)</span>

    <span class="c1"># Perhaps a &#39;struct&#39; that has a field for each time-type where a</span>
    <span class="c1"># zero would indicate &quot;don&#39;t show&quot; and a number would indicate</span>
    <span class="c1"># &quot;show&quot; with some sort of priority.  Same priorities could mean</span>
    <span class="c1"># show all with the same priority.</span>

    <span class="c1"># Or more simply, perhaps just a format string for each</span>
    <span class="c1"># possibility...</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locator</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">defaultfmt</span><span class="o">=</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Autoformat the date labels.  The default format is the one to use</span>
<span class="sd">        if none of the values in ``self.scaled`` are greater than the unit</span>
<span class="sd">        returned by ``locator._get_unit()``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locator</span> <span class="o">=</span> <span class="n">locator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tz</span> <span class="o">=</span> <span class="n">tz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defaultfmt</span> <span class="o">=</span> <span class="n">defaultfmt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_formatter</span> <span class="o">=</span> <span class="n">DateFormatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defaultfmt</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span>
        <span class="n">rcParams</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">rcParams</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">DAYS_PER_YEAR</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.autoformatter.year&#39;</span><span class="p">],</span>
            <span class="n">DAYS_PER_MONTH</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.autoformatter.month&#39;</span><span class="p">],</span>
            <span class="mi">1</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.autoformatter.day&#39;</span><span class="p">],</span>
            <span class="mi">1</span> <span class="o">/</span> <span class="n">HOURS_PER_DAY</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.autoformatter.hour&#39;</span><span class="p">],</span>
            <span class="mi">1</span> <span class="o">/</span> <span class="n">MINUTES_PER_DAY</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.autoformatter.minute&#39;</span><span class="p">],</span>
            <span class="mi">1</span> <span class="o">/</span> <span class="n">SEC_PER_DAY</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.autoformatter.second&#39;</span><span class="p">],</span>
            <span class="mi">1</span> <span class="o">/</span> <span class="n">MUSECONDS_PER_DAY</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.autoformatter.microsecond&#39;</span><span class="p">]</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">_set_locator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locator</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locator</span> <span class="o">=</span> <span class="n">locator</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">locator_unit_scale</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_locator</span><span class="o">.</span><span class="n">_get_unit</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">locator_unit_scale</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Pick the first scale which is greater than the locator unit.</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">fmt</span> <span class="k">for</span> <span class="n">scale</span><span class="p">,</span> <span class="n">fmt</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                    <span class="k">if</span> <span class="n">scale</span> <span class="o">&gt;=</span> <span class="n">locator_unit_scale</span><span class="p">),</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">defaultfmt</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_formatter</span> <span class="o">=</span> <span class="n">DateFormatter</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tz</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">fmt</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unexpected type passed to </span><span class="si">{0!r}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">result</span></div>


<span class="k">class</span> <span class="nc">rrulewrapper</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;freq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_tzinfo</span> <span class="o">=</span> <span class="n">tzinfo</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_rrule</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_rrule</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_rrule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">tzinfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_tzinfo</span>

        <span class="c1"># rrule does not play nicely with time zones - especially pytz time</span>
        <span class="c1"># zones, it&#39;s best to use naive zones and attach timezones once the</span>
        <span class="c1"># datetimes are returned</span>
        <span class="k">if</span> <span class="s1">&#39;dtstart&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">dtstart</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtstart&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dtstart</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tzinfo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tzinfo</span> <span class="o">=</span> <span class="n">dtstart</span><span class="o">.</span><span class="n">tzinfo</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dtstart</span> <span class="o">=</span> <span class="n">dtstart</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="n">tzinfo</span><span class="p">)</span>

                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtstart&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtstart</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;until&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">until</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;until&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">until</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">until</span> <span class="o">=</span> <span class="n">until</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="n">tzinfo</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;until cannot be aware if dtstart &#39;</span>
                                     <span class="s1">&#39;is naive and tzinfo is None&#39;</span><span class="p">)</span>

                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;until&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">until</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_construct</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tzinfo</span> <span class="o">=</span> <span class="n">tzinfo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rrule</span> <span class="o">=</span> <span class="n">rrule</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_attach_tzinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">tzinfo</span><span class="p">):</span>
        <span class="c1"># pytz zones are attached by &quot;localizing&quot; the datetime</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tzinfo</span><span class="p">,</span> <span class="s1">&#39;localize&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">tzinfo</span><span class="o">.</span><span class="n">localize</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">is_dst</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="n">tzinfo</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_aware_return_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">returns_list</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Decorator function that allows rrule methods to handle tzinfo.&quot;&quot;&quot;</span>
        <span class="c1"># This is only necessary if we&#39;re actually attaching a tzinfo</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tzinfo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span>

        <span class="c1"># All datetime arguments must be naive. If they are not naive, they are</span>
        <span class="c1"># converted to the _tzinfo zone before dropping the zone.</span>
        <span class="k">def</span> <span class="nf">normalize_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arg</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tzinfo</span><span class="p">:</span>
                    <span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tzinfo</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">arg</span>

        <span class="k">def</span> <span class="nf">normalize_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">normalize_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">kw</span><span class="p">:</span> <span class="n">normalize_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">kw</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

            <span class="k">return</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span>

        <span class="c1"># There are two kinds of functions we care about - ones that return</span>
        <span class="c1"># dates and ones that return lists of dates.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">returns_list</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">inner_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">normalize_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attach_tzinfo</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tzinfo</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">inner_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">normalize_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
                <span class="n">dts</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_attach_tzinfo</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tzinfo</span><span class="p">)</span> <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dts</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="n">inner_func</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="n">f</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rrule</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;after&#39;</span><span class="p">,</span> <span class="s1">&#39;before&#39;</span><span class="p">}:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aware_return_wrapper</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;xafter&#39;</span><span class="p">,</span> <span class="s1">&#39;xbefore&#39;</span><span class="p">,</span> <span class="s1">&#39;between&#39;</span><span class="p">}:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aware_return_wrapper</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">returns_list</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>


<div class="viewcode-block" id="DateLocator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.DateLocator">[docs]</a><span class="k">class</span> <span class="nc">DateLocator</span><span class="p">(</span><span class="n">ticker</span><span class="o">.</span><span class="n">Locator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines the tick locations when plotting dates.</span>

<span class="sd">    This class is subclassed by other Locators and</span>
<span class="sd">    is not meant to be used on its own.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hms0d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;byhour&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;byminute&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;bysecond&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tz : `datetime.tzinfo`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tz</span> <span class="o">=</span> <span class="n">_get_rc_timezone</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="o">=</span> <span class="n">tz</span>

<div class="viewcode-block" id="DateLocator.set_tzinfo"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.DateLocator.set_tzinfo">[docs]</a>    <span class="k">def</span> <span class="nf">set_tzinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set time zone info.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="o">=</span> <span class="n">tz</span></div>

<div class="viewcode-block" id="DateLocator.datalim_to_dt"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.DateLocator.datalim_to_dt">[docs]</a>    <span class="k">def</span> <span class="nf">datalim_to_dt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert axis data interval to datetime objects.&quot;&quot;&quot;</span>
        <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">get_data_interval</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dmin</span> <span class="o">&gt;</span> <span class="n">dmax</span><span class="p">:</span>
            <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="n">dmax</span><span class="p">,</span> <span class="n">dmin</span>

        <span class="k">return</span> <span class="n">num2date</span><span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">),</span> <span class="n">num2date</span><span class="p">(</span><span class="n">dmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span></div>

<div class="viewcode-block" id="DateLocator.viewlim_to_dt"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.DateLocator.viewlim_to_dt">[docs]</a>    <span class="k">def</span> <span class="nf">viewlim_to_dt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the view interval to datetime objects.&quot;&quot;&quot;</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">get_view_interval</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">vmin</span> <span class="o">&gt;</span> <span class="n">vmax</span><span class="p">:</span>
            <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">vmax</span><span class="p">,</span> <span class="n">vmin</span>
        <span class="k">return</span> <span class="n">num2date</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">),</span> <span class="n">num2date</span><span class="p">(</span><span class="n">vmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return how many days a unit of the locator is; used for</span>
<span class="sd">        intelligent autoscaling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_get_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of units for each tick.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

<div class="viewcode-block" id="DateLocator.nonsingular"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.DateLocator.nonsingular">[docs]</a>    <span class="k">def</span> <span class="nf">nonsingular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the proposed upper and lower extent, adjust the range</span>
<span class="sd">        if it is too close to being singular (i.e. a range of ~0).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">vmin</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">vmax</span><span class="p">):</span>
            <span class="c1"># Except if there is no data, then use 2000-2010 as default.</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">date2num</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                    <span class="n">date2num</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2010</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">vmax</span> <span class="o">&lt;</span> <span class="n">vmin</span><span class="p">:</span>
            <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">vmax</span><span class="p">,</span> <span class="n">vmin</span>
        <span class="n">unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_unit</span><span class="p">()</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_interval</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vmax</span> <span class="o">-</span> <span class="n">vmin</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">:</span>
            <span class="n">vmin</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">unit</span> <span class="o">*</span> <span class="n">interval</span>
            <span class="n">vmax</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">unit</span> <span class="o">*</span> <span class="n">interval</span>
        <span class="k">return</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span></div></div>


<div class="viewcode-block" id="RRuleLocator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.RRuleLocator">[docs]</a><span class="k">class</span> <span class="nc">RRuleLocator</span><span class="p">(</span><span class="n">DateLocator</span><span class="p">):</span>
    <span class="c1"># use the dateutil rrule instance</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">DateLocator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rule</span> <span class="o">=</span> <span class="n">o</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># if no data have been set, this will tank with a ValueError</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">viewlim_to_dt</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tick_values</span><span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span><span class="p">)</span>

<div class="viewcode-block" id="RRuleLocator.tick_values"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.RRuleLocator.tick_values">[docs]</a>    <span class="k">def</span> <span class="nf">tick_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">relativedelta</span><span class="p">(</span><span class="n">vmax</span><span class="p">,</span> <span class="n">vmin</span><span class="p">)</span>

        <span class="c1"># We need to cap at the endpoints of valid datetime</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">vmin</span> <span class="o">-</span> <span class="n">delta</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">):</span>
            <span class="c1"># cap</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                      <span class="n">tzinfo</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">vmax</span> <span class="o">+</span> <span class="n">delta</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">):</span>
            <span class="c1"># cap</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">9999</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span>
                                     <span class="n">tzinfo</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">timezone</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">dtstart</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">until</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>

        <span class="n">dates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">date2num</span><span class="p">([</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raise_if_exceeds</span><span class="p">(</span><span class="n">date2num</span><span class="p">(</span><span class="n">dates</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_get_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">_rrule</span><span class="o">.</span><span class="n">_freq</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unit_generic</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

<div class="viewcode-block" id="RRuleLocator.get_unit_generic"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.RRuleLocator.get_unit_generic">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_unit_generic</span><span class="p">(</span><span class="n">freq</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">YEARLY</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DAYS_PER_YEAR</span>
        <span class="k">elif</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">MONTHLY</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DAYS_PER_MONTH</span>
        <span class="k">elif</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">WEEKLY</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DAYS_PER_WEEK</span>
        <span class="k">elif</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">DAILY</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span>
        <span class="k">elif</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">HOURLY</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">HOURS_PER_DAY</span>
        <span class="k">elif</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">MINUTELY</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">MINUTES_PER_DAY</span>
        <span class="k">elif</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">SECONDLY</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">SEC_PER_DAY</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># error</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>   <span class="c1"># or should this just return &#39;1&#39;?</span></div>

    <span class="k">def</span> <span class="nf">_get_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">_rrule</span><span class="o">.</span><span class="n">_interval</span>

<div class="viewcode-block" id="RRuleLocator.autoscale"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.RRuleLocator.autoscale">[docs]</a>    <span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;3.2&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">autoscale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the view limits to include the data range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datalim_to_dt</span><span class="p">()</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">relativedelta</span><span class="p">(</span><span class="n">dmax</span><span class="p">,</span> <span class="n">dmin</span><span class="p">)</span>

        <span class="c1"># We need to cap at the endpoints of valid datetime</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">dmin</span> <span class="o">-</span> <span class="n">delta</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">_from_ordinalf</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">dmax</span> <span class="o">+</span> <span class="n">delta</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># The magic number!</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">_from_ordinalf</span><span class="p">(</span><span class="mf">3652059.9999999</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">dtstart</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">until</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>
        <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datalim_to_dt</span><span class="p">()</span>

        <span class="n">vmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">before</span><span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">vmin</span><span class="p">:</span>
            <span class="n">vmin</span> <span class="o">=</span> <span class="n">dmin</span>

        <span class="n">vmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">after</span><span class="p">(</span><span class="n">dmax</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">vmax</span><span class="p">:</span>
            <span class="n">vmax</span> <span class="o">=</span> <span class="n">dmax</span>

        <span class="n">vmin</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">(</span><span class="n">vmin</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">(</span><span class="n">vmax</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonsingular</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="AutoDateLocator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.AutoDateLocator">[docs]</a><span class="k">class</span> <span class="nc">AutoDateLocator</span><span class="p">(</span><span class="n">DateLocator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    On autoscale, this class picks the best `DateLocator` to set the view</span>
<span class="sd">    limits and the tick locations.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    intervald : dict</span>

<span class="sd">        Mapping of tick frequencies to multiples allowed for that ticking.</span>
<span class="sd">        The default is ::</span>

<span class="sd">            self.intervald = {</span>
<span class="sd">                YEARLY  : [1, 2, 4, 5, 10, 20, 40, 50, 100, 200, 400, 500,</span>
<span class="sd">                           1000, 2000, 4000, 5000, 10000],</span>
<span class="sd">                MONTHLY : [1, 2, 3, 4, 6],</span>
<span class="sd">                DAILY   : [1, 2, 3, 7, 14, 21],</span>
<span class="sd">                HOURLY  : [1, 2, 3, 4, 6, 12],</span>
<span class="sd">                MINUTELY: [1, 5, 10, 15, 30],</span>
<span class="sd">                SECONDLY: [1, 5, 10, 15, 30],</span>
<span class="sd">                MICROSECONDLY: [1, 2, 5, 10, 20, 50, 100, 200, 500,</span>
<span class="sd">                                1000, 2000, 5000, 10000, 20000, 50000,</span>
<span class="sd">                                100000, 200000, 500000, 1000000],</span>
<span class="sd">            }</span>

<span class="sd">        where the keys are defined in `dateutil.rrule`.</span>

<span class="sd">        The interval is used to specify multiples that are appropriate for</span>
<span class="sd">        the frequency of ticking. For instance, every 7 days is sensible</span>
<span class="sd">        for daily ticks, but for minutes/seconds, 15 or 30 make sense.</span>

<span class="sd">        When customizing, you should only modify the values for the existing</span>
<span class="sd">        keys. You should not add or delete entries.</span>

<span class="sd">        Example for forcing ticks every 3 hours::</span>

<span class="sd">            locator = AutoDateLocator()</span>
<span class="sd">            locator.intervald[HOURLY] = [3]  # only show every 3 hours</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minticks</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">maxticks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">interval_multiples</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tz : `datetime.tzinfo`</span>
<span class="sd">            Ticks timezone.</span>
<span class="sd">        minticks : int</span>
<span class="sd">            The minimum number of ticks desired; controls whether ticks occur</span>
<span class="sd">            yearly, monthly, etc.</span>
<span class="sd">        maxticks : int</span>
<span class="sd">            The maximum number of ticks desired; controls the interval between</span>
<span class="sd">            ticks (ticking every other, every 3, etc.).  For fine-grained</span>
<span class="sd">            control, this can be a dictionary mapping individual rrule</span>
<span class="sd">            frequency constants (YEARLY, MONTHLY, etc.) to their own maximum</span>
<span class="sd">            number of ticks.  This can be used to keep the number of ticks</span>
<span class="sd">            appropriate to the format chosen in `AutoDateFormatter`. Any</span>
<span class="sd">            frequency not specified in this dictionary is given a default</span>
<span class="sd">            value.</span>
<span class="sd">        interval_multiples : bool, default: True</span>
<span class="sd">            Whether ticks should be chosen to be multiple of the interval,</span>
<span class="sd">            locking them to &#39;nicer&#39; locations.  For example, this will force</span>
<span class="sd">            the ticks to be at hours 0, 6, 12, 18 when hourly ticking is done</span>
<span class="sd">            at 6 hour intervals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">DateLocator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="o">=</span> <span class="n">YEARLY</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">YEARLY</span><span class="p">,</span> <span class="n">MONTHLY</span><span class="p">,</span> <span class="n">DAILY</span><span class="p">,</span> <span class="n">HOURLY</span><span class="p">,</span> <span class="n">MINUTELY</span><span class="p">,</span>
                       <span class="n">SECONDLY</span><span class="p">,</span> <span class="n">MICROSECONDLY</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minticks</span> <span class="o">=</span> <span class="n">minticks</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">maxticks</span> <span class="o">=</span> <span class="p">{</span><span class="n">YEARLY</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="n">MONTHLY</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="n">DAILY</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="n">HOURLY</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span>
                         <span class="n">MINUTELY</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="n">SECONDLY</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="n">MICROSECONDLY</span><span class="p">:</span> <span class="mi">8</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">maxticks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">maxticks</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">maxticks</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># Assume we were given an integer. Use this as the maximum</span>
                <span class="c1"># number of ticks for every frequency and create a</span>
                <span class="c1"># dictionary for this</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">maxticks</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_freqs</span><span class="p">,</span> <span class="n">maxticks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interval_multiples</span> <span class="o">=</span> <span class="n">interval_multiples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intervald</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">YEARLY</span><span class="p">:</span>   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span>
                       <span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">4000</span><span class="p">,</span> <span class="mi">5000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">],</span>
            <span class="n">MONTHLY</span><span class="p">:</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
            <span class="n">DAILY</span><span class="p">:</span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">21</span><span class="p">],</span>
            <span class="n">HOURLY</span><span class="p">:</span>   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span>
            <span class="n">MINUTELY</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>
            <span class="n">SECONDLY</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>
            <span class="n">MICROSECONDLY</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span>
                            <span class="mi">5000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="mi">20000</span><span class="p">,</span> <span class="mi">50000</span><span class="p">,</span> <span class="mi">100000</span><span class="p">,</span> <span class="mi">200000</span><span class="p">,</span> <span class="mi">500000</span><span class="p">,</span>
                            <span class="mi">1000000</span><span class="p">],</span>
                            <span class="p">}</span>
        <span class="k">if</span> <span class="n">interval_multiples</span><span class="p">:</span>
            <span class="c1"># Swap &quot;3&quot; for &quot;4&quot; in the DAILY list; If we use 3 we get bad</span>
            <span class="c1"># tick loc for months w/ 31 days: 1, 4, ..., 28, 31, 1</span>
            <span class="c1"># If we use 4 then we get: 1, 5, ... 25, 29, 1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intervald</span><span class="p">[</span><span class="n">DAILY</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">21</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_byranges</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span>
                          <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">24</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span> <span class="kc">None</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">viewlim_to_dt</span><span class="p">()</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_locator</span><span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">locator</span><span class="p">()</span>

<div class="viewcode-block" id="AutoDateLocator.tick_values"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.AutoDateLocator.tick_values">[docs]</a>    <span class="k">def</span> <span class="nf">tick_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_locator</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span><span class="o">.</span><span class="n">tick_values</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span></div>

<div class="viewcode-block" id="AutoDateLocator.nonsingular"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.AutoDateLocator.nonsingular">[docs]</a>    <span class="k">def</span> <span class="nf">nonsingular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="c1"># whatever is thrown at us, we can scale the unit.</span>
        <span class="c1"># But default nonsingular date plots at an ~4 year period.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">vmin</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">vmax</span><span class="p">):</span>
            <span class="c1"># Except if there is no data, then use 2000-2010 as default.</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">date2num</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                    <span class="n">date2num</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2010</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">vmax</span> <span class="o">&lt;</span> <span class="n">vmin</span><span class="p">:</span>
            <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">vmax</span><span class="p">,</span> <span class="n">vmin</span>
        <span class="k">if</span> <span class="n">vmin</span> <span class="o">==</span> <span class="n">vmax</span><span class="p">:</span>
            <span class="n">vmin</span> <span class="o">=</span> <span class="n">vmin</span> <span class="o">-</span> <span class="n">DAYS_PER_YEAR</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="n">vmax</span> <span class="o">=</span> <span class="n">vmax</span> <span class="o">+</span> <span class="n">DAYS_PER_YEAR</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span></div>

    <span class="k">def</span> <span class="nf">_get_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="ow">in</span> <span class="p">[</span><span class="n">MICROSECONDLY</span><span class="p">]:</span>
            <span class="k">return</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">MUSECONDS_PER_DAY</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">RRuleLocator</span><span class="o">.</span><span class="n">get_unit_generic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">)</span>

<div class="viewcode-block" id="AutoDateLocator.autoscale"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.AutoDateLocator.autoscale">[docs]</a>    <span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;3.2&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">autoscale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Try to choose the view limits intelligently.&quot;&quot;&quot;</span>
        <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datalim_to_dt</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_locator</span><span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span><span class="p">)</span><span class="o">.</span><span class="n">autoscale</span><span class="p">()</span></div>

<div class="viewcode-block" id="AutoDateLocator.get_locator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.AutoDateLocator.get_locator">[docs]</a>    <span class="k">def</span> <span class="nf">get_locator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pick the best locator based on a distance.&quot;&quot;&quot;</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">relativedelta</span><span class="p">(</span><span class="n">dmax</span><span class="p">,</span> <span class="n">dmin</span><span class="p">)</span>
        <span class="n">tdelta</span> <span class="o">=</span> <span class="n">dmax</span> <span class="o">-</span> <span class="n">dmin</span>

        <span class="c1"># take absolute difference</span>
        <span class="k">if</span> <span class="n">dmin</span> <span class="o">&gt;</span> <span class="n">dmax</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="o">-</span><span class="n">delta</span>
            <span class="n">tdelta</span> <span class="o">=</span> <span class="o">-</span><span class="n">tdelta</span>

        <span class="c1"># The following uses a mix of calls to relativedelta and timedelta</span>
        <span class="c1"># methods because there is incomplete overlap in the functionality of</span>
        <span class="c1"># these similar functions, and it&#39;s best to avoid doing our own math</span>
        <span class="c1"># whenever possible.</span>
        <span class="n">numYears</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">delta</span><span class="o">.</span><span class="n">years</span><span class="p">)</span>
        <span class="n">numMonths</span> <span class="o">=</span> <span class="n">numYears</span> <span class="o">*</span> <span class="n">MONTHS_PER_YEAR</span> <span class="o">+</span> <span class="n">delta</span><span class="o">.</span><span class="n">months</span>
        <span class="n">numDays</span> <span class="o">=</span> <span class="n">tdelta</span><span class="o">.</span><span class="n">days</span>   <span class="c1"># Avoids estimates of days/month, days/year</span>
        <span class="n">numHours</span> <span class="o">=</span> <span class="n">numDays</span> <span class="o">*</span> <span class="n">HOURS_PER_DAY</span> <span class="o">+</span> <span class="n">delta</span><span class="o">.</span><span class="n">hours</span>
        <span class="n">numMinutes</span> <span class="o">=</span> <span class="n">numHours</span> <span class="o">*</span> <span class="n">MIN_PER_HOUR</span> <span class="o">+</span> <span class="n">delta</span><span class="o">.</span><span class="n">minutes</span>
        <span class="n">numSeconds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">tdelta</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">())</span>
        <span class="n">numMicroseconds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">tdelta</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1e6</span><span class="p">)</span>

        <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="n">numYears</span><span class="p">,</span> <span class="n">numMonths</span><span class="p">,</span> <span class="n">numDays</span><span class="p">,</span> <span class="n">numHours</span><span class="p">,</span> <span class="n">numMinutes</span><span class="p">,</span>
                <span class="n">numSeconds</span><span class="p">,</span> <span class="n">numMicroseconds</span><span class="p">]</span>

        <span class="n">use_rrule_locator</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">+</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span>

        <span class="c1"># Default setting of bymonth, etc. to pass to rrule</span>
        <span class="c1"># [unused (for year), bymonth, bymonthday, byhour, byminute,</span>
        <span class="c1">#  bysecond, unused (for microseconds)]</span>
        <span class="n">byranges</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="c1"># Loop over all the frequencies and try to find one that gives at</span>
        <span class="c1"># least a minticks tick positions.  Once this is found, look for</span>
        <span class="c1"># an interval from an list specific to that frequency that gives no</span>
        <span class="c1"># more than maxticks tick positions. Also, set up some ranges</span>
        <span class="c1"># (bymonth, etc.) as appropriate to be passed to rrulewrapper.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_freqs</span><span class="p">,</span> <span class="n">nums</span><span class="p">)):</span>
            <span class="c1"># If this particular frequency doesn&#39;t give enough ticks, continue</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minticks</span><span class="p">:</span>
                <span class="c1"># Since we&#39;re not using this particular frequency, set</span>
                <span class="c1"># the corresponding by_ to None so the rrule can act as</span>
                <span class="c1"># appropriate</span>
                <span class="n">byranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">continue</span>

            <span class="c1"># Find the first available interval that doesn&#39;t give too many</span>
            <span class="c1"># ticks</span>
            <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervald</span><span class="p">[</span><span class="n">freq</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="n">interval</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxticks</span><span class="p">[</span><span class="n">freq</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We went through the whole loop without breaking, default to</span>
                <span class="c1"># the last interval in the list and raise a warning</span>
                <span class="n">cbook</span><span class="o">.</span><span class="n">_warn_external</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;AutoDateLocator was unable to pick an appropriate &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;interval for this date range. It may be necessary to &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;add an interval value to the AutoDateLocator&#39;s &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;intervald dictionary. Defaulting to </span><span class="si">{</span><span class="n">interval</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

            <span class="c1"># Set some parameters as appropriate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="o">=</span> <span class="n">freq</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_byranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval_multiples</span><span class="p">:</span>
                <span class="n">byranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_byranges</span><span class="p">[</span><span class="n">i</span><span class="p">][::</span><span class="n">interval</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">DAILY</span><span class="p">,</span> <span class="n">WEEKLY</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">interval</span> <span class="o">==</span> <span class="mi">14</span><span class="p">:</span>
                        <span class="c1"># just make first and 15th.  Avoids 30th.</span>
                        <span class="n">byranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">interval</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
                        <span class="n">byranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">22</span><span class="p">]</span>

                <span class="n">interval</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">byranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_byranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">interval</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">freq</span> <span class="o">==</span> <span class="n">YEARLY</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval_multiples</span><span class="p">:</span>
            <span class="n">locator</span> <span class="o">=</span> <span class="n">YearLocator</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">use_rrule_locator</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">bymonth</span><span class="p">,</span> <span class="n">bymonthday</span><span class="p">,</span> <span class="n">byhour</span><span class="p">,</span> <span class="n">byminute</span><span class="p">,</span> <span class="n">bysecond</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">byranges</span>
            <span class="n">rrule</span> <span class="o">=</span> <span class="n">rrulewrapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span>
                                 <span class="n">dtstart</span><span class="o">=</span><span class="n">dmin</span><span class="p">,</span> <span class="n">until</span><span class="o">=</span><span class="n">dmax</span><span class="p">,</span>
                                 <span class="n">bymonth</span><span class="o">=</span><span class="n">bymonth</span><span class="p">,</span> <span class="n">bymonthday</span><span class="o">=</span><span class="n">bymonthday</span><span class="p">,</span>
                                 <span class="n">byhour</span><span class="o">=</span><span class="n">byhour</span><span class="p">,</span> <span class="n">byminute</span><span class="o">=</span><span class="n">byminute</span><span class="p">,</span>
                                 <span class="n">bysecond</span><span class="o">=</span><span class="n">bysecond</span><span class="p">)</span>

            <span class="n">locator</span> <span class="o">=</span> <span class="n">RRuleLocator</span><span class="p">(</span><span class="n">rrule</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">locator</span> <span class="o">=</span> <span class="n">MicrosecondLocator</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">date2num</span><span class="p">(</span><span class="n">dmin</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">70</span> <span class="o">*</span> <span class="mi">365</span> <span class="ow">and</span> <span class="n">interval</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">:</span>
                <span class="n">cbook</span><span class="o">.</span><span class="n">_warn_external</span><span class="p">(</span>
                    <span class="s1">&#39;Plotting microsecond time intervals for dates far from &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;the epoch (time origin: </span><span class="si">{</span><span class="n">get_epoch</span><span class="p">()</span><span class="si">}</span><span class="s1">) is not well-&#39;</span>
                    <span class="s1">&#39;supported. See matplotlib.dates.set_epoch to change the &#39;</span>
                    <span class="s1">&#39;epoch.&#39;</span><span class="p">)</span>

        <span class="n">locator</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">locator</span><span class="o">.</span><span class="n">set_view_interval</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">get_view_interval</span><span class="p">())</span>
            <span class="n">locator</span><span class="o">.</span><span class="n">set_data_interval</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">get_data_interval</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">locator</span></div></div>


<div class="viewcode-block" id="YearLocator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.YearLocator">[docs]</a><span class="k">class</span> <span class="nc">YearLocator</span><span class="p">(</span><span class="n">DateLocator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on a given day of each year that is a multiple of base.</span>

<span class="sd">    Examples::</span>

<span class="sd">      # Tick every year on Jan 1st</span>
<span class="sd">      locator = YearLocator()</span>

<span class="sd">      # Tick every 5 years on July 4th</span>
<span class="sd">      locator = YearLocator(5, month=7, day=4)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mark years that are multiple of base on a given month and day</span>
<span class="sd">        (default jan 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">DateLocator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">ticker</span><span class="o">.</span><span class="n">_Edge_integer</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replaced</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;month&#39;</span><span class="p">:</span>  <span class="n">month</span><span class="p">,</span>
                         <span class="s1">&#39;day&#39;</span><span class="p">:</span>    <span class="n">day</span><span class="p">,</span>
                         <span class="s1">&#39;hour&#39;</span><span class="p">:</span>   <span class="mi">0</span><span class="p">,</span>
                         <span class="s1">&#39;minute&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                         <span class="s1">&#39;second&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                         <span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tz</span><span class="p">,</span> <span class="s1">&#39;localize&#39;</span><span class="p">):</span>
            <span class="c1"># if tz is pytz, we need to do this w/ the localize fcn,</span>
            <span class="c1"># otherwise datetime.replace works fine...</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replaced</span><span class="p">[</span><span class="s1">&#39;tzinfo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tz</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># if no data have been set, this will tank with a ValueError</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">viewlim_to_dt</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tick_values</span><span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span><span class="p">)</span>

<div class="viewcode-block" id="YearLocator.tick_values"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.YearLocator.tick_values">[docs]</a>    <span class="k">def</span> <span class="nf">tick_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">vmin</span><span class="o">.</span><span class="n">year</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">step</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ge</span><span class="p">(</span><span class="n">vmax</span><span class="o">.</span><span class="n">year</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">step</span>

        <span class="n">vmin</span> <span class="o">=</span> <span class="n">vmin</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="n">ymin</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">replaced</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">,</span> <span class="s1">&#39;localize&#39;</span><span class="p">):</span>
            <span class="c1"># look after pytz</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vmin</span><span class="o">.</span><span class="n">tzinfo</span><span class="p">:</span>
                <span class="n">vmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="o">.</span><span class="n">localize</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">is_dst</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">ticks</span> <span class="o">=</span> <span class="p">[</span><span class="n">vmin</span><span class="p">]</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">ticks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dt</span><span class="o">.</span><span class="n">year</span> <span class="o">&gt;=</span> <span class="n">ymax</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">date2num</span><span class="p">(</span><span class="n">ticks</span><span class="p">)</span>
            <span class="n">year</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">year</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">step</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="n">year</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">replaced</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">,</span> <span class="s1">&#39;localize&#39;</span><span class="p">):</span>
                <span class="c1"># look after pytz</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">dt</span><span class="o">.</span><span class="n">tzinfo</span><span class="p">:</span>
                    <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="o">.</span><span class="n">localize</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">is_dst</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">ticks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span></div>

<div class="viewcode-block" id="YearLocator.autoscale"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.YearLocator.autoscale">[docs]</a>    <span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;3.2&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">autoscale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the view limits to include the data range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datalim_to_dt</span><span class="p">()</span>

        <span class="n">ymin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">dmin</span><span class="o">.</span><span class="n">year</span><span class="p">)</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ge</span><span class="p">(</span><span class="n">dmax</span><span class="o">.</span><span class="n">year</span><span class="p">)</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">dmin</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="n">ymin</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">replaced</span><span class="p">)</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">vmin</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">dmax</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="n">ymax</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">replaced</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">vmax</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>

        <span class="n">vmin</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">(</span><span class="n">vmin</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">(</span><span class="n">vmax</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonsingular</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="MonthLocator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.MonthLocator">[docs]</a><span class="k">class</span> <span class="nc">MonthLocator</span><span class="p">(</span><span class="n">RRuleLocator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on occurrences of each month, e.g., 1, 3, 12.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bymonth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bymonthday</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mark every month in *bymonth*; *bymonth* can be an int or</span>
<span class="sd">        sequence.  Default is ``range(1, 13)``, i.e. every month.</span>

<span class="sd">        *interval* is the interval between each iteration.  For</span>
<span class="sd">        example, if ``interval=2``, mark every second occurrence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bymonth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bymonth</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bymonth</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># This fixes a bug in dateutil &lt;= 2.3 which prevents the use of</span>
            <span class="c1"># numpy arrays in (among other things) the bymonthday, byweekday</span>
            <span class="c1"># and bymonth parameters.</span>
            <span class="n">bymonth</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bymonth</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>

        <span class="n">rule</span> <span class="o">=</span> <span class="n">rrulewrapper</span><span class="p">(</span><span class="n">MONTHLY</span><span class="p">,</span> <span class="n">bymonth</span><span class="o">=</span><span class="n">bymonth</span><span class="p">,</span> <span class="n">bymonthday</span><span class="o">=</span><span class="n">bymonthday</span><span class="p">,</span>
                            <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">hms0d</span><span class="p">)</span>
        <span class="n">RRuleLocator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span></div>


<div class="viewcode-block" id="WeekdayLocator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.WeekdayLocator">[docs]</a><span class="k">class</span> <span class="nc">WeekdayLocator</span><span class="p">(</span><span class="n">RRuleLocator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on occurrences of each weekday.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">byweekday</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mark every weekday in *byweekday*; *byweekday* can be a number or</span>
<span class="sd">        sequence.</span>

<span class="sd">        Elements of *byweekday* must be one of MO, TU, WE, TH, FR, SA,</span>
<span class="sd">        SU, the constants from :mod:`dateutil.rrule`, which have been</span>
<span class="sd">        imported into the :mod:`matplotlib.dates` namespace.</span>

<span class="sd">        *interval* specifies the number of weeks to skip.  For example,</span>
<span class="sd">        ``interval=2`` plots every second week.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">byweekday</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># This fixes a bug in dateutil &lt;= 2.3 which prevents the use of</span>
            <span class="c1"># numpy arrays in (among other things) the bymonthday, byweekday</span>
            <span class="c1"># and bymonth parameters.</span>
            <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">byweekday</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>

        <span class="n">rule</span> <span class="o">=</span> <span class="n">rrulewrapper</span><span class="p">(</span><span class="n">DAILY</span><span class="p">,</span> <span class="n">byweekday</span><span class="o">=</span><span class="n">byweekday</span><span class="p">,</span>
                            <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">hms0d</span><span class="p">)</span>
        <span class="n">RRuleLocator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span></div>


<div class="viewcode-block" id="DayLocator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.DayLocator">[docs]</a><span class="k">class</span> <span class="nc">DayLocator</span><span class="p">(</span><span class="n">RRuleLocator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on occurrences of each day of the month.  For example,</span>
<span class="sd">    1, 15, 30.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bymonthday</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mark every day in *bymonthday*; *bymonthday* can be an int or sequence.</span>

<span class="sd">        Default is to tick every day of the month: ``bymonthday=range(1, 32)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">interval</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span> <span class="ow">or</span> <span class="n">interval</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;interval must be an integer greater than 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bymonthday</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bymonthday</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bymonthday</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># This fixes a bug in dateutil &lt;= 2.3 which prevents the use of</span>
            <span class="c1"># numpy arrays in (among other things) the bymonthday, byweekday</span>
            <span class="c1"># and bymonth parameters.</span>
            <span class="n">bymonthday</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bymonthday</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>

        <span class="n">rule</span> <span class="o">=</span> <span class="n">rrulewrapper</span><span class="p">(</span><span class="n">DAILY</span><span class="p">,</span> <span class="n">bymonthday</span><span class="o">=</span><span class="n">bymonthday</span><span class="p">,</span>
                            <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">hms0d</span><span class="p">)</span>
        <span class="n">RRuleLocator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span></div>


<div class="viewcode-block" id="HourLocator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.HourLocator">[docs]</a><span class="k">class</span> <span class="nc">HourLocator</span><span class="p">(</span><span class="n">RRuleLocator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on occurrences of each hour.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">byhour</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mark every hour in *byhour*; *byhour* can be an int or sequence.</span>
<span class="sd">        Default is to tick every hour: ``byhour=range(24)``</span>

<span class="sd">        *interval* is the interval between each iteration.  For</span>
<span class="sd">        example, if ``interval=2``, mark every second occurrence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">byhour</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">byhour</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>

        <span class="n">rule</span> <span class="o">=</span> <span class="n">rrulewrapper</span><span class="p">(</span><span class="n">HOURLY</span><span class="p">,</span> <span class="n">byhour</span><span class="o">=</span><span class="n">byhour</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span>
                            <span class="n">byminute</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bysecond</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">RRuleLocator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span></div>


<div class="viewcode-block" id="MinuteLocator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.MinuteLocator">[docs]</a><span class="k">class</span> <span class="nc">MinuteLocator</span><span class="p">(</span><span class="n">RRuleLocator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on occurrences of each minute.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">byminute</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mark every minute in *byminute*; *byminute* can be an int or</span>
<span class="sd">        sequence.  Default is to tick every minute: ``byminute=range(60)``</span>

<span class="sd">        *interval* is the interval between each iteration.  For</span>
<span class="sd">        example, if ``interval=2``, mark every second occurrence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">byminute</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">byminute</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>

        <span class="n">rule</span> <span class="o">=</span> <span class="n">rrulewrapper</span><span class="p">(</span><span class="n">MINUTELY</span><span class="p">,</span> <span class="n">byminute</span><span class="o">=</span><span class="n">byminute</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span>
                            <span class="n">bysecond</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">RRuleLocator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span></div>


<div class="viewcode-block" id="SecondLocator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.SecondLocator">[docs]</a><span class="k">class</span> <span class="nc">SecondLocator</span><span class="p">(</span><span class="n">RRuleLocator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on occurrences of each second.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bysecond</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mark every second in *bysecond*; *bysecond* can be an int or</span>
<span class="sd">        sequence.  Default is to tick every second: ``bysecond = range(60)``</span>

<span class="sd">        *interval* is the interval between each iteration.  For</span>
<span class="sd">        example, if ``interval=2``, mark every second occurrence.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bysecond</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bysecond</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>

        <span class="n">rule</span> <span class="o">=</span> <span class="n">rrulewrapper</span><span class="p">(</span><span class="n">SECONDLY</span><span class="p">,</span> <span class="n">bysecond</span><span class="o">=</span><span class="n">bysecond</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">)</span>
        <span class="n">RRuleLocator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span></div>


<div class="viewcode-block" id="MicrosecondLocator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.MicrosecondLocator">[docs]</a><span class="k">class</span> <span class="nc">MicrosecondLocator</span><span class="p">(</span><span class="n">DateLocator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on regular intervals of one or more microsecond(s).</span>

<span class="sd">    .. note::</span>

<span class="sd">        By default, Matplotlib uses a floating point representation of time in</span>
<span class="sd">        days since the epoch, so plotting data with</span>
<span class="sd">        microsecond time resolution does not work well for</span>
<span class="sd">        dates that are far (about 70 years) from the epoch (check with</span>
<span class="sd">        `~.dates.get_epoch`).</span>

<span class="sd">        If you want sub-microsecond resolution time plots, it is strongly</span>
<span class="sd">        recommended to use floating point seconds, not datetime-like</span>
<span class="sd">        time representation.</span>

<span class="sd">        If you really must use datetime.datetime() or similar and still</span>
<span class="sd">        need microsecond precision, change the time origin via</span>
<span class="sd">        `.dates.set_epoch` to something closer to the dates being plotted.</span>
<span class="sd">        See :doc:`/gallery/ticks_and_spines/date_precision_and_epochs`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *interval* is the interval between each iteration.  For</span>
<span class="sd">        example, if ``interval=2``, mark every second microsecond.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interval</span> <span class="o">=</span> <span class="n">interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_locator</span> <span class="o">=</span> <span class="n">ticker</span><span class="o">.</span><span class="n">MultipleLocator</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="o">=</span> <span class="n">tz</span>

<div class="viewcode-block" id="MicrosecondLocator.set_axis"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.MicrosecondLocator.set_axis">[docs]</a>    <span class="k">def</span> <span class="nf">set_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_locator</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DateLocator</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="MicrosecondLocator.set_view_interval"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.MicrosecondLocator.set_view_interval">[docs]</a>    <span class="k">def</span> <span class="nf">set_view_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_locator</span><span class="o">.</span><span class="n">set_view_interval</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DateLocator</span><span class="o">.</span><span class="n">set_view_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span></div>

<div class="viewcode-block" id="MicrosecondLocator.set_data_interval"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.MicrosecondLocator.set_data_interval">[docs]</a>    <span class="k">def</span> <span class="nf">set_data_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_locator</span><span class="o">.</span><span class="n">set_data_interval</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DateLocator</span><span class="o">.</span><span class="n">set_data_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># if no data have been set, this will tank with a ValueError</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">viewlim_to_dt</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tick_values</span><span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span><span class="p">)</span>

<div class="viewcode-block" id="MicrosecondLocator.tick_values"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.MicrosecondLocator.tick_values">[docs]</a>    <span class="k">def</span> <span class="nf">tick_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="n">nmin</span><span class="p">,</span> <span class="n">nmax</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">((</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">))</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">nmin</span><span class="p">)</span>
        <span class="n">nmax</span> <span class="o">=</span> <span class="n">nmax</span> <span class="o">-</span> <span class="n">t0</span>
        <span class="n">nmin</span> <span class="o">=</span> <span class="n">nmin</span> <span class="o">-</span> <span class="n">t0</span>
        <span class="n">nmin</span> <span class="o">*=</span> <span class="n">MUSECONDS_PER_DAY</span>
        <span class="n">nmax</span> <span class="o">*=</span> <span class="n">MUSECONDS_PER_DAY</span>

        <span class="n">ticks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_locator</span><span class="o">.</span><span class="n">tick_values</span><span class="p">(</span><span class="n">nmin</span><span class="p">,</span> <span class="n">nmax</span><span class="p">)</span>

        <span class="n">ticks</span> <span class="o">=</span> <span class="n">ticks</span> <span class="o">/</span> <span class="n">MUSECONDS_PER_DAY</span> <span class="o">+</span> <span class="n">t0</span>
        <span class="k">return</span> <span class="n">ticks</span></div>

    <span class="k">def</span> <span class="nf">_get_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">MUSECONDS_PER_DAY</span>

    <span class="k">def</span> <span class="nf">_get_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interval</span></div>


<div class="viewcode-block" id="epoch2num"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.epoch2num">[docs]</a><span class="k">def</span> <span class="nf">epoch2num</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert UNIX time to days since Matplotlib epoch.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    e : list of floats</span>
<span class="sd">        Time in seconds since 1970-01-01.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `numpy.array`</span>
<span class="sd">        Time in days since Matplotlib epoch (see `~.dates.get_epoch()`).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;1970-01-01T00:00:00&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">)</span> <span class="o">-</span>
          <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">get_epoch</span><span class="p">(),</span> <span class="s1">&#39;s&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">dt</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="o">/</span> <span class="n">SEC_PER_DAY</span></div>


<div class="viewcode-block" id="num2epoch"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.num2epoch">[docs]</a><span class="k">def</span> <span class="nf">num2epoch</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert days since Matplotlib epoch to UNIX time.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d : list of floats</span>
<span class="sd">        Time in days since Matplotlib epoch (see `~.dates.get_epoch()`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `numpy.array`</span>
<span class="sd">        Time in seconds since 1970-01-01.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;1970-01-01T00:00:00&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">)</span> <span class="o">-</span>
          <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">get_epoch</span><span class="p">(),</span> <span class="s1">&#39;s&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">*</span> <span class="n">SEC_PER_DAY</span> <span class="o">-</span> <span class="n">dt</span></div>


<div class="viewcode-block" id="mx2num"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.mx2num">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;3.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">mx2num</span><span class="p">(</span><span class="n">mxdates</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert mx :class:`datetime` instance (or sequence of mx</span>
<span class="sd">    instances) to the new date format.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">scalar</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">mxdates</span><span class="p">):</span>
        <span class="n">scalar</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">mxdates</span> <span class="o">=</span> <span class="p">[</span><span class="n">mxdates</span><span class="p">]</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">epoch2num</span><span class="p">([</span><span class="n">m</span><span class="o">.</span><span class="n">ticks</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mxdates</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">scalar</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<span class="k">def</span> <span class="nf">date_ticker_factory</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numticks</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a date locator with *numticks* (approx) and a date formatter</span>
<span class="sd">    for *span* in days.  Return value is (locator, formatter).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">span</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">span</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">HOURS_PER_DAY</span>

    <span class="n">mins</span> <span class="o">=</span> <span class="n">span</span> <span class="o">*</span> <span class="n">MINUTES_PER_DAY</span>
    <span class="n">hrs</span> <span class="o">=</span> <span class="n">span</span> <span class="o">*</span> <span class="n">HOURS_PER_DAY</span>
    <span class="n">days</span> <span class="o">=</span> <span class="n">span</span>
    <span class="n">wks</span> <span class="o">=</span> <span class="n">span</span> <span class="o">/</span> <span class="n">DAYS_PER_WEEK</span>
    <span class="n">months</span> <span class="o">=</span> <span class="n">span</span> <span class="o">/</span> <span class="n">DAYS_PER_MONTH</span>      <span class="c1"># Approx</span>
    <span class="n">years</span> <span class="o">=</span> <span class="n">span</span> <span class="o">/</span> <span class="n">DAYS_PER_YEAR</span>        <span class="c1"># Approx</span>

    <span class="k">if</span> <span class="n">years</span> <span class="o">&gt;</span> <span class="n">numticks</span><span class="p">:</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">YearLocator</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">years</span> <span class="o">/</span> <span class="n">numticks</span><span class="p">),</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>  <span class="c1"># define</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;%Y&#39;</span>
    <span class="k">elif</span> <span class="n">months</span> <span class="o">&gt;</span> <span class="n">numticks</span><span class="p">:</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">MonthLocator</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;%b %Y&#39;</span>
    <span class="k">elif</span> <span class="n">wks</span> <span class="o">&gt;</span> <span class="n">numticks</span><span class="p">:</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">WeekdayLocator</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%a</span><span class="s1">, %b </span><span class="si">%d</span><span class="s1">&#39;</span>
    <span class="k">elif</span> <span class="n">days</span> <span class="o">&gt;</span> <span class="n">numticks</span><span class="p">:</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">DayLocator</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">days</span> <span class="o">/</span> <span class="n">numticks</span><span class="p">),</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;%b </span><span class="si">%d</span><span class="s1">&#39;</span>
    <span class="k">elif</span> <span class="n">hrs</span> <span class="o">&gt;</span> <span class="n">numticks</span><span class="p">:</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">HourLocator</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">hrs</span> <span class="o">/</span> <span class="n">numticks</span><span class="p">),</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;%H:%M</span><span class="se">\n</span><span class="s1">%b </span><span class="si">%d</span><span class="s1">&#39;</span>
    <span class="k">elif</span> <span class="n">mins</span> <span class="o">&gt;</span> <span class="n">numticks</span><span class="p">:</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">MinuteLocator</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">mins</span> <span class="o">/</span> <span class="n">numticks</span><span class="p">),</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;%H:%M:%S&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">MinuteLocator</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;%H:%M:%S&#39;</span>

    <span class="n">formatter</span> <span class="o">=</span> <span class="n">DateFormatter</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">locator</span><span class="p">,</span> <span class="n">formatter</span>


<div class="viewcode-block" id="DateConverter"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.DateConverter">[docs]</a><span class="k">class</span> <span class="nc">DateConverter</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">ConversionInterface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converter for `datetime.date` and `datetime.datetime` data, or for</span>
<span class="sd">    date/time data represented as it would be converted by `date2num`.</span>

<span class="sd">    The &#39;unit&#39; tag for such data is None or a tzinfo instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DateConverter.axisinfo"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.DateConverter.axisinfo">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">axisinfo</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the `~matplotlib.units.AxisInfo` for *unit*.</span>

<span class="sd">        *unit* is a tzinfo instance or None.</span>
<span class="sd">        The *axis* argument is required but not used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">unit</span>

        <span class="n">majloc</span> <span class="o">=</span> <span class="n">AutoDateLocator</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">majfmt</span> <span class="o">=</span> <span class="n">AutoDateFormatter</span><span class="p">(</span><span class="n">majloc</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">datemin</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">datemax</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2010</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">units</span><span class="o">.</span><span class="n">AxisInfo</span><span class="p">(</span><span class="n">majloc</span><span class="o">=</span><span class="n">majloc</span><span class="p">,</span> <span class="n">majfmt</span><span class="o">=</span><span class="n">majfmt</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                              <span class="n">default_limits</span><span class="o">=</span><span class="p">(</span><span class="n">datemin</span><span class="p">,</span> <span class="n">datemax</span><span class="p">))</span></div>

<div class="viewcode-block" id="DateConverter.convert"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.DateConverter.convert">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If *value* is not already a number or sequence of numbers, convert it</span>
<span class="sd">        with `date2num`.</span>

<span class="sd">        The *unit* and *axis* arguments are not used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">date2num</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="DateConverter.default_units"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.DateConverter.default_units">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">default_units</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the tzinfo instance of *x* or of its first element, or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_first_element</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">StopIteration</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">tzinfo</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="ConciseDateConverter"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.ConciseDateConverter">[docs]</a><span class="k">class</span> <span class="nc">ConciseDateConverter</span><span class="p">(</span><span class="n">DateConverter</span><span class="p">):</span>
    <span class="c1"># docstring inherited</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">formats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zero_formats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset_formats</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">show_offset</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_formats</span> <span class="o">=</span> <span class="n">formats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_zero_formats</span> <span class="o">=</span> <span class="n">zero_formats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset_formats</span> <span class="o">=</span> <span class="n">offset_formats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_show_offset</span> <span class="o">=</span> <span class="n">show_offset</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

<div class="viewcode-block" id="ConciseDateConverter.axisinfo"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.ConciseDateConverter.axisinfo">[docs]</a>    <span class="k">def</span> <span class="nf">axisinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="c1"># docstring inherited</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">unit</span>
        <span class="n">majloc</span> <span class="o">=</span> <span class="n">AutoDateLocator</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">majfmt</span> <span class="o">=</span> <span class="n">ConciseDateFormatter</span><span class="p">(</span><span class="n">majloc</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">,</span> <span class="n">formats</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_formats</span><span class="p">,</span>
                                      <span class="n">zero_formats</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_zero_formats</span><span class="p">,</span>
                                      <span class="n">offset_formats</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_offset_formats</span><span class="p">,</span>
                                      <span class="n">show_offset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_show_offset</span><span class="p">)</span>
        <span class="n">datemin</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">datemax</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2010</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">units</span><span class="o">.</span><span class="n">AxisInfo</span><span class="p">(</span><span class="n">majloc</span><span class="o">=</span><span class="n">majloc</span><span class="p">,</span> <span class="n">majfmt</span><span class="o">=</span><span class="n">majfmt</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                              <span class="n">default_limits</span><span class="o">=</span><span class="p">(</span><span class="n">datemin</span><span class="p">,</span> <span class="n">datemax</span><span class="p">))</span></div></div>


<span class="n">units</span><span class="o">.</span><span class="n">registry</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">]</span> <span class="o">=</span> <span class="n">DateConverter</span><span class="p">()</span>
<span class="n">units</span><span class="o">.</span><span class="n">registry</span><span class="p">[</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">]</span> <span class="o">=</span> <span class="n">DateConverter</span><span class="p">()</span>
<span class="n">units</span><span class="o">.</span><span class="n">registry</span><span class="p">[</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">]</span> <span class="o">=</span> <span class="n">DateConverter</span><span class="p">()</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer>
    <div class="footer">
    &copy; Copyright 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the Matplotlib development team; 2012 - 2020 The Matplotlib development team.
<br />
    Last updated on Aug 24, 2020.
Created using
<a href="http://sphinx-doc.org/">Sphinx</a> 3.2.1.
Doc version v3.3.1-dirty.
    </div>
</footer>
<script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-55954603-1', 'auto');
        ga('send', 'pageview');

</script>
  </body>
</html>