
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "gallery/images_contours_and_fields/image_antialiasing.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. meta::
        :keywords: codex

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_gallery_images_contours_and_fields_image_antialiasing.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_gallery_images_contours_and_fields_image_antialiasing.py:


==================
Image antialiasing
==================

Images are represented by discrete pixels, either on the screen or in an
image file.  When data that makes up the image has a different resolution
than its representation on the screen we will see aliasing effects.  How
noticeable these are depends on how much down-sampling takes place in
the change of resolution (if any).

When subsampling data, aliasing is reduced by smoothing first and then
subsampling the smoothed data.  In Matplotlib, we can do that
smoothing before mapping the data to colors, or we can do the smoothing
on the RGB(A) data in the final image.  The differences between these are
shown below, and controlled with the *interpolation_stage* keyword argument.

The default image interpolation in Matplotlib is 'antialiased', and
it is applied to the data.  This uses a
hanning interpolation on the data provided by the user for reduced aliasing
in most situations. Only when there is upsampling by a factor of 1, 2 or
>=3 is 'nearest' neighbor interpolation used.

Other anti-aliasing filters can be specified in `.Axes.imshow` using the
*interpolation* keyword argument.

.. GENERATED FROM PYTHON SOURCE LINES 27-31

.. code-block:: default


    import matplotlib.pyplot as plt
    import numpy as np








.. GENERATED FROM PYTHON SOURCE LINES 32-33

First we generate a 450x450 pixel image with varying frequency content:

.. GENERATED FROM PYTHON SOURCE LINES 33-49

.. code-block:: default

    N = 450
    x = np.arange(N) / N - 0.5
    y = np.arange(N) / N - 0.5
    aa = np.ones((N, N))
    aa[::2, :] = -1

    X, Y = np.meshgrid(x, y)
    R = np.sqrt(X**2 + Y**2)
    f0 = 5
    k = 100
    a = np.sin(np.pi * 2 * (f0 * R + k * R**2 / 2))
    # make the left hand side of this
    a[:int(N / 2), :][R[:int(N / 2), :] < 0.4] = -1
    a[:int(N / 2), :][R[:int(N / 2), :] < 0.3] = 1
    aa[:, int(N / 3):] = a[:, int(N / 3):]
    a = aa







.. GENERATED FROM PYTHON SOURCE LINES 50-68

The following images are subsampled from 450 data pixels to either
125 pixels or 250 pixels (depending on your display).
The Moiré patterns in the 'nearest' interpolation are caused by the
high-frequency data being subsampled.  The 'antialiased' imaged
still has some Moiré patterns as well, but they are greatly reduced.

There are substantial differences between the 'data' interpolation and
the 'rgba' interpolation.  The alternating bands of red and blue on the
left third of the image are subsampled.  By interpolating in 'data' space
(the default) the antialiasing filter makes the stripes close to white,
because the average of -1 and +1 is zero, and zero is white in this
colormap.

Conversely, when the anti-aliasing occurs in 'rgba' space, the red and
blue are combined visually to make purple.  This behaviour is more like a
typical image processing package, but note that purple is not in the
original colormap, so it is no longer possible to invert individual
pixels back to their data value.

.. GENERATED FROM PYTHON SOURCE LINES 68-83

.. code-block:: default


    fig, axs = plt.subplots(2, 2, figsize=(5, 6), layout='constrained')
    axs[0, 0].imshow(a, interpolation='nearest', cmap='RdBu_r')
    axs[0, 0].set_xlim(100, 200)
    axs[0, 0].set_ylim(275, 175)
    axs[0, 0].set_title('Zoom')

    for ax, interp, space in zip(axs.flat[1:],
                                 ['nearest', 'antialiased', 'antialiased'],
                                 ['data', 'data', 'rgba']):
        ax.imshow(a, interpolation=interp, interpolation_stage=space,
                  cmap='RdBu_r')
        ax.set_title(f"interpolation='{interp}'\nspace='{space}'")
    plt.show()




.. image-sg:: /gallery/images_contours_and_fields/images/sphx_glr_image_antialiasing_001.png
   :alt: Zoom, interpolation='nearest' space='data', interpolation='antialiased' space='data', interpolation='antialiased' space='rgba'
   :srcset: /gallery/images_contours_and_fields/images/sphx_glr_image_antialiasing_001.png, /gallery/images_contours_and_fields/images/sphx_glr_image_antialiasing_001_2_00x.png 2.00x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 84-91

Even up-sampling an image with 'nearest' interpolation will lead to Moiré
patterns when the upsampling factor is not integer. The following image
upsamples 500 data pixels to 530 rendered pixels. You may note a grid of
30 line-like artifacts which stem from the 524 - 500 = 24 extra pixels that
had to be made up. Since interpolation is 'nearest' they are the same as a
neighboring line of pixels and thus stretch the image locally so that it
looks distorted.

.. GENERATED FROM PYTHON SOURCE LINES 91-96

.. code-block:: default

    fig, ax = plt.subplots(figsize=(6.8, 6.8))
    ax.imshow(a, interpolation='nearest', cmap='gray')
    ax.set_title("upsampled by factor a 1.048, interpolation='nearest'")
    plt.show()




.. image-sg:: /gallery/images_contours_and_fields/images/sphx_glr_image_antialiasing_002.png
   :alt: upsampled by factor a 1.048, interpolation='nearest'
   :srcset: /gallery/images_contours_and_fields/images/sphx_glr_image_antialiasing_002.png, /gallery/images_contours_and_fields/images/sphx_glr_image_antialiasing_002_2_00x.png 2.00x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 97-98

Better antialiasing algorithms can reduce this effect:

.. GENERATED FROM PYTHON SOURCE LINES 98-103

.. code-block:: default

    fig, ax = plt.subplots(figsize=(6.8, 6.8))
    ax.imshow(a, interpolation='antialiased', cmap='gray')
    ax.set_title("upsampled by factor a 1.048, interpolation='antialiased'")
    plt.show()




.. image-sg:: /gallery/images_contours_and_fields/images/sphx_glr_image_antialiasing_003.png
   :alt: upsampled by factor a 1.048, interpolation='antialiased'
   :srcset: /gallery/images_contours_and_fields/images/sphx_glr_image_antialiasing_003.png, /gallery/images_contours_and_fields/images/sphx_glr_image_antialiasing_003_2_00x.png 2.00x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 104-107

Apart from the default 'hanning' antialiasing, `~.Axes.imshow` supports a
number of different interpolation algorithms, which may work better or
worse depending on the pattern.

.. GENERATED FROM PYTHON SOURCE LINES 107-113

.. code-block:: default

    fig, axs = plt.subplots(1, 2, figsize=(7, 4), layout='constrained')
    for ax, interp in zip(axs, ['hanning', 'lanczos']):
        ax.imshow(a, interpolation=interp, cmap='gray')
        ax.set_title(f"interpolation='{interp}'")
    plt.show()




.. image-sg:: /gallery/images_contours_and_fields/images/sphx_glr_image_antialiasing_004.png
   :alt: interpolation='hanning', interpolation='lanczos'
   :srcset: /gallery/images_contours_and_fields/images/sphx_glr_image_antialiasing_004.png, /gallery/images_contours_and_fields/images/sphx_glr_image_antialiasing_004_2_00x.png 2.00x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 114-120

.. admonition:: References

   The use of the following functions, methods, classes and modules is shown
   in this example:

   - `matplotlib.axes.Axes.imshow`


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 1.857 seconds)


.. _sphx_glr_download_gallery_images_contours_and_fields_image_antialiasing.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: image_antialiasing.py <image_antialiasing.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: image_antialiasing.ipynb <image_antialiasing.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
