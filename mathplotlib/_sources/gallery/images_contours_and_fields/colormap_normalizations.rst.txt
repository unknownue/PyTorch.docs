
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "gallery/images_contours_and_fields/colormap_normalizations.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. meta::
        :keywords: codex

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_gallery_images_contours_and_fields_colormap_normalizations.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_gallery_images_contours_and_fields_colormap_normalizations.py:


=======================
Colormap normalizations
=======================

Demonstration of using norm to map colormaps onto data in non-linear ways.

.. redirect-from:: /gallery/userdemo/colormap_normalizations

.. GENERATED FROM PYTHON SOURCE LINES 10-16

.. code-block:: default


    import matplotlib.pyplot as plt
    import numpy as np

    import matplotlib.colors as colors








.. GENERATED FROM PYTHON SOURCE LINES 17-19

Lognorm: Instead of pcolor log10(Z1) you can have colorbars that have
the exponential labels using a norm.

.. GENERATED FROM PYTHON SOURCE LINES 19-42

.. code-block:: default


    N = 100
    X, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]

    # A low hump with a spike coming out of the top.  Needs to have
    # z/colour axis on a log scale, so we see both hump and spike.
    # A linear scale only shows the spike.

    Z1 = np.exp(-X**2 - Y**2)
    Z2 = np.exp(-(X * 10)**2 - (Y * 10)**2)
    Z = Z1 + 50 * Z2

    fig, ax = plt.subplots(2, 1)

    pcm = ax[0].pcolor(X, Y, Z,
                       norm=colors.LogNorm(vmin=Z.min(), vmax=Z.max()),
                       cmap='PuBu_r', shading='nearest')
    fig.colorbar(pcm, ax=ax[0], extend='max')

    pcm = ax[1].pcolor(X, Y, Z, cmap='PuBu_r', shading='nearest')
    fig.colorbar(pcm, ax=ax[1], extend='max')





.. image-sg:: /gallery/images_contours_and_fields/images/sphx_glr_colormap_normalizations_001.png
   :alt: colormap normalizations
   :srcset: /gallery/images_contours_and_fields/images/sphx_glr_colormap_normalizations_001.png, /gallery/images_contours_and_fields/images/sphx_glr_colormap_normalizations_001_2_00x.png 2.00x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 43-45

PowerNorm: Here a power-law trend in X partially obscures a rectified
sine wave in Y. We can remove the power law using a PowerNorm.

.. GENERATED FROM PYTHON SOURCE LINES 45-58

.. code-block:: default


    X, Y = np.mgrid[0:3:complex(0, N), 0:2:complex(0, N)]
    Z1 = (1 + np.sin(Y * 10.)) * X**2

    fig, ax = plt.subplots(2, 1)

    pcm = ax[0].pcolormesh(X, Y, Z1, norm=colors.PowerNorm(gamma=1. / 2.),
                           cmap='PuBu_r', shading='nearest')
    fig.colorbar(pcm, ax=ax[0], extend='max')

    pcm = ax[1].pcolormesh(X, Y, Z1, cmap='PuBu_r', shading='nearest')
    fig.colorbar(pcm, ax=ax[1], extend='max')




.. image-sg:: /gallery/images_contours_and_fields/images/sphx_glr_colormap_normalizations_002.png
   :alt: colormap normalizations
   :srcset: /gallery/images_contours_and_fields/images/sphx_glr_colormap_normalizations_002.png, /gallery/images_contours_and_fields/images/sphx_glr_colormap_normalizations_002_2_00x.png 2.00x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 59-65

SymLogNorm: two humps, one negative and one positive, The positive
with 5-times the amplitude. Linearly, you cannot see detail in the
negative hump.  Here we logarithmically scale the positive and
negative data separately.

Note that colorbar labels do not come out looking very good.

.. GENERATED FROM PYTHON SOURCE LINES 65-81

.. code-block:: default


    X, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]
    Z = 5 * np.exp(-X**2 - Y**2)

    fig, ax = plt.subplots(2, 1)

    pcm = ax[0].pcolormesh(X, Y, Z,
                           norm=colors.SymLogNorm(linthresh=0.03, linscale=0.03,
                                                  vmin=-1.0, vmax=1.0, base=10),
                           cmap='RdBu_r', shading='nearest')
    fig.colorbar(pcm, ax=ax[0], extend='both')

    pcm = ax[1].pcolormesh(X, Y, Z, cmap='RdBu_r', vmin=-np.max(Z),
                           shading='nearest')
    fig.colorbar(pcm, ax=ax[1], extend='both')




.. image-sg:: /gallery/images_contours_and_fields/images/sphx_glr_colormap_normalizations_003.png
   :alt: colormap normalizations
   :srcset: /gallery/images_contours_and_fields/images/sphx_glr_colormap_normalizations_003.png, /gallery/images_contours_and_fields/images/sphx_glr_colormap_normalizations_003_2_00x.png 2.00x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 82-85

Custom Norm: An example with a customized normalization.  This one
uses the example above, and normalizes the negative data differently
from the positive.

.. GENERATED FROM PYTHON SOURCE LINES 85-107

.. code-block:: default


    X, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]
    Z1 = np.exp(-X**2 - Y**2)
    Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2)
    Z = (Z1 - Z2) * 2

    # Example of making your own norm.  Also see matplotlib.colors.
    # From Joe Kington: This one gives two different linear ramps:


    class MidpointNormalize(colors.Normalize):
        def __init__(self, vmin=None, vmax=None, midpoint=None, clip=False):
            self.midpoint = midpoint
            super().__init__(vmin, vmax, clip)

        def __call__(self, value, clip=None):
            # I'm ignoring masked values and all kinds of edge cases to make a
            # simple example...
            x, y = [self.vmin, self.midpoint, self.vmax], [0, 0.5, 1]
            return np.ma.masked_array(np.interp(value, x, y))









.. GENERATED FROM PYTHON SOURCE LINES 108-119

.. code-block:: default

    fig, ax = plt.subplots(2, 1)

    pcm = ax[0].pcolormesh(X, Y, Z,
                           norm=MidpointNormalize(midpoint=0.),
                           cmap='RdBu_r', shading='nearest')
    fig.colorbar(pcm, ax=ax[0], extend='both')

    pcm = ax[1].pcolormesh(X, Y, Z, cmap='RdBu_r', vmin=-np.max(Z),
                           shading='nearest')
    fig.colorbar(pcm, ax=ax[1], extend='both')




.. image-sg:: /gallery/images_contours_and_fields/images/sphx_glr_colormap_normalizations_004.png
   :alt: colormap normalizations
   :srcset: /gallery/images_contours_and_fields/images/sphx_glr_colormap_normalizations_004.png, /gallery/images_contours_and_fields/images/sphx_glr_colormap_normalizations_004_2_00x.png 2.00x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 120-123

BoundaryNorm: For this one you provide the boundaries for your colors,
and the Norm puts the first color in between the first pair, the
second color between the second pair, etc.

.. GENERATED FROM PYTHON SOURCE LINES 123-145

.. code-block:: default


    fig, ax = plt.subplots(3, 1, figsize=(8, 8))
    ax = ax.flatten()
    # even bounds gives a contour-like effect
    bounds = np.linspace(-1, 1, 10)
    norm = colors.BoundaryNorm(boundaries=bounds, ncolors=256)
    pcm = ax[0].pcolormesh(X, Y, Z,
                           norm=norm,
                           cmap='RdBu_r', shading='nearest')
    fig.colorbar(pcm, ax=ax[0], extend='both', orientation='vertical')

    # uneven bounds changes the colormapping:
    bounds = np.array([-0.25, -0.125, 0, 0.5, 1])
    norm = colors.BoundaryNorm(boundaries=bounds, ncolors=256)
    pcm = ax[1].pcolormesh(X, Y, Z, norm=norm, cmap='RdBu_r', shading='nearest')
    fig.colorbar(pcm, ax=ax[1], extend='both', orientation='vertical')

    pcm = ax[2].pcolormesh(X, Y, Z, cmap='RdBu_r', vmin=-np.max(Z1),
                           shading='nearest')
    fig.colorbar(pcm, ax=ax[2], extend='both', orientation='vertical')

    plt.show()



.. image-sg:: /gallery/images_contours_and_fields/images/sphx_glr_colormap_normalizations_005.png
   :alt: colormap normalizations
   :srcset: /gallery/images_contours_and_fields/images/sphx_glr_colormap_normalizations_005.png, /gallery/images_contours_and_fields/images/sphx_glr_colormap_normalizations_005_2_00x.png 2.00x
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 1.373 seconds)


.. _sphx_glr_download_gallery_images_contours_and_fields_colormap_normalizations.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: colormap_normalizations.py <colormap_normalizations.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: colormap_normalizations.ipynb <colormap_normalizations.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
